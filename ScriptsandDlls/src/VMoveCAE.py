#!/usr/bin/pythonpart_root

import os, sys, platform, locale
import wx
import wx.lib.inspection
import wx.lib.mixins.inspection
from constants import Const
#import wx.lib.customtreectrl as ct
import CustomTreeCtrl as ct
#import wx.lib.mixins.listctrl as listmix
# import CustomListCtrlMixins as listmix
from wx.lib.mixins.listctrl import CheckListCtrlMixin, ListCtrlAutoWidthMixin
# import wx.lib.mixins.listctrl as listmix
#import wx.lib.buttonpanel as bp
# from treepanels import PartTree, ResultTree
from wx.lib.wordwrap import wordwrap
if platform.python_version() < '2.7':
    import xml.parsers.expat
if platform.python_version() > '2.5':
    import xml.etree.ElementTree as et
else:
    import elementtree.ElementTree as et
import TriCheckListBox as tclb

import webbrowser
#import wx.adv.Wizard as wiz
from wx.adv import Wizard as wiz
from wx.adv import WizardPageSimple as WizardPageSimple
from wx.html import SimpleHtmlListBox
import wx.aui
import atexit
import CaeEngine
import Version
import Common
import Extractor
from threading import Thread
import time
import re
#wx.lib.embeddedimage.PyEmbeddedImage
from wx.lib.embeddedimage import PyEmbeddedImage
from InpFileReader import InpFileReader, InpFileError

VMoveCaeIcon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAHJJ"
    "REFUWIXtl0EKwCAQA7PF/39ZTz0UBBsNhNLk5GHBYXVcLAAdxlzOzQGg3YtVG4qsext7BwIQ"
    "gAC0dckzrOdygD55ieqAyn4EAbAD8BaINaABpvM4FgTgIPwlFFvwwQ6Ip5G9AwGwA2xoqPWw"
    "8Pff8QCRcAlTG+zVpAAAAABJRU5ErkJggg==")

VmoveCaeImg = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABHNCSVQICAgIfAhkiAAABZ9J"
    "REFUaIHNmU9oXEUcxz/vbZImsQlGTbA1tEXFQ/Fg8dIKQfGihQpR8OZBxYsK9dBzPIj2oAhF"
    "zEGsGFLQiFQKUvRQKmgRBKuthKApJlgCpYlp2jQxf3bfjIffTHbe7Htv32Y3m35hmbfvz+z3"
    "+/t95zczb4MgLJCFcyrSfwGngfNhIci8eRvQknXxrIr008AAMAXcpSJdAM7cQULCtAsnVKQP"
    "m+NW4E3gPqAdGFSRbgK3XAiSLHRMRfo4QtzF78AHQBuwDqyy/dmoEPC6ivR7wN0pD3wDfAV0"
    "mO8rQJHtExITMKgi/RHQX+Whd4HfgG7n3DrwL3CuyUI2xsCLKtJDVCcPcBR4CIm+RRsyRp5r"
    "8vjYEPAycCDnQ93AW4iN1p1PG9ADHGyiiBDgpFNx8qIfeAWIEOIu9gGPN0lE+I6K9KubfPhJ"
    "4BlgkXJlspl4EBhogohgHbRfLmtBEfgQKbEd3rUV4Dbw/RYO7LAe8iBzxRvA/ZQHtc1EB9BV"
    "5fkTKtIjKtJnVaSHNpGxQEND0jwBvE/ZQrbFHI85WTimIn0I2I0UhF5gBzADXAGeryFjwSzo"
    "3gYImDMCbiAD2xWCObcH6ATuBZ41AkqIDUFELAPfAa/lFBH+2gDyN4FhQAH3GILdDvk2xE47"
    "gL3m3AVk4nOxZu57Afgkp53Ci/UwR8h/BiwgNVmZtgvYRXm2XkdWtFcNySXgPDBLfM1ls3EE"
    "GM4hIiwBk3WQ/9gQs+tyK8KiC8lIryE+iXjdirhgWhdFc30Q+KKKiHASGKesPC+WkMjPIUts"
    "S1wRF2HbFmSB2GMEXEciHyHjwIcVcQQYyRARjoWFYBKYroH8InCKcuRd6/gZ8NFuhNwyJPtI"
    "X/kWkdJ8GPg5RUQIMI9EJQ+KwKdI1jo98jYDedBp2j2mzZqPWoFHgR9UpI97QkIQG8xSXUQR"
    "GEEi306lZVK3dynoQMaG7Tvrd1eQxeYhZB6JCRgNC8Es8E9GJ0vASeAS5ei5lqlmHRclIEAW"
    "hDsTrqdlQwFPAC855zY29bNIXb5Jsie/pGybJMJ5yVu0I3sKqIy++72VcmYXkY3Uj871DQEL"
    "SEX4EzjodXYKiby1jW+ZWsm3IIO3xyHb6h1j+l9GLPuHadeR5UaFgGXEJteJZ+E0cNGQt53W"
    "apkk7EJm5jXzvUg82jeQaF82fEqGbAvxsrshYDQsBA+rSO9HSuoBYNQjTwPIl5DJba/pw432"
    "IjLRjSPjcdUhaDnME993x15sLSCVYdaQ/4X4JOVaph4RO5GFnO1jGtlPTBkOllg75cjbdsHr"
    "KyZgBrFSK7Jm8ScpS7jeDDyClMVLyDL8qkOw3bvfJb+MlHwXFe+FhlWk9xkx4xki6kEPYg8b"
    "TZ80xCOPOb5M5fvZirln3rRdlNPTSPIgUbyNELfk3YHp28ZGP+nlcoWAGcqbEXePWw/5ktda"
    "Uj5h97jk3eN736JCwAKShQ6SU7sZtDitL8Y975N3780t4OuwEEyZC92V99eELLI+waT3/Pbc"
    "HOmvLBPXXzPIIOurjW8qgbTJxxfjW6dkeLgzb9pvxDCNzAV9SM32d0ybQZrnfdL2+xpwDfi2"
    "yuY+UcBPYSEYUJHuR8bCzbQbU5BUApNI+iRWkWqzglg5z2+l8poAHkP2s9dyEof0KpJmE0vc"
    "LibzEnf7TcSZsBA8pSK9O+umBOJulN3zUJmBErKEr5W0i0xuE8imo4P4fwF54Atyzy+Z/sYa"
    "8M408T8yF8Mq0rcQG+UdB0ll0fp7geoDsxZU5TSFLL6yxkHSTGqxVcQtqgr4G3nX30b6csLt"
    "xL4PbYS/86CqhQDeVpHWVJ8PGu3vPMhl60lgf8q1EPgPscgyW2OTLOTKAMCQirSfgVXz+Xwb"
    "/+zOPcFeAR5Aor1qzm0ncYvcAlaRTUie9UkzkdtCdyr+B7Ue60NkN/CWAAAAAElFTkSuQmCC")

LoadIcon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAIAAABvFaqvAAAAA3NCSVQICAjb4U/gAAABjUlE"
    "QVQ4jc2Uv2rCUBTG7y1dBDWSaBx0yJ0CDhGcdK1InkAcOnTyAdpH6AMUSseu7RD6BEE6WzsI"
    "ZhAy3QvGwb+gkUqn2yHgNTdXS0qGnjHnO7/75cD54GDigyTqIhFKkqBL4dfpejfEs7G3xIvt"
    "yt8rmRQqZCvlfA0VS3JaOAKjO7Id0nMInm+iaqRKLUMzDe13R28frtV3Jw/Xwmc9AMjd6/br"
    "u13XuVZoR7ZDrL5LKc3JSk5WBhOfhgsAQCm1+q7tkJOg6XrXc0igBgDYI2JWtU9vF/VFKe05"
    "ZLoOtRhoiGfcXs6w8HwzxDMxaOwtowNnWJyegfBiG1UfWAJTYT0Drfy9EHSqOD0DKZlULBCn"
    "ZyBUyMYCcXoGqpTzsUCcnoFqqIhU6dQYhBBCyOyoUg0VjwXsREpyumVoz+8OpTR982hWNXtE"
    "Dt3y7csxtGVo3PWGTsQ0tE5DD14OWEJrnYYevVs+j9p1vds0gn+MspAqdZtG9GKBMEZAOI/w"
    "UxcAcHVvxc6jv9X/y+zEQD+tjrd7D0xIQwAAAABJRU5ErkJggg==")

AppendIcon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABcAAAAWCAIAAACkFJBSAAAAA3NCSVQICAjb4U/gAAABmElE"
    "QVQ4ja2UIXSbUBSGv+xUUAeOySczRx2VSGSQkcRlbrKVictkZOQqI3GrjQuucUM27l7HdZsg"
    "ZTSha3eSX3B493K/878feAOYcbaugN91eg5icF18Ot/IwQtml6AAUOwcAAJQo0bsnt3n649T"
    "6maRxiGEzf1DsZmv93ep55z/LqWbi3QbYuRpNP/xXFX6MS9NLjXApkIMFxgmQjTK8p2x2SIG"
    "kLhyGMgbFADUFIhdg/WyNNlWpLHXPjBf23jJakzk+inWXh5KRExNRbl5nYgIszzKF4+rr3YE"
    "+uulMTqKwFDzxSifFMJlAZAMTU3vF1sgW9ivpddPwcTge7GXJs1aXBAA07Qx6s3GfpUkVVXd"
    "r8q+HdUtiNGNT61qYMHj7hCHiKohKkAWgXVGjnPBu80m3V6SfoPwbuSZhZWaii+KSgkCQf+O"
    "prFO46Tbm6wBJst946JRNuRUVz21F4moQeJahGJIa/2YYvVxuRkybscFL58SJhwQir31jk70"
    "M396XWgnwz4vpxb/U5c5pS531g2+vP/v/1t/AIhHu4wiyv5KAAAAAElFTkSuQmCC")

SaveIcon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABsAAAAZCAIAAABPfsIJAAAAA3NCSVQICAjb4U/gAAAApklE"
    "QVRIidWVyw3EIAxEZxGFUZpvbocS3AUl0AXKIVLCwd4NjjdS5gRIfjYePp/eO0KVYnHMnPdR"
    "a+0+rtaK8BoB5HmSkjPBGOOE3KpHU1ZXSykX40XkEhEAEYiUgCOliKiJ/bu29uEnEunr8c68"
    "gWh6DYDIbL/VxB/E75HxRL/XImKdcydxVU95Pd/ZVbtNZ5Z6ZxLnh9Otv/Vx/3RClAAwcxQO"
    "wAZUqjDGOv89VAAAAABJRU5ErkJggg==")

LicenseAcquiredIcon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABhWlDQ1BJQ0MgcHJvZmlsZQAA"
    "KJF9kT1Iw0AcxV9TtUUqgu0gxSFDdbIgKuIoVSyChdJWaNXB5NIvaNKQpLg4Cq4FBz8Wqw4u"
    "zro6uAqC4AeIm5uToouU+L+k0CLWg+N+vLv3uHsHCI0KU82eCUDVLCMVj4nZ3Kroe0UfhuBH"
    "GEGJmXoivZhB1/F1Dw9f76I8q/u5P8eAkjcZ4BGJ55huWMQbxDObls55nzjESpJCfE48btAF"
    "iR+5Lrv8xrnosMAzQ0YmNU8cIhaLHSx3MCsZKvE0cURRNcoXsi4rnLc4q5Uaa92TvzCQ11bS"
    "XKc5gjiWkEASImTUUEYFFqK0aqSYSNF+rIs/7PiT5JLJVQYjxwKqUCE5fvA/+N2tWZiadJMC"
    "MaD3xbY/RgHfLtCs2/b3sW03TwDvM3Cltf3VBjD7SXq9rUWOgMFt4OK6rcl7wOUOMPykS4bk"
    "SF6aQqEAvJ/RN+WA4C3Qv+b21trH6QOQoa6Wb4CDQ2CsSNnrXd7t7+zt3zOt/n4ATUBymLBb"
    "8vUAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQflBhIL"
    "BhnBaaqCAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAV5JREFUSMfV"
    "ljFIw0AUQN+lxbaLShcH6eYiHcXpzKKgLg5dxU030dUoznKgm3QTnZ2KW2ePgINKB5eCg+Ck"
    "iKCUUktJXCKcIOm1TVEDIf8O8l7uf/5d4L9fwhwsHfkrjU6wlnHE03Q+s1/emH0fVJD+CqTS"
    "441OcA7kPoKQ2kurAewNKnCMeBLIGeOpJFLkDLsGiQik0lmpdHYogghcASo/SZyE4MvRvdqX"
    "QCo91gUOUAbOehZIpQtAXSp9IJUWMfAt33PDflZwCEwAu8CxVDpnC7cVbAM3UbwJ1A34SRzc"
    "SuB77jMwB1SjqUL0rHaDWxfZ99wWUAIuDHgpmk+m0QzJui3822ZnKQmB0z+1F8WtYFQqXYx7"
    "OT/iNF/bwUNcoYXRUEXgrscPDIHblGDhcsd9i01RStDu80ScyThivmsN0kLcGw1ln2NBsxWE"
    "11ZncrSpLfbouPI99/HX/io+Addfc88PVkdxAAAAAElFTkSuQmCC")

LicenseConnectingIcon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABhWlDQ1BJQ0MgcHJvZmlsZQAA"
    "KJF9kT1Iw0AcxV9TtUUqgu0gxSFDdbIgKuIoVSyChdJWaNXB5NIvaNKQpLg4Cq4FBz8Wqw4u"
    "zro6uAqC4AeIm5uToouU+L+k0CLWg+N+vLv3uHsHCI0KU82eCUDVLCMVj4nZ3Kroe0UfhuBH"
    "GEGJmXoivZhB1/F1Dw9f76I8q/u5P8eAkjcZ4BGJ55huWMQbxDObls55nzjESpJCfE48btAF"
    "iR+5Lrv8xrnosMAzQ0YmNU8cIhaLHSx3MCsZKvE0cURRNcoXsi4rnLc4q5Uaa92TvzCQ11bS"
    "XKc5gjiWkEASImTUUEYFFqK0aqSYSNF+rIs/7PiT5JLJVQYjxwKqUCE5fvA/+N2tWZiadJMC"
    "MaD3xbY/RgHfLtCs2/b3sW03TwDvM3Cltf3VBjD7SXq9rUWOgMFt4OK6rcl7wOUOMPykS4bk"
    "SF6aQqEAvJ/RN+WA4C3Qv+b21trH6QOQoa6Wb4CDQ2CsSNnrXd7t7+zt3zOt/n4ATUBymLBb"
    "8vUAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQflBhIL"
    "BwHLHgOVAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAW5JREFUSMft"
    "lr9KA0EQxn97CSYBiSKkEO0UJFhKqmMbhWjjG9gIPoEKLip2gQuI2PinsrfyEQSPRQsVC7XQ"
    "FII2ighK0BjCnc0GjhTJnVFEcWFhZvbb+ZZvdpmF3z5E0Blf1ZPlmjeVsMR9tiexvDGTe2mX"
    "IF43bMftLte8XSD17vmcPVbKwGK7BFbA7gNSAX/wKySyvrsG/wQ/TxBvBbAdNwkUgH5gWyu5"
    "bzvuBDANXAJFAy0AGWBLK3kYmgBYAWaNnbcdNwvsAUkTuwMGGjC9Wkk/rESZgJ02M9mw3ogR"
    "UWpQBK6BN2BJK3kFrBn/BNgB1gOYea2kF5pAK1kChoBOraRjYnNAJ5DTSj5oJS8CmM1IRTYJ"
    "fcBviHmtMH//HaRtxx1utrmnw3p9qno39SvZtOGYZOcRD+gDpzHB2MGCfG4qUUxQ/WRHHElY"
    "YrRlDeJClMy9jqax4LXi+ceherLtuF1APiLHkVby9sd+FR9gvW0jXrsQYgAAAABJRU5ErkJg"
    "gg==")

LicenseLostIcon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABhWlDQ1BJQ0MgcHJvZmlsZQAA"
    "KJF9kT1Iw0AcxV9TtUUqgu0gxSFDdbIgKuIoVSyChdJWaNXB5NIvaNKQpLg4Cq4FBz8Wqw4u"
    "zro6uAqC4AeIm5uToouU+L+k0CLWg+N+vLv3uHsHCI0KU82eCUDVLCMVj4nZ3Kroe0UfhuBH"
    "GEGJmXoivZhB1/F1Dw9f76I8q/u5P8eAkjcZ4BGJ55huWMQbxDObls55nzjESpJCfE48btAF"
    "iR+5Lrv8xrnosMAzQ0YmNU8cIhaLHSx3MCsZKvE0cURRNcoXsi4rnLc4q5Uaa92TvzCQ11bS"
    "XKc5gjiWkEASImTUUEYFFqK0aqSYSNF+rIs/7PiT5JLJVQYjxwKqUCE5fvA/+N2tWZiadJMC"
    "MaD3xbY/RgHfLtCs2/b3sW03TwDvM3Cltf3VBjD7SXq9rUWOgMFt4OK6rcl7wOUOMPykS4bk"
    "SF6aQqEAvJ/RN+WA4C3Qv+b21trH6QOQoa6Wb4CDQ2CsSNnrXd7t7+zt3zOt/n4ATUBymLBb"
    "8vUAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQflBhIL"
    "BSC1QXFJAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAXdJREFUSMfV"
    "ljtLA0EUhb/NBkxUFMF02qSxEDuxyLggBDGNovgLLMXKQt2fsIjYBBst/Ae+CkWLNMOiXZpY"
    "aSFYqCmCjyIxkKyFs7AsuGbd+Jpq7oE7h3vOnbkD/31p3mB60x6t1JuzSV27n0z37qzNj7xG"
    "JYi7G2HJZKXePAZS1YbD0dVjAtiIShDz7NNAyhOPtUOi2Hd78LcIhCUTwpIzPmxCWHI4MoGw"
    "ZALYBw6EJZcUlgNOgMJHJPEQBfQAA6q18+rABSABPEeuwDaNMpAFSopkUR1eBrK2aVxG9kCR"
    "rPvgXds0Su0yOQds++BV15OoJg8Ce15ZPHLl/d31FQ9ugRXgQWle8JCcAmft8GALGHI1V56M"
    "A3O2adSitqlL8hQU//hTEVRBl7BkOii5v0OvHi5n7loaOOpmlkJOq6YDF0DONo2XQIl0jXrY"
    "8p33/EynrmU/9aA7HrsGiqE11qjVGk6xpZksLNkHTPnxT9a5bRo3v/areAN9OXS6VEMd2wAA"
    "AABJRU5ErkJggg==")

LicenseStatusUnknownIcon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABhWlDQ1BJQ0MgcHJvZmlsZQAA"
    "KJF9kT1Iw0AcxV9TtUUqgu0gxSFDdbIgKuIoVSyChdJWaNXB5NIvaNKQpLg4Cq4FBz8Wqw4u"
    "zro6uAqC4AeIm5uToouU+L+k0CLWg+N+vLv3uHsHCI0KU82eCUDVLCMVj4nZ3Kroe0UfhuBH"
    "GEGJmXoivZhB1/F1Dw9f76I8q/u5P8eAkjcZ4BGJ55huWMQbxDObls55nzjESpJCfE48btAF"
    "iR+5Lrv8xrnosMAzQ0YmNU8cIhaLHSx3MCsZKvE0cURRNcoXsi4rnLc4q5Uaa92TvzCQ11bS"
    "XKc5gjiWkEASImTUUEYFFqK0aqSYSNF+rIs/7PiT5JLJVQYjxwKqUCE5fvA/+N2tWZiadJMC"
    "MaD3xbY/RgHfLtCs2/b3sW03TwDvM3Cltf3VBjD7SXq9rUWOgMFt4OK6rcl7wOUOMPykS4bk"
    "SF6aQqEAvJ/RN+WA4C3Qv+b21trH6QOQoa6Wb4CDQ2CsSNnrXd7t7+zt3zOt/n4ATUBymLBb"
    "8vUAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQflBhIL"
    "BypnovrVAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAalJREFUSMfV"
    "1b+PDWEUxvHP3N24tiJbXAUqmkW1uxpjIkh2K9EoFKJSKIViJ/gDppCsRGypUqAiKpW7xiDB"
    "UqhEIbayRGJzs7k2m7mauckU3N8KTzNzZt73/b7nnPc9h/9dQdmYv5Gdamzl56qV4OvUZPX6"
    "7QuH14cFjLdfwiTd2djK72PiV97y/nuzgasjA2A3Jkr2/j9NCJN0B46him9YzuKo9TdApZ/d"
    "hEk6j494hAd4iudhktaGBoRJeggPUcMLLGIVR3BvFB5cxHbcxdEsji5jtoAcD5N0elhAOwxL"
    "7ZhncbSG5eL7vm5J7qalYrfvSmELMFWY60MBsjiqo15afC9uYQZfSp4M7EE54TW8xi6s4WwW"
    "R82hj2lJl4rF65jN4ujlSO5BSXuK52IWR6udBg4KuIbTeNxt4KCAOZzBgX5qUa8JrhSnp123"
    "zo/UgyyOctzECu703A/CJD2ID6V/T3Cl0+TJbZWNH5v5507VtBOgF7WwMhY4+Wwh+tkxRGOB"
    "zQE74ky1EpzomoPxIPiEt313rMBGM2+96aknF91qrk/Gq26X7Z/qN9ltdjsoHWPcAAAAAElF"
    "TkSuQmCC")


CutIcon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAABHlJ"
    "REFUSImNls9rXFUUxz/nvvcySSZxEhNbhf6IiIJo6bhzZSeCaFfOpiXtpgPuShtf6CLbuMyi"
    "dEilW+OmkXbR8T9IBQVxMxURdNGkRSr5PZnMz/fevcfFTEKIaZOzeXB57/s553zvvecJx4ib"
    "4dUvBc0BedAyUOpL2dLs7MPto76VV4u6fEdUKkBJhZIoWdCCIFlFS4qZv1u8/+ORgOnpS5lm"
    "28sD3UxZBpl3Yhe/vfPgCcDNqSsXRDUHkhPI0Weh6aFoJwFM6SBMACbDiUeC5BUtg8wnnpQG"
    "/bjSaAe5Tms0J0hWMg4ZidGRCB2JoGHQn4aXE09yvnUFkALoUKdamb97Z+Gx36FIvgssA2O+"
    "daWW9bP+aELwhhAMewQnDKbHx6mPdT6RNUQ9bRyM3bt9/xnwzY2pyyWjXlGgIEoBEH+3lNiT"
    "Md8SCoT4SvBxi4G30vR6/aS8XjwTICKoc8QaEdkWzaTOdqBMhhOPQLIoACUrNvTUKwPsAbpZ"
    "TH0dXgmDdx3Jr300hg2DH6UZOjWCbwKMGJyzrC6tUV9uUntuIFZAcWLzu15NT1/KtNod3T3A"
    "bihaTr/Zl82cGyJ5Zlj5pcIKFc6cP83Oeo31p2v4qYDhsQwnLo6ysbzJ1u+18q44QCPyswKL"
    "AKYrWrl+6+rZXR9MtYfBdIaz2bNcKFzg7Q/fYfm35wwPjPDpxOd89tUXvP/JB4ycHCX9Whog"
    "+7Jt2q1Ayp7TMeAZSNluC71+mv5gkIEgw+mxgOqLHcYvXiR2EY14BwGsJvRn0oAMHQHY1yKh"
    "HG3G9JgUKa+PPn+AxAffBAz3nqRlGwhC7CJatsHg6CDSOTuHhjm4cPfOwuPmZhtjfIz4eCbA"
    "NwGe+Az2DNPr9RN4qb21IBVgegz7WvxqAHSMrr6ooupwanHdZyupk7gI65LuukVR+l5P0W1x"
    "p+GqOTpn6nAAUK6uVYlci7Zt0LINEo3Zaq+yE23RTGq0bZPYRSQuwkubXdH9aVbgEA+6OVR2"
    "1nZoJjV8CWjEDRIXs9VaJXExraROPa52QEkT06+8zOg9gKgWJsOJEMiBUt+oU4u2UYVm3CZx"
    "EZutFZxa2kmTZlKjHlepNarELgI0Nz19KXPwCt8FlAUJFZ1JPBMO+nGltRlVdqItrMa0I0vs"
    "IrZaqzi1RLZNo1lj5Y91tv7cwcW6CEKz7S1PhhPFTjWdFhmAueLClEIRCI1LhmZnH24rLG/8"
    "s0GlvUEtrpC4mM3WCmsb//L05yX+erDExpPqok00N1dcGJ8rLoyrSB6kIBACy3Bg4EyGE9cE"
    "mVe0AOR7ziX5/vc8dCOgUVZSwz71pQhF5xPPzHTvL2B3VjADmgWKfSlbnJ19uP2/iXZj6vJ5"
    "o2YRpCKnWmNyJkL+TmPXTQUoHVd4z9vDnL9+6+pZ37pSdyxWgEWQobniwvj+ajsDhrGOcDJ/"
    "2Iw+dJveu33/2fT0pVyz7c13BUpAYZ/wTOdNnZkr/vD9YRqvrGB/TIYT3wlS0K5pxxU+NqAL"
    "uQbkj/qDOCz+A7/OWGg/XLpsAAAAAElFTkSuQmCC")

IsoIcon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAABe9J"
    "REFUSImV1W9oVfcZwPHv75xzzzn3f/6amBhN1Bijpo1pXa4Mm5RCsZNS1yE4X3QZjFEGgmMv"
    "fDeEvRzDUGWsrJPtxVpb2Bo72NLBnNJlRq1tnDFWY2MyjUnu9d7c3H/nnj/3/PYiGrXWjT3w"
    "e/N7fjwfHnj4PYKnxMFDB14T+N0g+p/MymkQY54qhn75i3dnnlYDQHxN0QGB2AtAzIOYhwhL"
    "NEVHUwJoQqOShfKCi+9KJHIMGHxr8OTvngosF5aDAlpXMrUutJRRWhxMLUw4EMPUwphaiIBi"
    "oCkB7IxL6mqGzGQWiRzzhT9w/OgHlx8DDv74u32K5AyNNrSVl28tBeYNmNcRIZ9Yr051czUh"
    "LUpQC6OrQTQlgIKggk9pqcAXH09STJeyEmXg2OC7px4AaiKxbVDUeptFIocI+YiQj1olsaId"
    "ZIwEWe8ZvC/zKOkcja2riQarieixlY4M1cQIBlnVWYeVK5lWurR/x84tQxdGry4AKCCqqHUf"
    "tpQxKXzShX2xChZcLLOFhab93LF2cvWPX+AvCWJ6DXGjliqznphRR1SvIRKoovOlzVSvi6NI"
    "dejw4X3x+8DDUMsG/kiElvqNdG7axMZwmo13jtNQGCXQsJ38mu9x7sNL5OdKxI26+6eGqB4n"
    "GIhiamE2vrgeTVdaLVs99BBwBarQUBZCxJq7aO55nfqOftp2/YDOV39KvZgnNPkOsaCGvuUN"
    "/npqlOnxKeJGHRG9mqAWxVSD6KqJGQxSv7UW4AEgzzCvY2hBDNN4bMQqTgmnmGFt7wEa2hOU"
    "/3WCsOrR0Psmw3/+G/lUDlMNEVB0VCWAIlQUoVK/tQaBqDp46MBrii/8ISwVJRMkVBvEys6u"
    "ALf+8RvmP/+QyY9/jrU4y+quV0ief5uAk6LxGwP8+p1jzM7OUJEVfFlBSomUEkUXGNUBBH63"
    "cvzoB5clnLEnBJG6CIgc9sI4IV3BK2ZY+/x32LX/Z1RFI6RunKVuUx93Rk+gawrhzn189IeT"
    "5IoZ3IqN5zt4vosnXYwGDRD9CoAUHHGSFdykpLmnkTuX/0LcVKlt3sTi3A1cYbCt7w1Wt3RQ"
    "SN6krmMZMauayGsbOH1qmJJXoFwp4VQs3IqN1PzlwQG4MDo+05vo6ncW3dYNL6xn7vIMhmaw"
    "btMOrvz9BKGmLjQzRtP6brKz13BcF1UPYS3Oorbt5t71cxgRGyIVSm6eklegOF/CTcnplTH1"
    "VDFQztjc/Wye7j3PMnHhT5gBwbbEq0yf+z3ZfIHFkkfLc6+zeOsC9R19lO5ews5M4TS9zPVP"
    "bpArLlLy8lheAc93HnYAcPHclaXeRFc2dze/u6G9kXhtnMtnT/PCK99n6d5tpi59hB5vQos1"
    "U0zeRA/XYMYayN6+Qr6mFyeXRtj/xq+1Kbl57KSHTAemVwCA86Pj53sT27pTU6nNW/u2Ui4U"
    "mbg4wq49P0QoASbPnaR4b5pieobqtT1Ur+0hNfY+2dhzKJU06sIt/LYCZa+IvB4ESx16DADo"
    "7+scth25O33nXmPPt55nKXWPaxdHaO9+idbte/B8SXTNduJrnkFRAxSSN0m5UVZtmIJbadxo"
    "CSIejEUB+asngJGRCbu/r/NkMe++mZxeMLt3d+PYRcZODxPQg9S3fxMlvGrlfebWBQpoNHV9"
    "ipP0oXx/xdw18FTl0BPAA2THzi3DTsnZn5xJmm2JtVSvizN5/p+kZ67hA3q4Bq+cY358mOCW"
    "MoTn8AoVyGmQDSAtZej40ffeFl8HPIjDh/fFLVs9o+lad/vLbYQbgyxcT5EaT2MvLv/ARjuo"
    "28pYXhE5F4BPYwD4gv5jR987+1+BR5DfCsTeumfjxLpMPN/F8cvYFYuyV8T2LCQSOWXC1QgS"
    "OfTW4MlvwyNj+rQYGZmwz4+Ov9+b6MqWFsqJ/Jcl01VtnEgByyviVMoPH18LIy0lGzQq/SMj"
    "EzZ8Zen/r/jRTw6s0yr+EYEYIFiBRgfi3nLytolMa1lf+P2P7uX/C3gcknuBvQL6JTILnPGF"
    "f+SrS/8/A0yaarZFYMUAAAAASUVORK5CYII=")

StreamIcon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAsBJ"
    "REFUSIm1Vb9v01AQ/u45P9oMxFX4UVSJdAI2sjE2/wFhADVZ8FzR4KpDR7xmqGK1qLNZ2oou"
    "4T9wZxQpCHVALOnAz0CaCmiFar9jsJ/iuGmqQHvb87277/Pdve+ASzaKf3i69PieYM0AUCCg"
    "CAAMuABaDHLX7c3X/wSwaFYeENjsJ+UWQG7ojoBxDyBHku+8qL96ey5AyNgmoBgEw/Y04Wys"
    "bu5HL66sPMoe/9FKABlxEgxyQdyLJ8+kvBZVzfnnAEwA9mTat2u1ncOF5Uo+4XMJYD3k0ZPk"
    "u4pxxG8QqHAWewYbAz1YXCrPEcNSDIcEtADYa/b2y3jcsPuZlNeiyO/bBDLCMjUkSXuQsTQA"
    "mATSGXCZYK3Xt3bPYq8s7IFwg0B2PE1Yqv6LS+U5X1BbnUMi5gAQyB41WVQ1y88AmEwwFCPV"
    "l0SWdHkEyBO0o/44UL98NNBoBtmn3kHVLNcTOszrc1lk9SyYGZ29LrrN3/DJL0RHsz9ZmAWo"
    "OJiJe5KkNQCwsFzJJ31uz5SmkJ++jdzETTAkOkcf8aH5Hj+aPxtr9vbD8+oetUT0oEmeTV4j"
    "TE1dxY3MLeSv3IVkDwTCwZ0Ous1fpXGSnwJQJkhAIw0pLQ1PahCkQUCMm/s0gC+ofdJh9A66"
    "+D7xCUQEyRLd4y/o7HXB4Ma4AEObnNSFOX0/h9xMDgzG53df8e3NQU+SLEabHOiXNAAU1TRF"
    "jcHGyDEVSdL5JBhBSdJQycMX7xAwqx4mgHYcwNOEQ8Flbgx7oQvLlXxU9EINcvrCSNZk2nNq"
    "tZ3DkSUK5jlhUSB6of6z42nC3Vjd3A9LUSKQEfrtybRnjUo8tAchQzNUyWE1HZASZWeJ3Xp9"
    "azfsAVuIyLUKIkYBYJ2J3EzKaynfWHL9fwsHbQCNkQtHHarm/BME4lUI0S9mZcY/XPTSv3T7"
    "Cx+uqdjtVqWCAAAAAElFTkSuQmCC")

FeatureEdgesIcon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAfVJ"
    "REFUSInV1E1qFFEUBeCvyyQoIf60kr+BGsWYYCTgCtyEu8hyehluQGcOQwgoEhQj/oEICokY"
    "oyaatIP7uvp1pao7AydeKKh679xzz7vn1uN/j1bjzlr5dg0L2BuKj+hiCvvY0GFsBPlFPMAr"
    "rGvC92MC9zGNDSMSprCEt0nRT50GZAg6g9t4jcu9raIBfBYrSflXo1vZwh18w/scX9SAx7CK"
    "j9g5BTksJtx2FVJUwEVSvoMPjcSD5NdFO7eEyb0nKzCo5I/o42nIZzGH5ymvF2WB3ORbYiSf"
    "CpNaKelC2r9krcR3cU6M7yYOdMrCXRzXFVgQJk3r9/0I7fQ+LyZFIrgnDN2vTNdAi/ICe3iG"
    "H2VCKJpLX1uV9Xn1AzBwgnyKioaEpugOWa+Y/O8L1HrQGijQn5QCM1iypsgIrgqPFrP1Ls5j"
    "sq5A3Qna+IUn+J3tH4vrg/CuZ/6EmMTN4QVC/SSWxYzvDkxK7H9J+E9Z/moif5eT1p1gAnfx"
    "Brvqo1vJX8ZhSd45WaCVPSv4XKqrv0W7maAb4oJ8UcVXT1CIK/ogqW8i7xUgfswZ0crjKr56"
    "ggVxBbwcQU4Y3cbNRH5Yh89NviKMfYxxjGejWlV9lDCzeITvTWLyAtvi2l0eqrsfLTzUPAQn"
    "CqxniVWipog/dkgr/wLQqXcO26/D2gAAAABJRU5ErkJggg==")

ElementGroupsIcon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAPCAIAAABxxpiMAAAAA3NCSVQICAjb4U/gAAACTklE"
    "QVQ4jY1UTWvqQBSduRmru/6A4s6Ff67SKl0paqK7CrWi6E4QrLQFoUgUg18oFVER7K6ISEU3"
    "CtJF8aPJzHQxj+BL5fGyOmTOPXPOvZfBHx8fhBBd1wFAAISQzWYzDAMhtF6vO51Oo9EIBoNf"
    "X1+xWCwWi72/v2ez2fv7+1arValU7u7u6vU6fH9/Hw4HhBCldL/fM8YYY/v9nlKKENpsNi8v"
    "Lx6Ph1KaSqUCgcByuczn85FIZDQaaZoWjUY1TSsWi4AQwhgjhE4CALi6ujo/P7+9vfV6vdvt"
    "NpPJBAKB6XT69PQUDoe73W6z2YzH4wRjjDFmjAnAORdCnHPGmMPheHt7KxQK19fXu90unU77"
    "/f7ZbPb4+CjLcq/Xq9frsiy3223gnHPOhQWhYgIA2O12qqpeXl7qui5U5vN5oVCQZbnf79dq"
    "NUVRyuVyqVSC4yxC0fQl/vt8PkppMpn0+/2LxeLh4UFRlMFgoGlaJBIpl8vj8TiRSPwVDQBM"
    "L2a0brc7Ho9vbm7m83kulwuFQv1+X1VVRVFKpdJwOAwGg8/Pz5LH4xFa6NcHAJ+fn6qqXlxc"
    "AEC1WnU6ndvtttlsulyu1Wr1+vrqdrtns1mv18OTyYQQIuJwzgEAIWT2njEmPBqGIUmS2BIB"
    "GGPCOOecCIl/RDOpdrtdFEuSJPgCmKfE0uzjqVm2wTITC+3PzSenZqk/KST4hmHA70Rmp46B"
    "Zb8sHSCEwDFDAEvZ/wCMMRF32u12xhil9OzsTMyIEAIAuq5LkmR5FRhjFv7hcPgBcyfgBLk4"
    "DQcAAAAASUVORK5CYII=")

IsoVolumeIcon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAPCAIAAABxxpiMAAAAA3NCSVQICAjb4U/gAAACTklE"
    "QVQ4jY1UTWvqQBSduRmru/6A4s6Ff67SKl0paqK7CrWi6E4QrLQFoUgUg18oFVER7K6ISEU3"
    "CtJF8aPJzHQxj+BL5fGyOmTOPXPOvZfBHx8fhBBd1wFAAISQzWYzDAMhtF6vO51Oo9EIBoNf"
    "X1+xWCwWi72/v2ez2fv7+1arValU7u7u6vU6fH9/Hw4HhBCldL/fM8YYY/v9nlKKENpsNi8v"
    "Lx6Ph1KaSqUCgcByuczn85FIZDQaaZoWjUY1TSsWi4AQwhgjhE4CALi6ujo/P7+9vfV6vdvt"
    "NpPJBAKB6XT69PQUDoe73W6z2YzH4wRjjDFmjAnAORdCnHPGmMPheHt7KxQK19fXu90unU77"
    "/f7ZbPb4+CjLcq/Xq9frsiy3223gnHPOhQWhYgIA2O12qqpeXl7qui5U5vN5oVCQZbnf79dq"
    "NUVRyuVyqVSC4yxC0fQl/vt8PkppMpn0+/2LxeLh4UFRlMFgoGlaJBIpl8vj8TiRSPwVDQBM"
    "L2a0brc7Ho9vbm7m83kulwuFQv1+X1VVRVFKpdJwOAwGg8/Pz5LH4xFa6NcHAJ+fn6qqXlxc"
    "AEC1WnU6ndvtttlsulyu1Wr1+vrqdrtns1mv18OTyYQQIuJwzgEAIWT2njEmPBqGIUmS2BIB"
    "GGPCOOecCIl/RDOpdrtdFEuSJPgCmKfE0uzjqVm2wTITC+3PzSenZqk/KST4hmHA70Rmp46B"
    "Zb8sHSCEwDFDAEvZ/wCMMRF32u12xhil9OzsTMyIEAIAuq5LkmR5FRhjFv7hcPgBcyfgBLk4"
    "DQcAAAAASUVORK5CYII=")

SelectAll = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAIAAABvFaqvAAAAA3NCSVQICAjb4U/gAAAAPElE"
    "QVQ4jWP8//8/AzUAE1VMoaZBLGh8dkZidf5EDRKquYiRWoE96jUsYNRrJINRrxEGw9hrg6/M"
    "pppBAF5NISHHOcg+AAAAAElFTkSuQmCC")

CheckAll = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAIAAABvFaqvAAAAA3NCSVQICAjb4U/gAAADJklE"
    "QVQ4ja2UXUgUURTHz0wzs87MNs7u6hpllgZ9YB/0oVH0YJIarhQ+FGZpQRRC9GUUQT0oQhSB"
    "T1YIRUVFSRBoGvRgZQ9BvVQEvQRGH0q7q5ubO+26995ze9htbNXVHvxzmblwmN/5/+fcGSE4"
    "NAyzIXFWKLMJkuzd/e4XHT19ofBo2p6CUOMraaj1zQDq6Om70nwsyzQAAIBzAA4cOCBHRD4Y"
    "+PnLija2tO2vLlVVdYo29u7rYGDRfK/HZXjchseV6XEZHtNwm3PdmYbbcL7+0P/LGguFI2V7"
    "G9sfPJkO5NTVcCTCOXLknHOOyYXInr580/XybShsCQAXTx+419kbjUbTggCAI0fkiIiILLnY"
    "+4+fWm8/NjQ1y8gAAEAWjcWGgsHpQMh5nFB/KEwoZYwyRr98/3Gu9XZc1Mo2rli7LBcACGWW"
    "Fd1Wf6al7V56R5xfunqn6dqjzwNBZBgcDp9vvTU0pvi2rK7cXAiIAMAZUzMcXe3ND3r64vE4"
    "Ik4Nor9Dz573db54+80fauvo7R8mFZsKa8uLRAE45wDAkAEAoxQALMuilCaelVJAyI8ePjAw"
    "cOHG3YevP3xiCBtXLanbXuyQBEZpsnnSFgWAkZERRVEURZnoiCHLcDhOHjk0Txp59+ZVLDa2"
    "r3xDpqYwxhJ2IHG4ABhlABCJjNqOUkGUEUJysjwnGg4u9joPVhXnZhs2IjkQRPtKCLXf0Xg0"
    "URAIIfH4HErIhnVrbq1bk5jjv8FBSJgCZAxSNQ6q8ZXsabwUCkcESCMBVuZ5PC6TMs7+GpkC"
    "1FDr219dWrbvVNOR3RwZMpwQCgA0VRtDUVdEYVK3lKmpqlq/q6rlenc0GotYv9UMJREExm/g"
    "kMWi5Qs0TZ8OBACHayrrdm4dCga31Z+5efk4JYRRyiHFmqbpbrdrBlDC18K8vN07KvacvTK5"
    "amv90vmyLIlicu5Cun+2ZVmBQOBzf7/f77csa0JV1/WcnJz8ggKv16vr+tSOEpJl2TTN/IKC"
    "bG82IXRSVXI655qmKcvyDI4QkVJKCKF0/NTZEkVRkiRZliUpmS6tI1EU7e/of/QHTDOj3nUp"
    "BhUAAAAASUVORK5CYII=")

MoveUp = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAIAAABvFaqvAAAAA3NCSVQICAjb4U/gAAABD0lE"
    "QVQ4jb2UMUsDMRTHf6n2ihRcym2FCk46uJU6tbt0syB06VBwc3Jxchfa1aGLQ79Cp34Ft+6F"
    "G27qeUUOpXQxDrEh1xRRSPpfEl5e8n557yUieUtxoYKTU4BD2yTEzwh8rtZA+ahkeUlASt9E"
    "JkuSZsDzeArUqiHQu24ankJz+SRSd47iBTAcTdjkKIoT7aO4pJket0TC7CMV2WSxdVINgfvb"
    "NlA8AAiCkjeiu8cXzRJWjtnUTsm01C9Ogf5N0z1Rrmqty3Og1TgDkmUGDEYTvfr00AVeZ/Mt"
    "UiU/RJ2rhp6n7x87N6js2PL5+pXs3s3FFwL4kr7f2t9l0/rp7NyCgPwf+Lt9H1X7n90Z0TfJ"
    "wlz/h82pFAAAAABJRU5ErkJggg==")

MoveDown = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAIAAABvFaqvAAAAA3NCSVQICAjb4U/gAAABG0lE"
    "QVQ4jb2UMUtCURTHf1dLEaEl3iYUOOXQJgVBLo1tfgA3cW/oKwjiKuTgEji5FQ4t0ZY4CA4u"
    "ITi4PW0wLd4beg1PH9f35C7e23+5cM49//u7h3uPsGdzdCimxQU4iIaEWK+KMs/z/oVIZhl9"
    "TIHaw1OQbdUqCiMzRJuLe+zqglraiPYycl3HdR0NRrK2etTp9oDCxZmioD8cA/Z8Adxc5YK4"
    "GaK39xHQfR0A1vFRaOt9tR2w5M+zoaw2IiH//snUBurNZ2D14+wsOM1YwF35FjiMAyQSSWNE"
    "aq7CZQ4oFa+BmBDAr/T6TRL5mn1+AY3HF+AkYwUs6zIh2P6P5on82bT8doB0KhmKR0eDyZnt"
    "yz9TZpHjUWkj+gNns1x80Zk7eQAAAABJRU5ErkJggg==")

Undo = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAIAAABvFaqvAAAAA3NCSVQICAjb4U/gAAAC2ElE"
    "QVQ4ja3Ty2tcBRQG8N/ceydJ02SmbfpKn8FCaUNo3bW4E5EuakEq3SiIUixY6MKdm+KiUgX9"
    "A1y0CC6sClLEkqIIVaGgJoGCtNQmNTTRPtIk88xk7tw7d1xE8R+YszicxXfO+b7zyH3yzc8Y"
    "6Au2FgaxUK3hyfwcgjCMogCtOAHiZgNpkEelWkWp3nz06AkCXbJosDGPxeXk+UPHsKvWj/mg"
    "id179w7v2oNGZRkPHj6dvfc7Jm/fx0qcYnm5srTwFNHDUhP9A/2bNm3Cml/L/3Vi6tadaeSi"
    "PPYfOHjs5KsIBn/AZ59/gaVyLU2zrkpbqsfoGyw0mgnWF9Zj+vY9XLlyZaX9P7Rn/PrY6CjO"
    "vHUa0zMz+PLqt2FPX1cZrSw/xmzp8Ud/TuPg2CEM79iNwrY9C9N3kYS9aJfrM+PfY/uWIRx/"
    "6QRu3Pxtfu6vrjIqdwawWi2tPPgbN36ZxNDWYazE7cZqinbWQpZlWdrBpcuf4qvjJzA2Ojo7"
    "M4MoqMwj12r9W7hvPR4ultFsxv396xAGAXQyYQBtmPvjDp4Z2RP15rsqbSHphVxvdfUJkjhG"
    "HCcIw54syxDHLYSypNVCPmug3upALkrjpKuMmtUlVFZbca0EQR75KARZK24iCgJ02mkUdlAs"
    "FHBg/z5cvfZ12k4RLVQaGN429Ma5t3H50mXMzs2hUCh2kgSdKEKWxpVSCefefAdpGuOnH2+u"
    "W9fdy5Y0sbi4dHDfCD7+4AI+vHgBE1O38vkIq0mKYrF49sxpvP7aKZw99y6qtUanu7+WGzny"
    "wlq0e6iI8+ff898g7967Pzk1gZ3D2zF2+NktGzfg/YsXce36dyhu3Nzs7vpzh148iWajnq7W"
    "kbXbeO7oUZx65eWdO3agXGticmri+vg4HtyfwUBxA8r1leLGzciNHD6CtBP0R1CrlpFlHWTt"
    "tJWkCIMc8j29a8178z0IwxCxQNpVaf8AX3U7t30T6JMAAAAASUVORK5CYII=")

Redo = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAIAAABvFaqvAAAAA3NCSVQICAjb4U/gAAACz0lE"
    "QVQ4ja3US2ucZRjG8d/MvO+8naRpTNRE6UmrJdZDhQpCV7pQbKUoVbtQhCK4ceNCEE8fwY12"
    "ISoKHkBE09oidCW40IKCPbe2KTWlktS0dSYzyZze08RFZfQDzLO7r+eB6//nhqcwffgHJElS"
    "CEIU8hRx1kPcaXc6bYRBgCAsZ2mC3koPed5Do9WZm/8LRQM6Qa1WQ1QZKgfQ7sZYXmpgZM3o"
    "homNqEQR6vX6wvw8xiZvx5apzfjiq2/itIcgCMMbFtcWayiv9LB9+3Zs3nRHnGT/r23HXQRB"
    "hJFKiCTuXF9sDFStWq2hkyRBEOLZPbv7d98eODT7x0Uk3S5WDY/s2vkEtm17oP/mlrGxI7+d"
    "GCjRYq2GbpLt2PlkP3133/u4PFddCSr9cCxqRqPjqDfaOHXuIi5fbaR5caBE1VaCyZvHt265"
    "G19O78ep3y+hsnokbTWRxS2Mr9t46OD3OHfqJM7PX8VKloVhCUG6vIQNm9blnSX8+NOvKAcB"
    "Os3lNMv7nedmzp84c7o/RmGIlDzLBqq2FLeRTdy50MrRinO0kx7SJMmTBJWhCoKo3MlzRKuG"
    "kHaXUSgGeXFloESFPMHypdO3Pby5ny43WwjlYamELE7QSdLVozeh3emil3RRCIIoCBFcaxdw"
    "5PSF51++FVun7sLhP2cRhJFS6b/OUrFZr/XH++6ZwtnzMzfWMTi1v2uLqF9ZPHzwAF5/9RXM"
    "nD2O2cvzeT6MpJehXBK3mnj8sUfxzhtv47U33zp2/ORAieJiBVkpfu/Tz7BxchyffPQx9n3w"
    "4c+/HEW1sYj1k+NPP/USXnjuGXz+9TSOHT2qGAySqHD/IzuQD1fq1TmsFeHFvXuxZ/euodFx"
    "9NIUQ6vC42dmMD09jf3fHcLwmtF2HKNw74MPoV0cUplAs72AlTjFxMTk2g3rUS4W0Fhaunpl"
    "AddrVYTD//4wUVAepNo/deg0RGz9CnoAAAAASUVORK5CYII=")

WizardIcon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAHQAAAEECAIAAAB2rYcFAAAAA3NCSVQICAjb4U/gAAAGBklE"
    "QVR4nO2bwc3bRhBGR0HgwAddBDhNqAGfnALUgdOEGhDsQA2oiaQDFZCc0oCaSABddAjsC3Ng"
    "RATJkuDu8u3OUt87GiS9+PA4M7s/tem6zgTDN7UXsGYULojCBVG4IAoXROGCKFwQhQuicEEU"
    "LojCBVG4IN/mP2Kz2aTduPozI5kLsoC5Tz5jF7eKzAVZMtyu+9R1nxZ8YOvIXBCFC7JgQ5vm"
    "8///ac4M1/S4JnNBiplrZhZlYerWxBGzwk3eg704KgsgEWVh7J2OtHp4zPrfBpkLEtnQ+pY0"
    "UoI3m5+y17MqZC7IZs6U3k8LnYXNnV87u87m19z+P9EmQoRZYBMRVKvXcvDuNSdlmQuicEGK"
    "ni2Y2SvsHQZkLojCBYksC3lN/9VGBpkLEmFujnZNb7SSkbkgs84WRBoyF0ThgihcEIULUv5s"
    "4b8cDoe0G6/X67IrWRyZC1Lf3Cc/xlz8M7WKRZG5II7CvV4/Xq8fa69iSRyFuz4ULoifhjZN"
    "oIPNmeHqjmsyF6QVc83MoixM3ZosSYlwk/dgraOyAFKuLIy905FWD49p4G2QuSBlG1rfkkZK"
    "8OHwS9HF8MhcED+jWBsHXVHIXJD65ganiL4qD5vXRidlmQuicEHql4VIWqoPMhdE4YKULQt5"
    "Tb+5kUHmgpQzN0c7/x/XBJG5IPr4GUTmgihcEIULonBBFC6IwgVRuCAKF6S581wzs/P5nHbj"
    "6XRadiXTyFyQJs198kPMxb9SqxhH5oK0He7p9OF0+lB7FaO0Ha5zFC5I0w1tmkAHmzPDLTiu"
    "yVyQFZtrZhZlYerWZBSn4SbvwVyhsgDi1NyesXc60urhMaXfBpkL4tpcs2dLGinB5/NvRRcT"
    "icwFcW/uFBUOuqKQuSBNmhucIvqqPGxePUzKMhdE4YI0WRYiqVYfZC6IwgVxXxbymn7dkUHm"
    "grg2N0e7wh/XBJG5IPrBCYjMBVG4IAoXROGCKFwQhQuicEFc79Dmc7lc0m48Ho/LruTfyFyQ"
    "lZj75H3Mxb9Tq3gic0HWFu7x+P54jPIXZG3hukLhgqysoU0T6GBzZrjkcU3mgryUuWZmURam"
    "bk3+oZlwk/dgFVFZAGnG3J6xdzrS6uEx7Nsgc0EaM9fs2ZJGSvDlgp8YzEfmgjRo7hSOtDWZ"
    "i7ISc4NTRF+Vh81r+UlZ5oIoXJCVlIVICtUHmQuicEEaLAt5Tb/kyCBzQRozN0c79OOaIDIX"
    "RL+JAJG5IAoXROGCKFwQhQuicEEULojCBVG4IAoXxOPBze12S7txv98vu5JMZC6IR3OffB9z"
    "8R/UKjKQuSCuw93v3+3372qvIh3X4baOwgXx3NCmCXSwOTNcyXFN5oK0a66ZWZSFqVuTdOqE"
    "m7wHawuVBZCaZWHsnY60eniMu7dB5oLUbmh9Sxopwbfbn0UXszQyF6S2uVN4POiKQuaCeDQ3"
    "OEX0VXnYvDYxKctcEIUL4rEsROK3PshcEIULUrss5DV95yODzAWpaW6Odt4+rgkic0H0UykQ"
    "mQuicEEULojCBVG4IAoXROGC1Nmh3e/3tBt3u92yK0GRuSB1T8Xexlz8F7UKDJkLUjnc3e7t"
    "bhflb0vIXBCFC1L7zzxTBDrYnBnOz7gmc0E8m2tmFmVh6taEggo3eQ+2JlQWQNiyMPZOR1o9"
    "PKaxt0HmgvANrW9JIyX4fm/vxGA+Mhek7ii2Zm1N5qLUMTc4RfRVedi8rmBSlrkgChfE+9mC"
    "mTW3dxiQuSAKF4QvC3lNv+mRQeaCsObmaOfnrzXJyFwQ/SYCROaCKFwQhQuicEGcni08Ho+0"
    "G7fb7bIryUHmgjg198l3MRd/oVaRiswF8R7udvtmu31TexWJeA+3aRQuiPOGNk2gg82Z4YqN"
    "azIXpGlzzcyiLEzdmiRSLdzkPVhDqCyAVC4LY+90pNXDY3y9DTIXxEFD61vSSAl+PL4WXcyi"
    "yFwQB+ZO4e6gKwqZC+LU3OAU0VflYfPqf1KWuSAKF8RpWYjEaX2QuSAKF8RBWchr+p5HBpkL"
    "UtncHO1cfVwTROaC6ONnEJkLonBBFC6IwgX5G6ER8eI/rtY0AAAAAElFTkSuQmCC")

AttributesIcon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAAlwSFlz"
    "AAALEwAACxMBAJqcGAAAAAd0SU1FB9oDCgY4GrkcNm4AAAAZdEVYdENvbW1lbnQAQ3JlYXRl"
    "ZCB3aXRoIEdJTVBXgQ4XAAAA/klEQVRIx+2VvWpCQRCFPxVEbARBq0gsLU0rBOs0KeMLpLEx"
    "qfQFfIGkSJMivb0vIOmsUqZNUorYhaB4LO4Ug/h3vdsEHRiYXc6ec3Z2YOEc/zT0AJJlOTR5"
    "CTRzAre70OkjFPpAwa0bId1fgZbOvUCjUOSpiEwC/YI+XJ0N0aI74NrqV+Dd6hxQT+o+D/oy"
    "x3+gC1DHtekx6Q16QMXqN0j9AJ+BHlqX1meB5qCq7VfdDb6TCAzWpmZbVo4hbx5ILlArLnnG"
    "jeISdAOqrWXXCTzFFWi7wy9bMDWHGcchL4ImdnASrTfi0qCp4RbROB8m8Oyc3e/BDh22ef5p"
    "TjBWJZa15CAUhNoAAAAASUVORK5CYII=")

LayersIcon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAK1J"
    "REFUSIntlUsOhCAQRKsaD+bROFp7MK1ZTGJQETtxSGZBExYQmkcVP9ISeoZ1nX0A/gIwlQ1t"
    "q6KJtMTQuPMx1bYqIz8mZuQQ5GIRLTEKiCg+KDgn/ELJQcE+UIC7hwFNJbR0qQAEQe6uL+65"
    "1uahpbZFEOCLNxXM89ze7NrqVa4+UhoKbi1SD4sO7myrJGB5adEtoIQ8BXl/s6da555oiWT8"
    "+ajDx482AG/jAw1KdeBxb3qYAAAAAElFTkSuQmCC")

CreateResultIcon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAT1SURBVFhHzZdrTBxVFMf/d3cH9sHD"
    "EBYsj25rpKn2ETUiNdJoY6rgFlp8xcQPxqjRT0iiTWpbsAS1NRgt9VU11vSj8QOhPFpqaDWp"
    "2kg/UGwRNJaWh2EpAbssLOyyO55z7yx0KZqw4NZ/Mjuz59y559xzf/fOjAgGg/rz33TgWPdV"
    "BMNAWMcNEvKXHUL+RrQYu4mMmgkoXevEV0/dBYvFohxer1dPqWrR4yWOxTEjEsPDw7rr0DlM"
    "1hQDZ0ooVSslTqnOiscQAMw2IOSn6wQ6eIyLsOtkC08BhY2wVx7HlfJ74XQ6yUfhKAnpV/+o"
    "AzMFjzrIZjES4jP/j8XOfZM4FseMSHg8Hn0VV+Ctx1DZ2AuTSUO1Owf7WgZVA6FTH2FY6Dyj"
    "C4R0E3UgFmUPM1vhIGpKVsO+twWXqQIZGRmyf3ACtj1Ncj7iIY7FMSOStbquIv+55scyJuvm"
    "SSWg+IiP5sUyIGwnCN04cOyCBHbntvWobbqoGkiITQSnIJB0hIgoLuPi7HwGdpWuJwibCcL8"
    "aAitcYSQY90A4ex+GQ/9PyG8iZIQughCP0F4sPkiwQOUF6/Dh8e7jCYEFZFpJqhCDBXTZGgh"
    "uyAKLSYz+cwSQAYxTBDyUV68duGd0Lo7fhDa97YuAOEya+fXm7Fpn5BHwZsC+ZUCr5Nt1NtB"
    "Fb7FaKVkvBUsj2pPvIi2zi9Rct/j2F7wAWyJDkm9P+BD5+UzeOHI3bjNWkYtD6sbSIqBOmLg"
    "bbdhik3VDTvQeaUBr+2ow+D4z7gwVI9h36T0ZSTZseHWMqxM3YRPWvbQ9ROocH8hOYmC8LOT"
    "tPvRTvby1nX4/FsFIe+c82HjpazsZlg1O4aunUVbz9PY9eR+nO3/mAIPYHoGOLRNLfryJoFE"
    "qnVmci4ecFWgrqEKbxS3YOPqzf9cgWnjzIF4nhgW5pz6le8+9M4jz6yq+i3IdWYioJ3HgLdb"
    "ln0yCNS5VQKvNgvYNbqgznJT7oRDvx/nf+vGgWdOqX1ANYtWonFwkAipfI4E5VUXua/tl++Q"
    "k5mGgfFuegmh5MkXmFut8ppt7Osf78IKpwNdQz/A7/fHvhHZ6E6uDotmB8NT52SFah/R8X6R"
    "jk9L5obF12xjH1s9/nZ5byAQUAlEOopVfL8v0Df7Kvhv4qctt+V7aBswlqGRwdE2Bk/guYfv"
    "wNFTv0obu/jRaqEtcsbY2XgUbLeYNaTYnPJb4i+/B1aan8rTQn5fTBEsBx9VVahoFbBSJP4u"
    "sFGba1OD8rHNinofiFU19UUYEa3IXkFshBQfDOE7W1QCuykphpBHbzHTdF0FJv68B9VlJ9QU"
    "aOxZgsq3vodLlygAjSqBAmk02kSm3hBfs4193OaPXqAorwIJCQmqAoVHOgiMEIKUOpdzvmS1"
    "+Id817u5jCZhof0gBWus7yIvtQEF+eSg8QRpCoJUDZZGo+YEmNKf2oHb7aV46cE6ZGVlQYyN"
    "jem9vb2gs4QiVoWo9t/3f4SeiUasyaNNJ5PKrQjDDCXj8QA9vwN5SW48m78fLpcLycnJELQU"
    "9ImJCbkklqLp6WmMjo6iq+9HnO47jIHJzrlyUaVy7Bvx0MpXsGFVIbKzs5Gamqq2Yn4kGs2W"
    "JK4AD4STGBkZgc/nkzYWB0pKSkJ6ejrS0tLgcDikjbVsCbC4K/rclzscVzTSNb+kMHA2mw2a"
    "psn/SsDfzX0T7LhwbqsAAAAASUVORK5CYII=")

CreateResult24Icon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlw"
    "SFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoA"
    "AAMESURBVEiJtZVvaJVlGMZ/z842M2dm6482mLJ/rFozKD+MqK3yyzQmVn6ZkBDiGmINBtWi"
    "UkGp1YpmqX2pPoRBh2TIJkkFCoFfxDorRbbqQ5lStD9YMUeN8+vDcTvneN55ToEP3Dzve9/X"
    "c1/vfV3vyxtUruUqKgQUAqXXhCAEykIJr1LPRGijP/SwNLsezIzIJmpOgAHcTKUXeER5WulT"
    "DjvGabehscvSmj6Tvs6M4oinbuIW+qlhNbVALVAzt5ez5Ny7kOgMDHcVIlGYNTkEKlhIL3W0"
    "U0vIaJral18EEhBarlQgzMoVlU9PUMOt1LEyp3l1Evgm1ZxE1uGohjlkOfofsp3v/IVLiiPi"
    "J2KP2Couk3m0zvYww5tIgL8uwqE9uGcaN4q1LhKbRMiOzKaR+SvenkoWuz5dXF2FsYEGcZPY"
    "Kx4VL4iO5xJ4FzOWsE+4KYeAmI9S5xTrlC6Ps9dVs7WXZM2ncmZU9BKaQOMRBHB3rhqZN1vd"
    "yOv+xIByxhmmPYBny1N1ih3lGYeY9E20Y3655iVQ4YQLmXQHnp/CIXH3BD6xHVuKVezmZtfy"
    "njX8IbwsXKfiMW50H7vdTvNVCdKF/kp8Ko73iNgop5+UNXMYKL08WZEf0OHz/O4G9E7+Mca6"
    "XA+wjGJfo94vaLNxNr9SmjfI8CviIfF7GXCaKhXjNLuLhJvQ+9Ab+Fy4I3ICVvgQD/sjHcob"
    "znDY/Zy1XCUusa+lMyljjqKDTNvHMbeizejt/CC05fWAvS7goC9y0r+YVDw3joPbMB5T8SuW"
    "eoB37GLGVrSaP4UXhAUqDnJ9XpNTybEKPH4Q3xY3i6u+RVrmMI00WEqvsDzDh06fY9z1fGY9"
    "dXlNThUfuB/LTlWLj4k7JT4olVm4j2lyF6dsR+9FF3NECiRQ2SlF3bLlI/ltWDTJlCPs8Agr"
    "7ONDt5D0QXQZI8LagiSKiglZ4s+85Zf87X70WbQVreKi0C2UFPSh5Y0e6n2cozaQtJT3hduu"
    "hp/74fznFUIFej4v7H8TFLj+BUNi2SEB1l5nAAAAAElFTkSuQmCC")

NotSorted1 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAABhWlDQ1BJQ0MgcHJvZmlsZQAA'
    b'KJF9kT1Iw0AYht+mSotUHKwgIpKhOlkQFXGUKhbBQmkrtOpgcukfNGlIUlwcBdeCgz+LVQcX'
    b'Z10dXAVB8AfE1cVJ0UVK/C4ptIjxjuMe3vvel7vvAKFRYarZNQGommWk4jExm1sVA68QMIAg'
    b'zRGJmXoivZiB5/i6h4/vd1Ge5V335+hV8iYDfCLxHNMNi3iDeGbT0jnvE4dZSVKIz4nHDbog'
    b'8SPXZZffOBcdFnhm2Mik5onDxGKxg+UOZiVDJZ4mjiiqRvlC1mWF8xZntVJjrXvyF4by2kqa'
    b'67SGEccSEkhChIwayqjAQpR2jRQTKTqPefiHHH+SXDK5ymDkWEAVKiTHD/4Hv3trFqYm3aRQ'
    b'DOh+se2PUSCwCzTrtv19bNvNE8D/DFxpbX+1Acx+kl5va5EjoG8buLhua/IecLkDDD7pkiE5'
    b'kp+WUCgA72f0TTmg/xboWXP71jrH6QOQoV4t3wAHh8BYkbLXPd4d7OzbvzWt/v0APjRykhKl'
    b'f1AAAAAGYktHRABCAIUA9IZeXzgAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnAhUI'
    b'Cjlxa0RtAAABUklEQVRIx+3Xu0qDQRAF4C9RsRYELTRgIYKtCGpnoYXi7TXyDIKFPoGNWFqL'
    b'iDcsBBFEGy8PoBZ22ig+gCQ2E4jhNyT4J0HMgSl2Z9izs+zOnKWN7+jDdVhfs0izOMUMpnGG'
    b'jrQWr7bQBp6wg2fkYhPnjcx2DkeRdQkZ7GOpUaQ53KM3wdeDOwylTdqFC0xWiRnHJbrTJN5E'
    b'voa4fMSmhsfIaAwjCf6R8I3j4TdEmYrxAuZjfgn9Ff5XHKCI47AS1rCCzxh3Yg/r9W7qtsa5'
    b'Em4qXkE25n4sEmkhg0LZuJBwog0hrrsston/L3Ex4XkU0yLurOI7jGZRXhB2K2IWo5NlMJCw'
    b'xgC2Y8Mn0fFaW2J/qyiGo0sd4i3B/4YXLOMjFE2qbXSq2W0UBlshHMql0nE9UqkjxUs2iok4'
    b'VljFO7aaJYdnGyGHa/kAXIU17QPwN/AFLgY+5H5Qjs4AAAAASUVORK5CYII=')

NotSorted2 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABhGlDQ1BJQ0MgcHJvZmlsZQAA'
    b'KJF9kT1Iw0AcxV9TpVIqDlYQcchQnSz4hThKFYtgobQVWnUwufQLmjQkKS6OgmvBwY/FqoOL'
    b's64OroIg+AHi6uKk6CIl/i8ptIjx4Lgf7+497t4BQqPCVLNrHFA1y0jFY2I2tyoGXiFgAAFM'
    b'ICgxU0+kFzPwHF/38PH1LsqzvM/9OXqVvMkAn0g8x3TDIt4gntm0dM77xGFWkhTic+Ixgy5I'
    b'/Mh12eU3zkWHBZ4ZNjKpeeIwsVjsYLmDWclQiaeJI4qqUb6QdVnhvMVZrdRY6578haG8tpLm'
    b'Os1hxLGEBJIQIaOGMiqwEKVVI8VEivZjHv4hx58kl0yuMhg5FlCFCsnxg//B727NwtSkmxSK'
    b'Ad0vtv0xAgR2gWbdtr+Pbbt5AvifgSut7a82gNlP0uttLXIE9G0DF9dtTd4DLneAwSddMiRH'
    b'8tMUCgXg/Yy+KQf03wLBNbe31j5OH4AMdbV8AxwcAqNFyl73eHdPZ2//nmn19wNwRnKms9Cr'
    b'1gAAAAZiS0dEAEIAhQD0hl5fOAAAAAlwSFlzAAAN1wAADdcBQiibeAAAAAd0SU1FB+cCFQc0'
    b'FQkqdM4AAADrSURBVEjH3ZSxDgFBEIa/u5an0EyjEWrJdS4eg56XEzqJWmgU/sZTUNNsIZd1'
    b'Zq4SU+7ufF9md2fgl0LSVFIVySkjcGALbCKSMgg/A8eIpAzCZ0AdkRQRuJnd03ovrU+AuZnt'
    b'w4JP8Ld9l6ToAo9Iiq5wr6RoHDbg5IV/kAzN7NZ2eCWp36EJe5KW/H9IWqQ7jeb1Ja1bf5Gk'
    b'AXBJnVqb2cMLB3bACBib2TU7KtLrz9Nv2HoqacDrd3hbo1XA5lslGfghMipaJR64Z9hlJV74'
    b'V0FOknJccJcgIym9cLegIXl64V2asErT9nfiBd07umqCDqgiAAAAAElFTkSuQmCC')

NotSorted3 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABhWlDQ1BJQ0MgcHJvZmlsZQAA'
    b'KJF9kT1Iw0AYht+mSotUHKwgIpKhOlkQFXGUKhbBQmkrtOpgcukfNGlIUlwcBdeCgz+LVQcX'
    b'Z10dXAVB8AfE1cVJ0UVK/C4ptIjxjuMe3vvel7vvAKFRYarZNQGommWk4jExm1sVA68QMIAg'
    b'zRGJmXoivZiB5/i6h4/vd1Ge5V335+hV8iYDfCLxHNMNi3iDeGbT0jnvE4dZSVKIz4nHDbog'
    b'8SPXZZffOBcdFnhm2Mik5onDxGKxg+UOZiVDJZ4mjiiqRvlC1mWF8xZntVJjrXvyF4by2kqa'
    b'67SGEccSEkhChIwayqjAQpR2jRQTKTqPefiHHH+SXDK5ymDkWEAVKiTHD/4Hv3trFqYm3aRQ'
    b'DOh+se2PUSCwCzTrtv19bNvNE8D/DFxpbX+1Acx+kl5va5EjoG8buLhua/IecLkDDD7pkiE5'
    b'kp+WUCgA72f0TTmg/xboWXP71jrH6QOQoV4t3wAHh8BYkbLXPd4d7OzbvzWt/v0APjRykhKl'
    b'f1AAAAAGYktHRABCAIUA9IZeXzgAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnAhUI'
    b'CTVT8FuFAAABMElEQVRIx+3Wvy5EQRQG8N8iIYItiIpgE9EgRKvTLFGohIZGoRFWLxERLyCK'
    b'1Ygo/Kt0ii0UXsA7KBU6KjSzyYS7hHs32zjJTeZ85875Zs58c+6lgVZAMW2S5hp4D47Qin48'
    b'ZLnyJpyHHcAxJrMk2MVC5HfgBvksks9gPwEfwRlyaZL34xotNeLL2ExDcIC5UPv8pzMphKfy'
    b'26TxlvuwhLYwXg/4JPZwH9R0G/BpbOA5+N1YxNtPpO0oR/4USgnvlUKsauUw94sk62r/BI0n'
    b'SLpUL+iMlNSLwyg+i/Eg07sIf8c2XnGBx78uqhJdvLgC+YDNhUv7Z9vC6jft/xKDaUt7ioka'
    b'7aaYxdlVW3hXhM1jJ0uBjOIkjAdwlfSFzKUkWcEwxrCGp3pIvYihhv2afABtaSaEqaXHQgAA'
    b'AABJRU5ErkJggg==')

NotSorted4 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABhWlDQ1BJQ0MgcHJvZmlsZQAA'
    b'KJF9kT1Iw0AcxV9TtSIVQYuIOGSoThZERcRJqlgEC6Wt0KqDyaUfQpOGJMXFUXAtOPixWHVw'
    b'cdbVwVUQBD9AXF2cFF2kxP8lhRYxHhz34929x907QKiVmGq2jQGqZhnJWFTMZFfEwCsE9KMX'
    b'M+iQmKnHUwtpeI6ve/j4ehfhWd7n/hzdSs5kgE8knmW6YRGvE09tWjrnfeIQK0oK8TnxqEEX'
    b'JH7kuuzyG+eCwwLPDBnp5BxxiFgstLDcwqxoqMSTxGFF1ShfyLiscN7irJYqrHFP/sJgTltO'
    b'cZ3mEGJYRBwJiJBRwQZKsBChVSPFRJL2ox7+QcefIJdMrg0wcsyjDBWS4wf/g9/dmvmJcTcp'
    b'GAXaX2z7YxgI7AL1qm1/H9t2/QTwPwNXWtNfrgHTn6RXm1r4COjZBi6um5q8B1zuAANPumRI'
    b'juSnKeTzwPsZfVMW6LsFulbd3hr7OH0A0tTV0g1wcAiMFCh7zePdna29/Xum0d8PmtdytxdR'
    b'+EUAAAAGYktHRABCAIUA9IZeXzgAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnAhYT'
    b'ACTqRCNBAAACQ0lEQVRIx92VT2hTQRCHv9nECCIU2lBQil4EsVD8g4gHrYeixYhoXqwnD5Kn'
    b'4KGIB6knQcSDgrdAQNqXihVE2zyhaA9B9FIQT+rBnkWQRi0Fq1CqeTsemiaxvtKYtgjOYWGH'
    b'Xb6dmd/MwhqbhHoPZYWW9buBTZTsM0bPzzUKMKHeeKwD9BjQQdS4K4ngT4DjxVE5DlIAsog0'
    b'kxzoXh3Aqf4YIicRJvHdV/juDNbcRaQTx9u+coBKAtU2vs3eq/i+fv6IUgAckv1NjQNS3n5U'
    b'9qBkKPSWKv7nfYrExoEiYlI4XuRvANHq6zkK8g7sZnq8dQy7RQB6vBh2bhtWJhCuAPeBAMcz'
    b'QBSReSWqWqCE72o4QPQhKglE9hGgwGUAAraAZBB5geIBC9E5wIlyFgwwDVwDvoQD8ucmgAlS'
    b'ua1AVZoiATBOPn1jUfQ7MVxlJP2+nOLrKBuXBvxeF1lWziKgtedEwtrWrPWo+B8BqgvLgrq0'
    b'dltjdvHNEF9okb+jtJDKPQAsVi0ij8tzygAJkF2oHgCGah62AbiIk5tE7FhZlaGAKeBSTXRa'
    b'o/0o4KJ6E6M+Rj5UbkW4TUlbEdmByulyT4QA5jvx5xIpDYBRhHYi0SEena2OlGG3iDP4A2wP'
    b'MNZYkX03wJAHWikFBzmSrSq/81YEbC/Ca3z3ZeMqGnFnQHzgME2xtuonFT+D8gnRp8t/mfVY'
    b'cqAbI3sRMlhtB+kCuYOfnlodwLyqLiA0oxjgCb77ph6Z1m8lO0jUdAFFpmff8i/sF8covIjR'
    b'Ofa/AAAAAElFTkSuQmCC')

NotSorted5 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABhGlDQ1BJQ0MgcHJvZmlsZQAA'
    b'KJF9kT1Iw0AcxV9TRdGKgwWLOGRonSyIijhKFYtgobQVWnUwufQLmjQkKS6OgmvBwY/FqoOL'
    b's64OroIg+AHi6uKk6CIl/i8ptIjx4Lgf7+497t4BQqPCVLNrAlA1y0jFY2I2tyr2vELAMPoR'
    b'QUhipp5IL2bgOb7u4ePrXZRneZ/7cwwoeZMBPpF4jumGRbxBPLNp6Zz3iYOsJCnE58TjBl2Q'
    b'+JHrsstvnIsOCzwzaGRS88RBYrHYwXIHs5KhEk8ThxVVo3wh67LCeYuzWqmx1j35CwN5bSXN'
    b'dZqjiGMJCSQhQkYNZVRgIUqrRoqJFO3HPPwjjj9JLplcZTByLKAKFZLjB/+D392ahalJNykQ'
    b'A7pfbPsjAvTsAs26bX8f23bzBPA/A1da219tALOfpNfbWvgIGNwGLq7bmrwHXO4AoSddMiRH'
    b'8tMUCgXg/Yy+KQcM3QJ9a25vrX2cPgAZ6mr5Bjg4BMaKlL3u8e7ezt7+PdPq7weEMnKu7WuF'
    b'vgAAAAZiS0dEAEIAhQD0hl5fOAAAAAlwSFlzAAAN1wAADdcBQiibeAAAAAd0SU1FB+cCFwsp'
    b'LX1XkaMAAAFSSURBVEjH7dSxSlxBFMbxn2KlTxAQrSS1JlaiMUQICJFkIEUqwQnqK0hSJmxr'
    b'I6yEwTcY61SCNkGStbQIKVYEK1srydpM9CKbBXdXsPDAbe459/vPd+6Zw2M87AhppFeJwQ7i'
    b'NRwK6Un/ASFtYgVN7AtptH+AkLbwHvNarSX8KJCx3gEh1fEGc3I8tvvxEsvYK5DxuwIGKuLb'
    b'WEWrPNNybAjpEM/KYZp4IcemkFZvaR3I8bi9g5CGUcdURax6iFrJvStw2MZrPMcXzLZzMARy'
    b'vMBRxc3tuhM5HrX5/mtxOXn3Me1TDHXIfRLSOcYrbXzaoX6s4uRcjiedHKzhO37ic/mBF1hH'
    b'A7/wt1LfwkbJ7VaHZ6CL9VHHIl7K8U95N4hveHU9ZV0Dbi7jWyzgN3Ywg/l/rekNcLNOPpR2'
    b'TRRHp/+/aN1BaljCghzPHuxKf4z7jSsl+GKZss6+VwAAAABJRU5ErkJggg==')

SortDisabled4 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABhWlDQ1BJQ0MgcHJvZmlsZQAA'
    b'KJF9kT1Iw0AcxV9TtSIVQYuIOGSoThZERcRJqlgEC6Wt0KqDyaUfQpOGJMXFUXAtOPixWHVw'
    b'cdbVwVUQBD9AXF2cFF2kxP8lhRYxHhz34929x907QKiVmGq2jQGqZhnJWFTMZFfEwCsE9KMX'
    b'M+iQmKnHUwtpeI6ve/j4ehfhWd7n/hzdSs5kgE8knmW6YRGvE09tWjrnfeIQK0oK8TnxqEEX'
    b'JH7kuuzyG+eCwwLPDBnp5BxxiFgstLDcwqxoqMSTxGFF1ShfyLiscN7irJYqrHFP/sJgTltO'
    b'cZ3mEGJYRBwJiJBRwQZKsBChVSPFRJL2ox7+QcefIJdMrg0wcsyjDBWS4wf/g9/dmvmJcTcp'
    b'GAXaX2z7YxgI7AL1qm1/H9t2/QTwPwNXWtNfrgHTn6RXm1r4COjZBi6um5q8B1zuAANPumRI'
    b'juSnKeTzwPsZfVMW6LsFulbd3hr7OH0A0tTV0g1wcAiMFCh7zePdna29/Xum0d8PmtdytxdR'
    b'+EUAAAAGYktHRABCAIUA9IZeXzgAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnAhYT'
    b'ADGHmceqAAABWElEQVRIx+3Wy0scQRAG8N+4QlSIyaqIiFmTFQQRctFzLoH87Z68eVEIGkWE'
    b'PGXxudHN5RMmwz5gXNiLBcV09UxX1ddd9fUwQVlCC43nOBm0eAHrmEET3+sGmOozNxPnZzjA'
    b'K6yNC0EDG+jiGx7RQRvXuH1ugHW8Sea9zHUzXsMvPNTdouUc7EEyL8tFEHxAUTdAC78xFy2j'
    b'fIs/+eZpTZFxI9rvPP/LphkHs7H38pzHJ5zjB06zZe1saRG9xT5uRqF6jd0h9pPs5t0ge2CZ'
    b'jlVeAkw+wHSfub/hn88pxx6OS2XdwiJWcFjxtZ2GPE1PDUVWbqCi1HRf0vXNCtXMhYXb2BlF'
    b'172KVlHPpvHKlNKN/T5MfKXmZdLBalB1KqzwMYR4NgrBMHkIHbRxifvMb+bd1zLqutfhXc7m'
    b'XTJejB5lq/qSXR3Zyg1Y4AQ/x13mjZTt0sR+Tf4B/opDN1nra1oAAAAASUVORK5CYII=')

SortDisabled5 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABhGlDQ1BJQ0MgcHJvZmlsZQAA'
    b'KJF9kT1Iw0AcxV9TRdGKgwWLOGRonSyIijhKFYtgobQVWnUwufQLmjQkKS6OgmvBwY/FqoOL'
    b's64OroIg+AHi6uKk6CIl/i8ptIjx4Lgf7+497t4BQqPCVLNrAlA1y0jFY2I2tyr2vELAMPoR'
    b'QUhipp5IL2bgOb7u4ePrXZRneZ/7cwwoeZMBPpF4jumGRbxBPLNp6Zz3iYOsJCnE58TjBl2Q'
    b'+JHrsstvnIsOCzwzaGRS88RBYrHYwXIHs5KhEk8ThxVVo3wh67LCeYuzWqmx1j35CwN5bSXN'
    b'dZqjiGMJCSQhQkYNZVRgIUqrRoqJFO3HPPwjjj9JLplcZTByLKAKFZLjB/+D392ahalJNykQ'
    b'A7pfbPsjAvTsAs26bX8f23bzBPA/A1da219tALOfpNfbWvgIGNwGLq7bmrwHXO4AoSddMiRH'
    b'8tMUCgXg/Yy+KQcM3QJ9a25vrX2cPgAZ6mr5Bjg4BMaKlL3u8e7ezt7+PdPq7weEMnKu7WuF'
    b'vgAAAAZiS0dEAEIAhQD0hl5fOAAAAAlwSFlzAAAN1wAADdcBQiibeAAAAAd0SU1FB+cCFwso'
    b'GUX4VFcAAAEUSURBVEjH7dS9SgNREAXgT00holEkCjaCiEUaURSFYNBX0E5fUlDfwNJCG7GM'
    b'P4VNCoUo0QS0GWFZsmtMDKTIgWWHucOcOz/nMsKwo9BvgvGcsx0cYqofgokMfwVreME67tH6'
    b'L4I9rOACt1jAVpB89ktQxTLO8Rq+B8xjuxeSsVTycthfOEU95lCK2AbO4l9O5XqOlnbckgLu'
    b'4oOjVNwNah2qraEZLb3KI2jHbbPQyDi/Dn+plzUduJA2o/yZROxcTvx0opJmVJ1JcJmw6zHA'
    b'dgw2uQhJbMSlfhahZ1RxgmJqG/dxHJX8quQ8PGIWu2F/4ABLoZ9Glg7+igpWo4XFUP5bt29R'
    b'N3jCJBYj+fvQPukjDBbfAaU4kU4RUj4AAAAASUVORK5CYII=')

SortedAsc1 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAABhWlDQ1BJQ0MgcHJvZmlsZQAA'
    b'KJF9kT1Iw0AYht+mSotUHKwgIpKhOlkQFXGUKhbBQmkrtOpgcukfNGlIUlwcBdeCgz+LVQcX'
    b'Z10dXAVB8AfE1cVJ0UVK/C4ptIjxjuMe3vvel7vvAKFRYarZNQGommWk4jExm1sVA68QMIAg'
    b'zRGJmXoivZiB5/i6h4/vd1Ge5V335+hV8iYDfCLxHNMNi3iDeGbT0jnvE4dZSVKIz4nHDbog'
    b'8SPXZZffOBcdFnhm2Mik5onDxGKxg+UOZiVDJZ4mjiiqRvlC1mWF8xZntVJjrXvyF4by2kqa'
    b'67SGEccSEkhChIwayqjAQpR2jRQTKTqPefiHHH+SXDK5ymDkWEAVKiTHD/4Hv3trFqYm3aRQ'
    b'DOh+se2PUSCwCzTrtv19bNvNE8D/DFxpbX+1Acx+kl5va5EjoG8buLhua/IecLkDDD7pkiE5'
    b'kp+WUCgA72f0TTmg/xboWXP71jrH6QOQoV4t3wAHh8BYkbLXPd4d7OzbvzWt/v0APjRykhKl'
    b'f1AAAAAGYktHRABCAIUA9IZeXzgAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnAhUI'
    b'DQURRa4tAAABi0lEQVRIx+3Xz0tUURQH8M+8MZLAhVDMxgSJEAYXUQxEuzYFBv74S/oHhBCX'
    b'4Vr8I6KwKRdtihAKzU21KcilK7VdLXSemxOMjzcPRu8YkQcOvHu/953vfeece895XMhJaeBj'
    b'aCOl4VoFluE1rsXzHh7iKAVxVoEt4TJu4xbqWBy0i6fDvUfIQzv4gNlBkY7jS7g2L+gBPmMi'
    b'NeklvAvjeQ/9io0IQ7IYL0fCTVW808QhnqbM6h/4FfPDJS7dwe/48mHcOC3xUGH8GI+CuCyJ'
    b'ruBNELcL2BPMhzf+2H4Wp6Mv2SqJ71bF+s1C6LKY6/scnyZsna5xp+qCyvwluSD+v4nzkizN'
    b'UxEPVWBrGOkiz/CisGYmKlkNYyU2xrAaG36Fl6k2/h0t3MFkCT4ZWAvfuoH6GYlvRpVaizJa'
    b'lD3sYg4/sZ6yjL7FvYo1Lbw/axktk+vYxtUSbBSfBtE4dLdK7cIpqeF5r1apnjDJmrgbboUF'
    b'7GPlPO6EdTzA/ajb9fO6kBrRj22k/gH49+UYq1BU1gyMjE0AAAAASUVORK5CYII=')

SortedAsc2 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABhGlDQ1BJQ0MgcHJvZmlsZQAA'
    b'KJF9kT1Iw0AcxV9TpVIqDlYQcchQnSz4hThKFYtgobQVWnUwufQLmjQkKS6OgmvBwY/FqoOL'
    b's64OroIg+AHi6uKk6CIl/i8ptIjx4Lgf7+497t4BQqPCVLNrHFA1y0jFY2I2tyoGXiFgAAFM'
    b'ICgxU0+kFzPwHF/38PH1LsqzvM/9OXqVvMkAn0g8x3TDIt4gntm0dM77xGFWkhTic+Ixgy5I'
    b'/Mh12eU3zkWHBZ4ZNjKpeeIwsVjsYLmDWclQiaeJI4qqUb6QdVnhvMVZrdRY6578haG8tpLm'
    b'Os1hxLGEBJIQIaOGMiqwEKVVI8VEivZjHv4hx58kl0yuMhg5FlCFCsnxg//B727NwtSkmxSK'
    b'Ad0vtv0xAgR2gWbdtr+Pbbt5AvifgSut7a82gNlP0uttLXIE9G0DF9dtTd4DLneAwSddMiRH'
    b'8tMUCgXg/Yy+KQf03wLBNbe31j5OH4AMdbV8AxwcAqNFyl73eHdPZ2//nmn19wNwRnKms9Cr'
    b'1gAAAAZiS0dEAEIAhQD0hl5fOAAAAAlwSFlzAAAN1wAADdcBQiibeAAAAAd0SU1FB+cCFQc1'
    b'NStfZUcAAAD4SURBVEjH3ZQxTsNAEEWf3TqnoJmGBkEd2R1WjhF6OMJeKgodFjWCJgW/ySmg'
    b'Ds1KIGsdz7iK2HJ35z2NNPPhok4a1qShi5TUITjsgV1EUgfhH8BbRFIH4fdAH5FUIXhqv/J9'
    b'k+/vgA2pfYkLpuC/7y5JtQgekFSL4U5JNfpswLsbXpZck9rjuc+PpGG1YAkb0vDA/z+StpKa'
    b'BXUrSU9np0jSFXDIm9qb2bcXDjwDN8CtmX0Wo8LMjsAmT8Pe08kI3v+FTy6apA7YzXVSgL+6'
    b'o2JO4oHPht2UxAufT9OCJNe44C5BQVJ74W7BSHLywpcsYSdpfVHJ8AMAyqDmkol81AAAAABJ'
    b'RU5ErkJggg==')

SortedAsc3 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABhWlDQ1BJQ0MgcHJvZmlsZQAA'
    b'KJF9kT1Iw0AYht+mSkUqDlYQccjQOlkQFXGUViyChdJWaNXB5NI/aNKQpLg4Cq4FB38Wqw4u'
    b'zro6uAqC4A+Iq4uToouU+F1SaBHjwd09vPe9L3ffAUKzylSzZxJQNctIJ2JiLr8qBl4hYBhB'
    b'WiMSM/VkZjELz/F1Dx/f76I8y7vuzzGgFEwG+ETieaYbFvEG8eympXPeJw6xsqQQnxNPGHRB'
    b'4keuyy6/cS45LPDMkJFNx4lDxGKpi+UuZmVDJZ4hDiuqRvlCzmWF8xZntVpn7XvyFwYL2kqG'
    b'6zTHkMASkkhBhIw6KqjCQpR2jRQTaTqPefhHHX+KXDK5KmDkWEANKiTHD/4Hv3trFqen3KRg'
    b'DOh9se2PCBDYBVoN2/4+tu3WCeB/Bq60jr/WBOY+SW90tPARMLgNXFx3NHkPuNwBRp50yZAc'
    b'yU9TKBaB9zP6pjwwdAv0r7l9a5/j9AHIUq+Wb4CDQ2C8RNnrHu/u6+7bvzXt/v0ASqlyl2up'
    b'6pEAAAAGYktHRABCAIUA9IZeXzgAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnAhUM'
    b'CgFeYFQvAAABEElEQVRIx+3UMUsDQRAF4C+SKrW1Imgj6c7KXkUw2EvqCBYW+QVWadXS0lJE'
    b'CyuxsrLzF6iInWCpnZjYzMFx3IHxLqbxwcDu7O57c7ezjyliEZ1Jkc/iGUN0JyFwg1HEO9p1'
    b'kh9E5aNMPKBVB/kavnLko8idVyWfx1sBeRpD9KsIHJVUn42PcUmbmfEhntDAcW7fGe7iLlJs'
    b'YA+vMV/A+k+F85X3Cvb0kGTmJ0VEM5N+rf8C0xdoluQfw03hEy+ZtU0sYRX3uXP70XVXuTNj'
    b'4TbaMylw4ATb8Wh/jT52StYauAjbqYRTLBfkB2GYldHCdc7Ct8Lqa0M7viR14suyf1YFXcxh'
    b'Bbth97Wjk2npv8c3mNxDKF2XEbIAAAAASUVORK5CYII=')

SortedAsc4 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABhWlDQ1BJQ0MgcHJvZmlsZQAA'
    b'KJF9kT1Iw0AcxV9TtSIVQYuIOGSoThZERcRJqlgEC6Wt0KqDyaUfQpOGJMXFUXAtOPixWHVw'
    b'cdbVwVUQBD9AXF2cFF2kxP8lhRYxHhz34929x907QKiVmGq2jQGqZhnJWFTMZFfEwCsE9KMX'
    b'M+iQmKnHUwtpeI6ve/j4ehfhWd7n/hzdSs5kgE8knmW6YRGvE09tWjrnfeIQK0oK8TnxqEEX'
    b'JH7kuuzyG+eCwwLPDBnp5BxxiFgstLDcwqxoqMSTxGFF1ShfyLiscN7irJYqrHFP/sJgTltO'
    b'cZ3mEGJYRBwJiJBRwQZKsBChVSPFRJL2ox7+QcefIJdMrg0wcsyjDBWS4wf/g9/dmvmJcTcp'
    b'GAXaX2z7YxgI7AL1qm1/H9t2/QTwPwNXWtNfrgHTn6RXm1r4COjZBi6um5q8B1zuAANPumRI'
    b'juSnKeTzwPsZfVMW6LsFulbd3hr7OH0A0tTV0g1wcAiMFCh7zePdna29/Xum0d8PmtdytxdR'
    b'+EUAAAAGYktHRABCAIUA9IZeXzgAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnAhYT'
    b'ABjFK1/GAAACPElEQVRIx82VzUtUYRSHn/POB32BfUyGNbhpNRYk0aJFtrEsijLHapUYc40i'
    b'IuoPCKQ2Be2EImx04c6cuxjKXbRw0SLoi9A2RQSR4eQiBCvvvKeFt+k6cyUdlTq7+3tfeM7H'
    b'77wXVjgkVG26K2yONQJ1ePqY/Lkf1QKioeqW2E6sdKOaJGK2Az3VAiIVSjqbALkCHECkHiRG'
    b'6tgEb/Pvlg442RtHTSeQAZJADGEbYlaROv6GsfzXxQLMnC+Vo2AvAnWB+awGbUE4T1tvTfUV'
    b'tGf3olwF2QGsLTNCHNiEyDSp1ueM5XXxQ1YOI5JEKQAW2OCfeMAnhCJKB5AFiqSzBogiMlup'
    b'qgU8XEfDAaKDqPkOuhXoKEvkPSojKM+Amd92AFr9NhtgEugGJsIBua5RYJT2vnrgBKrrSxWI'
    b'PCGXuVEG3YXhGkOZD36Lr6Osmx8wdy7y14UUAQ3qImFra1b6qfgvALIUQOUMtMLiimoYxFbc'
    b'q9RChzwFjAC7AYvoFJjX/jtlgCMgjajuAwYCia0BLpPu+4zYYd+VoYACop2omEBmXiAhB9Wb'
    b'GHUx8jHgvdt4WotICpXT/k6EAGY3cWaelhaBPEIDkegAg2e90skDZ5x0/0+wp4Dh6lzkOkUM'
    b'OaAWr9hEy50/s9l/KwL2EsILXOdp9TYdcr6BuMBBauLJkp5InEH5guij5bFg2/1DGNmD0IPV'
    b'BpBmkHu4mcKyeZx09gLCRhQDPMR1Xi7sn7zQ8Gw/UdMMjDM5/Yp/Eb8AKNmu9BQXtZwAAAAA'
    b'SUVORK5CYII=')

SortedAsc5 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABhGlDQ1BJQ0MgcHJvZmlsZQAA'
    b'KJF9kT1Iw0AcxV9TRdGKgwWLOGRonSyIijhKFYtgobQVWnUwufQLmjQkKS6OgmvBwY/FqoOL'
    b's64OroIg+AHi6uKk6CIl/i8ptIjx4Lgf7+497t4BQqPCVLNrAlA1y0jFY2I2tyr2vELAMPoR'
    b'QUhipp5IL2bgOb7u4ePrXZRneZ/7cwwoeZMBPpF4jumGRbxBPLNp6Zz3iYOsJCnE58TjBl2Q'
    b'+JHrsstvnIsOCzwzaGRS88RBYrHYwXIHs5KhEk8ThxVVo3wh67LCeYuzWqmx1j35CwN5bSXN'
    b'dZqjiGMJCSQhQkYNZVRgIUqrRoqJFO3HPPwjjj9JLplcZTByLKAKFZLjB/+D392ahalJNykQ'
    b'A7pfbPsjAvTsAs26bX8f23bzBPA/A1da219tALOfpNfbWvgIGNwGLq7bmrwHXO4AoSddMiRH'
    b'8tMUCgXg/Yy+KQcM3QJ9a25vrX2cPgAZ6mr5Bjg4BMaKlL3u8e7ezt7+PdPq7weEMnKu7WuF'
    b'vgAAAAZiS0dEAEIAhQD0hl5fOAAAAAlwSFlzAAAN1wAADdcBQiibeAAAAAd0SU1FB+cCFwsp'
    b'BD/lCc8AAAE0SURBVEjH7dU/S9tBHMfxl5KpHZw6CMU8CFvcqpsZVPDAudAr+hzSB+DqIsTA'
    b'PYSek7NUHUTUjJ3TTdDVSYjLoT9S479EcMgXjuP+8Hnf3ee+d4zjfUdIH4eVmHxEfBMnQpoe'
    b'PSCkLfxAFwdC+jw6QEjbWMOCXm8FxwUyMzwgpBaW8U2Of+3+vMF37BdI/aWAiYr4DtbRK+Wr'
    b'HM+FdILZspgu5uXYFdIqPlW0shwv+wG1Iv4BrVLgvG8Rm/hd2r1SN/GlMu8UAwA5XqNT2U3/'
    b'vH9y7Iz2mo4oao+M/RLSFerDACYG5MF6X89hMbhZMfZ/k+89aMvxbDBgcHbX8eeJXW3Isf06'
    b'D3LsYg5HD4xeY6kq/jqTc7zAIvYqvRdoyHHveR48/8haaNwl3xs96VPjf+19xy0/blU2AHfV'
    b'GwAAAABJRU5ErkJggg==')

SortedDesc1 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAABhWlDQ1BJQ0MgcHJvZmlsZQAA'
    b'KJF9kT1Iw0AYht+mSotUHKwgIpKhOlkQFXGUKhbBQmkrtOpgcukfNGlIUlwcBdeCgz+LVQcX'
    b'Z10dXAVB8AfE1cVJ0UVK/C4ptIjxjuMe3vvel7vvAKFRYarZNQGommWk4jExm1sVA68QMIAg'
    b'zRGJmXoivZiB5/i6h4/vd1Ge5V335+hV8iYDfCLxHNMNi3iDeGbT0jnvE4dZSVKIz4nHDbog'
    b'8SPXZZffOBcdFnhm2Mik5onDxGKxg+UOZiVDJZ4mjiiqRvlC1mWF8xZntVJjrXvyF4by2kqa'
    b'67SGEccSEkhChIwayqjAQpR2jRQTKTqPefiHHH+SXDK5ymDkWEAVKiTHD/4Hv3trFqYm3aRQ'
    b'DOh+se2PUSCwCzTrtv19bNvNE8D/DFxpbX+1Acx+kl5va5EjoG8buLhua/IecLkDDD7pkiE5'
    b'kp+WUCgA72f0TTmg/xboWXP71jrH6QOQoV4t3wAHh8BYkbLXPd4d7OzbvzWt/v0APjRykhKl'
    b'f1AAAAAGYktHRABCAIUA9IZeXzgAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnAhUI'
    b'DB6CO1aAAAABhUlEQVRIx+3XP0scYRAG8N/5B20FQQujkRSWFmKRRkghQoJena/gl0gRP0Ga'
    b'YJnCykKSqCkCwRAMEqNFYpoYkpQ2YqlFdNPMwrnsHXv43kGIDwzs7gzzzPvu7jzzcovrGMHH'
    b'sJFukfbgDebxAG/Rmyp5q0Qr+IEX+I3xKOJdJ1f7EK9j1Tlq2EC9U6TjOMRwiW8IB5hMTdqP'
    b'HdxvETOLDxhISfwMyxXiliM2GY5jRTOYKvFPhW8W329CVCvcL+JRPK9jtOA/wUtk2AzL8QSP'
    b'cdXwO67habtFfa74LMc+LqOoLK73WzWJVKgV8vWU7GhHiNtui7fE/y9xVvKVZqmI+1r4XoVY'
    b'/GmIXS/ELIWS1TBWkmMMq1HwViheaedqFz9xHnkGS1TrFy6CeBD3qqy4CjYxjbkm/ryQ9/iS'
    b'WkbzpFkT+4bd1DIKd3CE0xLSM3ztxODQOCp9KojEFfaajUqppsZjTATh3Yb3uoPnVfT4pj1h'
    b'O2a13tj6hdiFrhwA9sK6dgD4N/AXYIRSoFOmGwcAAAAASUVORK5CYII=')

SortedDesc2 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABhGlDQ1BJQ0MgcHJvZmlsZQAA'
    b'KJF9kT1Iw0AcxV9TpVIqDlYQcchQnSz4hThKFYtgobQVWnUwufQLmjQkKS6OgmvBwY/FqoOL'
    b's64OroIg+AHi6uKk6CIl/i8ptIjx4Lgf7+497t4BQqPCVLNrHFA1y0jFY2I2tyoGXiFgAAFM'
    b'ICgxU0+kFzPwHF/38PH1LsqzvM/9OXqVvMkAn0g8x3TDIt4gntm0dM77xGFWkhTic+Ixgy5I'
    b'/Mh12eU3zkWHBZ4ZNjKpeeIwsVjsYLmDWclQiaeJI4qqUb6QdVnhvMVZrdRY6578haG8tpLm'
    b'Os1hxLGEBJIQIaOGMiqwEKVVI8VEivZjHv4hx58kl0yuMhg5FlCFCsnxg//B727NwtSkmxSK'
    b'Ad0vtv0xAgR2gWbdtr+Pbbt5AvifgSut7a82gNlP0uttLXIE9G0DF9dtTd4DLneAwSddMiRH'
    b'8tMUCgXg/Yy+KQf03wLBNbe31j5OH4AMdbV8AxwcAqNFyl73eHdPZ2//nmn19wNwRnKms9Cr'
    b'1gAAAAZiS0dEAEIAhQD0hl5fOAAAAAlwSFlzAAAN1wAADdcBQiibeAAAAAd0SU1FB+cCFQc2'
    b'LRMertIAAAD3SURBVEjH5ZQ9bsJQDIC/ZA2nYPHSpaIzSrZGHAP29gi+FKJbn5irdmGoF04B'
    b'MwzNwF+I/SakvtHP/j5Zsg2P9MxsamZNpKaMwIEVsIxIyiD8B/iKSMog/BVoI5IiAheRXRev'
    b'uvgLMBORz7CgD37y75IUOfCIpMiFeyXFRbIA3154j+RJRLb3kt/MbJSxhJWZLfgHT9McTVVG'
    b'3QhN7/enSNMY2HSb2qL13g2HD+AZmKD17+1TofUWmHXTsHJ1cg5vT+H9m6ypAZaDnVzD1/5b'
    b'NCRxwAePXa/ECR8W3JL81bjgPsG1pPTC/YJzycELz1nCBk3ThzoMR8Q6pah2xhxgAAAAAElF'
    b'TkSuQmCC')

SortedDesc3 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABhWlDQ1BJQ0MgcHJvZmlsZQAA'
    b'KJF9kT1Iw0AYht+mSkUqDlYQccjQOlkQFXGUViyChdJWaNXB5NI/aNKQpLg4Cq4FB38Wqw4u'
    b'zro6uAqC4A+Iq4uToouU+F1SaBHjwd09vPe9L3ffAUKzylSzZxJQNctIJ2JiLr8qBl4hYBhB'
    b'WiMSM/VkZjELz/F1Dx/f76I8y7vuzzGgFEwG+ETieaYbFvEG8eympXPeJw6xsqQQnxNPGHRB'
    b'4keuyy6/cS45LPDMkJFNx4lDxGKpi+UuZmVDJZ4hDiuqRvlCzmWF8xZntVpn7XvyFwYL2kqG'
    b'6zTHkMASkkhBhIw6KqjCQpR2jRQTaTqPefhHHX+KXDK5KmDkWEANKiTHD/4Hv3trFqen3KRg'
    b'DOh9se2PCBDYBVoN2/4+tu3WCeB/Bq60jr/WBOY+SW90tPARMLgNXFx3NHkPuNwBRp50yZAc'
    b'yU9TKBaB9zP6pjwwdAv0r7l9a5/j9AHIUq+Wb4CDQ2C8RNnrHu/u6+7bvzXt/v0ASqlyl2up'
    b'6pEAAAAGYktHRABCAIUA9IZeXzgAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnAhUM'
    b'CQuVmO7yAAABCElEQVRIx+3WrUsEURQF8J8fabNicxG0yLZtmhcRXOxi3mhYsFsUTIpFjGbR'
    b'YBKTf4PVotlqEna1XOExzCzsfLDFA5eZOW/mnPu4912GGWId/aoiCwX8Eq4wQhuvdWf/EMJw'
    b'i06d4ifYS55beIprZfRwlsNvxk4qoY17zBWsH2BYxeAS++hGkVN0I16mFZ1P7i+wim2cZsSP'
    b'gz9P+B184yfibRrjm4zBIOedQSL+FxN30Aj+DWZvsFjAryWdtILrZG0XG9jK+e4ouukRH2WT'
    b'+sppzzRGcWhLY4jxBIPPZBKXxl1kmpd9r47atWI0pOLjGPW1oZOpx3MTXXgYmb9jualW78cP'
    b'wmzwCyHZQimhVrthAAAAAElFTkSuQmCC')

SortedDesc4 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABhWlDQ1BJQ0MgcHJvZmlsZQAA'
    b'KJF9kT1Iw0AcxV9TtSIVQYuIOGSoThZERcRJqlgEC6Wt0KqDyaUfQpOGJMXFUXAtOPixWHVw'
    b'cdbVwVUQBD9AXF2cFF2kxP8lhRYxHhz34929x907QKiVmGq2jQGqZhnJWFTMZFfEwCsE9KMX'
    b'M+iQmKnHUwtpeI6ve/j4ehfhWd7n/hzdSs5kgE8knmW6YRGvE09tWjrnfeIQK0oK8TnxqEEX'
    b'JH7kuuzyG+eCwwLPDBnp5BxxiFgstLDcwqxoqMSTxGFF1ShfyLiscN7irJYqrHFP/sJgTltO'
    b'cZ3mEGJYRBwJiJBRwQZKsBChVSPFRJL2ox7+QcefIJdMrg0wcsyjDBWS4wf/g9/dmvmJcTcp'
    b'GAXaX2z7YxgI7AL1qm1/H9t2/QTwPwNXWtNfrgHTn6RXm1r4COjZBi6um5q8B1zuAANPumRI'
    b'juSnKeTzwPsZfVMW6LsFulbd3hr7OH0A0tTV0g1wcAiMFCh7zePdna29/Xum0d8PmtdytxdR'
    b'+EUAAAAGYktHRABCAIUA9IZeXzgAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnAhYT'
    b'AAo2ki6OAAACNklEQVRIx8WVQUhUURiFv/NmnIQUKWejWW2CgnRRtGhTrSJSjJzJffRq56KF'
    b'FLRq0daVIZQ9KykixJGMICRaGdQqIrKCwlWTWISpIObM+1s4M476pqY3hgfug/u//3Leufec'
    b'++A/Q4HVY32ifssBoIGM/4zRC4thCZzAajzWAtYGtBB13EoUrCdIeHFM7aAxoA9pOx23TmwM'
    b'wZn+GNJpxFdS7itS7iy+cwfpKAlvb+UEplbMmphbGCzUfk5/wRgDEnT014UnSHqHMR3E6GWs'
    b'K1OoP79kKDYOTCEnScKL/AtBdOXrOQl6B34jnV4VQ+4UAJ1eDH9xD74mEJeBe0CWhOcgi2Ja'
    b'dqLMx5Qh5VqwAtlDYCfSWbJ0F+pZdmHqRTqOycOUV9cBvABeA28w3QXipRUMn58AJkgO7AZW'
    b'rCllgXGGz11bs7YZUzNQnZtvBWqAb3/LgRMQwPV9kq3qk5ZHWUErHxYuyRuITSAwyz/y7rLi'
    b'6R+2x4BsaRetYB6jnuTAA8DHNx9pJHdPOUAb6BBmR1bnyGqBbhIDaeSP5lwZSPAduFikzoC8'
    b'96uAK8hqMWoCFLQim8dUDVwNJlhO4lKJLc0AgxhdQOOa9duACMZH4Gm4Q065WSLcx3gCzAB+'
    b'0dslII24Tcp9Gd5FQ+4scm7m/hcLRclLg24ge1zcHgnlvfePfrCvfR6cBsQOYBqUAq4z7M5V'
    b'TgDwYfQz+0/VYTSBfQJ6GHEny7Fp+fjle1RpEphiZvEtm4HfMRO6RoMBA8cAAAAASUVORK5C'
    b'YII=')

SortedDesc5 = PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABhGlDQ1BJQ0MgcHJvZmlsZQAA'
    b'KJF9kT1Iw0AcxV9TRdGKgwWLOGRonSyIijhKFYtgobQVWnUwufQLmjQkKS6OgmvBwY/FqoOL'
    b's64OroIg+AHi6uKk6CIl/i8ptIjx4Lgf7+497t4BQqPCVLNrAlA1y0jFY2I2tyr2vELAMPoR'
    b'QUhipp5IL2bgOb7u4ePrXZRneZ/7cwwoeZMBPpF4jumGRbxBPLNp6Zz3iYOsJCnE58TjBl2Q'
    b'+JHrsstvnIsOCzwzaGRS88RBYrHYwXIHs5KhEk8ThxVVo3wh67LCeYuzWqmx1j35CwN5bSXN'
    b'dZqjiGMJCSQhQkYNZVRgIUqrRoqJFO3HPPwjjj9JLplcZTByLKAKFZLjB/+D392ahalJNykQ'
    b'A7pfbPsjAvTsAs26bX8f23bzBPA/A1da219tALOfpNfbWvgIGNwGLq7bmrwHXO4AoSddMiRH'
    b'8tMUCgXg/Yy+KQcM3QJ9a25vrX2cPgAZ6mr5Bjg4BMaKlL3u8e7ezt7+PdPq7weEMnKu7WuF'
    b'vgAAAAZiS0dEAEIAhQD0hl5fOAAAAAlwSFlzAAAN1wAADdcBQiibeAAAAAd0SU1FB+cCFwsp'
    b'EssxvJ4AAAE9SURBVEjH7dWxa1NRFMfxj6FTHTqVbjqJs9StQhQzKZT2QQudL8T+C9Wu6uoi'
    b'hMijeyl36x9QOpYKnTpIhwRBCmbtaBzeFcIjvCZ5FTL0TIdzD+fL+Z1z7+Xe5tuyfKluiUZF'
    b'8Q4uZPnjOoAHYwov4hBvU+QaW2I4rQ/I8hUc4UUp7wbbYjieHVBIcYIqSd6JoTs9oJDlPZZT'
    b'fHPEh4jfye+K4VyWt0u1TsVwefsMCuAZno9EVsXwvZQzTOABNrA/rrtGzS38KIY2etOv6R3Z'
    b'whSXbhFPKzIeyfJnyR+IoV8F+FQacl8MN7J8F20M8WfkfIg9fEhyNauHXN1JB2/wSgxXKdbA'
    b'N7xGUwy92QFFwa9pc1r4gQOs4eU/aeoBCsgX7OAcT1JHPye7B5NDPmMdLTH8+l9P+sP7f22+'
    b'7S8OD1DiSVgUyQAAAABJRU5ErkJggg==')

SortDisabled = SortDisabled5
NotSorted = NotSorted5
SortedAsc = SortedAsc5
SortedDesc = SortedDesc5

#----------------------------------------------------------------------------

APP_NAME = Version.app_name('VMoveCAE')
APP_NAME_VER = Version.app_name_ver('VMoveCAE')

#----------------------------------------------------------------------------

SORT_STATE_DISABLED = 0
SORT_STATE_NOT_APPLIED = 1
SORT_STATE_ASCENDING = 2
SORT_STATE_DESCENDING = 3

GEOM_TREE = "Geometry"
RESULT_TREE = "Results"
INSTANCE_LIST = "Instances"

#----------------------------------------------------------------------------

LICENSE_STATUS_UNKNOWN = 0
LICENSE_ACQUIRED = 1
LICENSE_RECONNECTING = 2
LICENSE_LOST = 3

LICENSE_STATUS_UNKNOWN_TEXT = 'License Status Unknown'
LICENSE_ACQUIRED_TEXT = 'License Acquired'
LICENSE_RECONNECTING_TEXT = 'Acquiring License'
LICENSE_LOST_TEXT = 'License Lost'

#----------------------------------------------------------------------------

def CompareInstances(in1, in2):
    return cmp([int(x) for x in in1.split(':')[1:]], 
                    [int(x) for x in in2.split(':')[1:]])
#    id_list1 = [int(x) for x in l1.split(':')[1:]]
#    id_list2 = [int(x) for x in l2.split(':')[1:]]
#    if len(id_list1) > len(id_list2):
#        if id_list2 < id_list1:
#            return -1
#        if id_list1 < id_list2:
#            return -1
#        elif id_list1 > id_list2:
#            return 1
#        else: 
#            return 0
#    else
#        if id_list2 < id_list1:
#            return -1
#        elif id_list2 > id_list1:
#            return 1
#        else: 
#            return 0

#----------------------------------------------------------------------------
def SortInstances(ilist):
    if platform.python_version() > '2.4':
        # ilist.sort(cmp=CompareInstances)
        sorted(ilist)
    else:
        sorted(ilist)
        # ilist.sort(CompareInstances)

#----------------------------------------------------------------------------
def uniqueList(anyList):
    """given a list, returns a unique list with the order retained"""
    # create an empty dictionary
    dic1 = {}

    # use a list comprehension statement and the unique feature of a dictionary

    return [dic1.setdefault(e,e) for e in anyList if e not in dic1]

#----------------------------------------------------------------------------
class TranslationThread(Thread):
    def __init__(self, engine, cax_file, trans_string, ignore_midnodes, elem_res_trans, en_to_e_avg, attributes_dict):
        Thread.__init__(self)

        self.engine = engine
        self.cax_file = cax_file
        self.trans_string = trans_string
        self.ignore_midnodes = ignore_midnodes
        self.elem_res_trans = elem_res_trans
        self.en_to_e_avg = en_to_e_avg
        self.attributes_dict = attributes_dict

        self.result = ''

    def run(self):
        self.result = self.engine.TranslateInThread(self.cax_file, 
                        self.trans_string,
                        self.ignore_midnodes, 
                        self.elem_res_trans, 
                        self.en_to_e_avg,
                        self.attributes_dict,
                        None, None)

    def getResult(self):
        return self.result

#----------------------------------------------------------------------------

def curr_app_folder():
    if getattr(sys, 'frozen', False):
        folder_path = os.path.dirname(sys.executable)
    elif __file__:
        folder_path = os.path.dirname(__file__)

    return folder_path

#----------------------------------------------------------------------------

class LicenseToolBar(wx.ToolBar):
    def __init__(self, parent):
        wx.ToolBar.__init__(self, parent, -1, wx.DefaultPosition,
                            wx.DefaultSize, wx.TB_FLAT|wx.TB_NODIVIDER)
    
        self.tool_id = wx.NewIdRef(count=1)
        self.SetToolBitmapSize(wx.Size(24,24))
        self.AddTool(self.tool_id, 
                    LicenseAcquiredIcon.GetBitmap(), LICENSE_ACQUIRED_TEXT)
        self.EnableTool(self.tool_id, False)

    def UpdateProps(self, icon, hint, enabled=False):
        self.SetToolNormalBitmap(self.Id_LicenseStatusTool, icon.GetBitmap())
        self.SetToolDisabledBitmap(self.Id_LicenseStatusTool,
                                   icon.GetBitmap().ConvertToDisabled())
        self.SetToolShortHelp(self.Id_LicenseStatusTool, hint)
        self.EnableTool(self.Id_LicenseStatusTool, enabled)

    def SetState(self, state):
        if state == LICENSE_ACQUIRED:
            self.UpdateProps(LicenseAcquiredIcon,
                                    LICENSE_ACQUiRED_TEXT)
        elif state == LICENSE_STATUS_UNKNOWN:
            self.UpdateProps(LicenseStatusUnknownIcon,
                                    LICENSE_STATUS_UNKNOWN_TEXT)
        elif state == LICENSE_LOST:
            self.UpdateProps(LicenseLostIcon,
                                    LICENSE_LOST_TEXT)
        elif state == LICENSE_RECONNECTING:
            self.UpdateProps(LicenseConnectingIcon,
                                    LICENSE_RECONNECTING_TEXT)

#----------------------------------------------------------------------------

class LicenseHandlerThread(Thread):
    def __init__(self):
        Thread.__init__(self)
        self.result = None

    def run(self):
        pass

    def getResult(self):
        return self.result

#----------------------------------------------------------------------------

class VmoveCaeFrame(wx.Frame):
    def __init__(self, engine, tmpdir, parent = None, title = APP_NAME):
        self.engine = engine
        self.tmpdir = tmpdir
        self.dir_path = os.path.dirname(os.path.realpath(__file__))
        #self.engine_root = et.Element(engine.GetRootName())
        #self.data_root = et.SubElement(self.engine_root, "data")
        #self.data_root.set("name", "Data Manager")
        #self.data_root.set("appendable", "false")
        #self.data_root.set("update", "true")
        #self.ndict = {self.engine_root: None, self.data_root: None}
        #self.invdict = {}
        self.cmd_option_list = []
        self.cmd_file_list = []
        self.sort_states = {
            GEOM_TREE: SORT_STATE_DISABLED,
            RESULT_TREE: SORT_STATE_DISABLED,
            INSTANCE_LIST: SORT_STATE_DISABLED,
        }

        self.cfg = wx.Config(title)
        (w, h) = (700, 600)
        #if self.cfg.Exists('width'):
        #    w = self.cfg.ReadInt('width')
        #if self.cfg.Exists('height'):
        #    h = self.cfg.ReadInt('height')
        #self.frame_title = title + ' - Log folder: ' + self.tmpdir.getPath()
       
        self.frame_title = title.decode() + ' - Log folder: ' + self.tmpdir.getPath()
        wx.Frame.__init__(self, parent, -1, self.frame_title, 
                        wx.DefaultPosition, wx.Size(w, h))
        self.SetTitle(self.frame_title)
        self.SetBackgroundColour('LIGHT GREY');
        self.arch=Common.GetArchitecture()
        if self.arch in ['win32', 'win64']:
            self.SetIcon(wx.Icon(os.path.join(
                self.dir_path, Const.VMOVECAE_ICON), wx.BITMAP_TYPE_ICO))
        else:
            self.SetIcon(wx.Icon(icons.VMoveCaeIcon.GetBitmap()))

        self.manager = wx.aui.AuiManager()
        self.manager.SetManagedWindow(self)

        self.is_appendable = False
        self.addMenuBar()
        self.statusbar = self.CreateStatusBar()
        self.statusbar.SetFieldsCount(2)
        self.statusbar.SetStatusWidths([-1, -1])
        
        self.statusbar.SetStatusText('Welcome to ' + APP_NAME.decode())
        
        #self.statusbar.SetStatusText('Log folder: ' + self.tmpdir.getPath())

        self.progressbar = wx.Gauge(self.statusbar, -1, style=wx.GA_HORIZONTAL|wx.GA_SMOOTH)
        rect = self.statusbar.GetFieldRect(1)
        self.progressbar.SetPosition((rect.x+2, rect.y+2))
        self.progressbar.SetSize((rect.width-4, rect.height-4))
        self.progressbar.Hide()

        self.addToolBar()
        self.addTreeCtrls()
        self.addAdditionalPanels()

        vmove_folder_name = None
        if self.arch == 'win32':
            vmove_folder_name = 'VMoveCAE32'
        if self.arch == 'win64':
            vmove_folder_name = 'VMoveCAE64'

        self.app_folder_path = curr_app_folder()

        self.vmove_dir = None
        self.help_file = None
        if self.arch in ['win32', 'win64']:
            self.vmove_dir = os.environ.get('VCOLLAB_DIR')
            if self.vmove_dir:
                self.vmove_dir += vmove_folder_name + os.sep
            #else:
                #wx.MessageBox('Unable to identify the VCollab Installation '
                #              'Directory.  \n\nIn case that you recently '
                #              'installed VCollab Suite %s \nand system is '
                #              'not rebooted afterwards, please reboot \n your '
                #              'system.  Otherwise, please reinstall VCollab '
                #              'Suite.\n\nExiting VMoveCAE %s',
                #              'Error!' % (Version.VERSION, Version.VERSION))
                #self.Close(True)
            self.launch_dir = os.getcwd() + os.sep
            help_filename = 'VMoveCAE User Guide.chm'
            if os.path.exists(self.launch_dir+help_filename):
                self.help_file = self.launch_dir + help_filename 
            elif os.path.exists(self.launch_dir+'Help'+os.sep+help_filename):
                self.help_file = self.launch_dir + 'Help' + os.sep + help_filename 
            elif self.vmove_dir and \
                    os.path.exists(self.vmove_dir+'Help'+os.sep+help_filename):
                self.help_file = self.vmove_dir + 'Help'+os.sep+help_filename 
        else:
            self.vmove_dir = os.environ.get('VMOVE_DIR')
            if self.vmove_dir:
                self.help_file = 'file://' + self.vmove_dir + os.sep 
                self.help_file += 'share' + os.sep + 'doc' + os.sep + 'VMoveCAE' + os.sep + 'contents.html'
            else:
                self.help_file = 'http://training.vcollab.com/etraining.html?page=VMoveCAE_CS.html'

        self.language = wx.LANGUAGE_DEFAULT
        self.language = wx.LANGUAGE_ENGLISH_US
        LOCALE_FOLDER = 'locale'
        wx.Locale.AddCatalogLookupPathPrefix(LOCALE_FOLDER)
        lcfolder = os.path.join(self.app_folder_path, LOCALE_FOLDER)
        wx.Locale.AddCatalogLookupPathPrefix(lcfolder)
        if self.vmove_dir:
            lcfolder = os.path.join(self.vmove_dir, LOCALE_FOLDER)
            wx.Locale.AddCatalogLookupPathPrefix(lcfolder)

        self.locale = wx.Locale()
        if self.locale.Init(self.language):
            self.locale.AddCatalog("wizard-custom")

        self.Id_Wizard = wx.NewIdRef(count=1)
        self.Id_Wizard_TextCtrl = wx.NewIdRef(count=1)
        self.Id_Wizard_Button = wx.NewIdRef(count=1)
        self.wizard_textctrl = None
        self.mb_encoding = locale.getpreferredencoding()
        # self.createUpgradeOdbWizard()

        self.manager.Update()

        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.part_tree.Bind(ct.EVT_TREE_SEL_CHANGED, self.OnPartTreeSelect)
        self.part_tree.Bind(ct.EVT_TREE_ITEM_CHECKED, self.OnPartTreeCheck)
        self.result_tree.Bind(ct.EVT_TREE_SEL_CHANGED, self.OnResultSel)
        self.result_tree.Bind(ct.EVT_TREE_ITEM_CHECKED, self.OnResultCheck)
        #self.result_tree.Bind(wx.EVT_RIGHT_DOWN, self.OnResultRightDown)
        #self.result_tree.Bind(wx.EVT_RIGHT_UP, self.OnResultRightUp)
        self.instance_listbox.Bind(wx.EVT_LIST_ITEM_UNCHECKED, 
                                                self.OnInstanceUnCheck)
        self.instance_listbox.Bind(wx.EVT_LIST_ITEM_CHECKED, 
                                                self.OnInstanceCheck)
        # self.instance_listbox.Bind(wx.EVT_LIST_ITEM_SELECTED, 
        #                                         self.OnInstanceFocused)
        self.Bind(wx.EVT_CLOSE, self.OnClose)
        self.Bind(wx.EVT_CHECKBOX, self.OnItems)
        self.model_file = None
        self.results_file = None
        self.file_type = None
        if self.cfg.Exists('cwd'):
            try:
                os.chdir(self.cfg.Read('cwd'))
            except os.error as msg:
                self.cfg.Write('cwd', os.getcwd())
        self.local_file_caching_key = 'InputFilecaching'
        self.enable_local_file_caching = ('True' == self.cfg.Read(self.local_file_caching_key, 'False'))
        self.ignore_midnodes_key = 'IgnoreMidNodes'
        self.ignore_midnodes = ('True' == self.cfg.Read(self.ignore_midnodes_key, 'True'))
        #self.disable_parts_key = 'DisableParts'
        #self.disable_parts = ('True' == self.cfg.Read(self.disable_parts_key, 'False'))
        self.sep_partsets_key = 'SeparatePartSets'
        self.sep_partsets = ('True' == self.cfg.Read(self.sep_partsets_key, 'False'))
        self.element_results_key = 'ElementResults'
        self.elem_res_trans = ('True' == self.cfg.Read(self.element_results_key, 'False'))
        self.entoe_key = 'EN_to_E'
        self.en_to_e_avg = ('True' == self.cfg.Read(self.entoe_key, 'False'))
        self.encoding_key = 'Encoding'
        #self.mb_encoding = self.cfg.Read(self.encoding_key, 'raw-unicode-escape')
        self.odb_all_elements_key = 'UncheckAllElementsSet'
        self.odb_all_elements_off = ('True' == self.cfg.Read(self.odb_all_elements_key, 'True'))
        self.odb_duplicate_set_instances_key = 'UncheckDuplicateSetInstances'
        self.odb_duplicate_set_instances_off = ('True' == self.cfg.Read(self.odb_duplicate_set_instances_key, 'False'))
        self.odb_fast_load_key = 'ODBFastLoad'
        self.odb_fast_load_on = ('True' == self.cfg.Read(self.odb_fast_load_key, 'False'))
        self.odb_load_zero_frames_key = 'ODBZeroFramesLoad'
        self.odb_load_zero_frames_on = ('True' == self.cfg.Read(self.odb_load_zero_frames_key, 'False'))
        self.odb_load_internal_sets_key = 'ODBLoadInternalSets'
        self.odb_load_internal_sets_on = ('True' == self.cfg.Read(self.odb_load_internal_sets_key, 'False'))
        self.odb_load_instance_parts_key = 'ODBLoadInstanceParts'
        self.odb_load_instance_parts_on = ('True' == self.cfg.Read(self.odb_load_instance_parts_key, 'False'))
        self.abaqus_input_sets_prompt_key = 'AbaqusInputSetsPrompt'
        self.abaqus_input_sets_prompt_on = ('True' == self.cfg.Read(self.abaqus_input_sets_prompt_key, 'False'))
        self.odb_upgrade_wizard_skip_key = 'ODBUpgradeWizardSkip'
        self.odb_upgrade_wizard_skip_on = ('True' == self.cfg.Read(self.odb_upgrade_wizard_skip_key, 'False'))
        self.ansys_input_commands_prompt_key = 'AnsysInputCommandsPrompt'
        self.ansys_input_commands_prompt_on = ('True' == self.cfg.Read(self.ansys_input_commands_prompt_key, 'False'))
        self.marc_experimental_features_key = 'MarcExperimentalFeatures'
        self.marc_experimental_features_on = ('True' == self.cfg.Read(self.marc_experimental_features_key, 'False'))
        self.results_use_instances_key = 'ResultsUseInstances'
        self.results_use_instances_on = ('True' == self.cfg.Read(self.results_use_instances_key, 'False'))
        self.results_instance_title_key = 'ResultsInstanceTitle'
        self.results_instance_title_value = self.cfg.Read(self.results_instance_title_key, self.engine.DefaultResultsInstanceTitle())
        #self.bdf_use_sets_key = 'BdfUseSets'
        #self.bdf_use_sets_on = ('True' == self.cfg.Read(self.bdf_use_sets_key, 'False'))
        self.model_suffix_enabled = True
        self.op2_rigid_rotation_var_enabled = ('1' == os.environ.get('VMOVECAE_OP2_RIGID_ROTATION_NODES', '0'));
        self.op2_enable_rigid_rotation_node_key = 'Op2EnableRigidRotationNode';
        self.op2_enable_rigid_rotation_node_value = ('True' == self.cfg.Read(self.op2_enable_rigid_rotation_node_key, 'False'))
        self.op2_rigid_rotation_node_index_key = 'Op2RigidRotationNodeIndex'
        self.op2_default_rigid_rotation_node_index = 9000001
        self.op2_rigid_rotation_node_index = int(self.cfg.Read(self.op2_rigid_rotation_node_index_key, str(self.op2_default_rigid_rotation_node_index)))
        self.interface_info = self.engine.GetInterfaceInfo()
        self.interface_info_key = 'InterfaceInfo'
        self.interface_grouping_key = 'InterfaceGrouping'
        self.part_grouping_key_prefix = 'PartGrouping_'
        grouping_default = self.interface_info.GetGroupingDefault()
        self.interface_grouping = {}
        for interface in self.interface_info.interfaces:
            grouping_type_unicode = self.cfg.Read(self.part_grouping_key_prefix + interface, grouping_default)
            self.interface_grouping[interface] = grouping_type_unicode.encode('ascii')
        self.nodal_averaged_loads_key = 'NodalAveragedLoads'
        self.nodal_averaged_loads_on = ('True' == self.cfg.Read(self.nodal_averaged_loads_key, 'False'))
        #self.extract_mode_properties_key = 'ExtractModeProperties'
        #self.extract_mode_properties_on = ('True' == self.cfg.Read(self.extract_mode_properties_key, 'False'))
        self.last_activity_time = wx.DateTime.Now()

    def setCmdLineOptions(self, cmd_options, cmd_files, cwd):
        if cwd:
            os.chdir(cwd)

        self.cmd_option_list = cmd_options
        self.cmd_file_list = cmd_files

        nfiles = 0
        if self.cmd_file_list:
            nfiles = len(self.cmd_file_list)

        if nfiles > 1:
            self.LoadModelInternal(os.path.abspath(self.cmd_file_list[1]))
            if self.is_appendable and nfiles > 2:
                self.AppendResultsInternal(
                        os.path.abspath(self.cmd_file_list[2]))
        self.SetTitle(self.frame_title)

    def addMenuBar(self):
        menubar = wx.MenuBar()
        self.SetMenuBar(menubar)

        self.file_menu = wx.Menu()
        self.Id_LoadModelItem = wx.NewIdRef(count=1)
        self.file_menu.Append(self.Id_LoadModelItem, 'Load &Model', 
                                    'Loads a CAE Model')
        self.Id_AppendResultsItem = wx.NewIdRef(count=1)
        self.file_menu.Append(self.Id_AppendResultsItem, 'Append &Results', 
                                    'Append Results from a CAE file')
        self.file_menu.Enable(self.Id_AppendResultsItem, self.is_appendable)
        self.Id_SaveCaxItem = wx.NewIdRef(count=1)
        self.file_menu.Append(self.Id_SaveCaxItem, '&Save CAx', 
                                    'Translates to a CAx file')
        self.file_menu.Enable(self.Id_SaveCaxItem, False)
        self.file_menu.AppendSeparator()
        self.Id_LoadConfigItem = wx.NewIdRef(count=1)
        #self.file_menu.Append(self.Id_LoadConfigItem, '&Load Translation Parameters', 
        #                            'Loads the translation parameters')
        #self.file_menu.Enable(self.Id_LoadConfigItem, False)
        self.Id_SaveConfigItem = wx.NewIdRef(count=1)
        self.file_menu.Append(self.Id_SaveConfigItem, '&Save Translation Parameters', 
                                    'Saves the translation parameters')
        self.file_menu.Enable(self.Id_SaveConfigItem, False)

        self.file_menu.AppendSeparator()
        exit_item = self.file_menu.Append(wx.ID_EXIT, '&Exit', 'E&xit\tCtrl-W')
        menubar.Append(self.file_menu, '&File')

        view_menu = wx.Menu()

        view_toolbars_menu = wx.Menu()
        self.Id_Features = wx.NewIdRef(count=1)
        view_toolbars_menu.AppendCheckItem(self.Id_Features, '&Features')
        view_menu.AppendSubMenu(view_toolbars_menu, '&Toolbars')

        view_windows_menu = wx.Menu()
        self.Id_Instances = wx.NewIdRef(count=1)
        self.Id_DerivedTypes = wx.NewIdRef(count=1)
        view_windows_menu.AppendCheckItem(self.Id_Instances, '&Instances')
        view_menu.AppendSubMenu(view_windows_menu, '&Windows')
        menubar.Append(view_menu, '&View')

        settings_menu = wx.Menu()
        perspectives_menu = wx.Menu()
        self.Id_Basic = wx.NewIdRef(count=1)
        self.Id_Advanced = wx.NewIdRef(count=1)
        perspectives_menu.AppendRadioItem(self.Id_Basic, '&Basic')
        perspectives_menu.AppendRadioItem(self.Id_Advanced, '&Advanced')
        perspectives_menu.Enable(self.Id_Basic, False)
        perspectives_menu.Enable(self.Id_Advanced, False)
        settings_menu.AppendSubMenu(perspectives_menu, '&Perspective')
        self.Id_Preferences = wx.NewIdRef(count=1)
        settings_menu.Append(self.Id_Preferences, '&Preferences')
        menubar.Append(settings_menu, '&Settings')

        help_menu = wx.Menu()
        about_item = help_menu.Append(wx.ID_ABOUT, '&About...')
        help_menu.AppendSeparator()
        self.Id_Help = wx.NewIdRef(count=1)
        help_menu.Append(self.Id_Help, '&Help\tF1')
        menubar.Append(help_menu, '&Help')

        self.Bind(wx.EVT_MENU, self.OnItems)


    def addToolBar(self):
        self.file_toolbar = wx.ToolBar(self, -1, wx.DefaultPosition,
                            wx.DefaultSize, wx.TB_FLAT|wx.TB_NODIVIDER)
        self.file_toolbar.SetToolBitmapSize(wx.Size(24,24))
        self.Id_LoadModelTool = wx.NewIdRef()
        self.file_toolbar.AddTool(self.Id_LoadModelTool, 'Load Model',
                    LoadIcon.GetBitmap(), "Load Model",wx.ITEM_NORMAL)
        self.Id_AppendResultsTool = wx.NewIdRef(count=1)
        self.append_tool = self.file_toolbar.AddTool(
                    self.Id_AppendResultsTool,"Append Results",  
                    AppendIcon.GetBitmap(), 'Append Results', wx.ITEM_NORMAL)
        self.file_toolbar.EnableTool(self.Id_AppendResultsTool, 
                                                self.is_appendable)
        self.Id_SaveCaxTool = wx.NewIdRef()
        self.append_tool = self.file_toolbar.AddTool(self.Id_SaveCaxTool,"Save CAx",  
                    SaveIcon.GetBitmap(), 'Save CAx', wx.ITEM_NORMAL)
        self.file_toolbar.EnableTool(self.Id_SaveCaxTool, False)
        self.file_toolbar.Realize()

        #self.license_toolbar = LicenseToolBar(self)
        #self.license_toolbar.Realize()

        self.features_toolbar = wx.ToolBar(self, -1, wx.DefaultPosition,
                            wx.DefaultSize, wx.TB_FLAT|wx.TB_NODIVIDER)
        self.features_toolbar.SetToolBitmapSize(wx.Size(24,24))

        self.Id_FeatureEdge = wx.NewIdRef(count=1)
        #self.features_toolbar.AddTool(self.Id_FeatureEdge, 
        #            FeatureEdgesIcon.GetBitmap(), 'Add Feature Edges')
        #self.features_toolbar.EnableTool(self.Id_FeatureEdge, False)

        self.Id_Cut = wx.NewIdRef(count=1)
        self.features_toolbar.AddTool(self.Id_Cut,"Add Cut-Section", 
                    CutIcon.GetBitmap(), 'Add Cut-Section')
        self.features_toolbar.EnableTool(self.Id_Cut, False)

        self.Id_Iso = wx.NewIdRef(count=1)
        self.features_toolbar.AddTool(self.Id_Iso,'Add Iso-Surface', 
                    IsoIcon.GetBitmap(), 'Add Iso-Surface')
        self.iso_on = False
        self.features_toolbar.EnableTool(self.Id_Iso, False)

        self.Id_Stream = wx.NewIdRef(count=1)
        self.features_toolbar.AddTool(self.Id_Stream,  'Add Flow Lines',
                    StreamIcon.GetBitmap(), 'Add Flow Lines')
        self.features_toolbar.EnableTool(self.Id_Stream, False)

        self.Id_EGroup = wx.NewIdRef(count=1)
        #self.features_toolbar.AddTool(self.Id_EGroup, 
        #            ElementGroupsIcon.GetBitmap(), 'Add Element Groups')
        #self.features_toolbar.EnableTool(self.Id_EGroup, False)

        self.Id_IsoVolume = wx.NewIdRef(count=1)
        #self.features_toolbar.AddTool(self.Id_IsoVolume, 
        #            IsoVolumeIcon.GetBitmap(), 'Add Iso-Volumes')
        #self.features_toolbar.EnableTool(self.Id_IsoVolume, False)

        self.Id_NewResultTool = wx.NewIdRef(count=1)
        self.features_toolbar.AddTool(self.Id_NewResultTool,'Create Result',
                    CreateResult24Icon.GetBitmap(), 'Create Result')
        self.features_toolbar.EnableTool(self.Id_NewResultTool, False)

        self.Id_AttributesTool = wx.NewIdRef(count=1)
        self.features_toolbar.AddTool(self.Id_AttributesTool,'Set or Add Attributes',
                    AttributesIcon.GetBitmap(), 'Set or Add Attributes')
        self.features_toolbar.EnableTool(self.Id_AttributesTool, False)

        self.Id_LayersTool = wx.NewIdRef(count=1)
        self.features_toolbar.AddTool(self.Id_LayersTool,'Result Properties',
                    LayersIcon.GetBitmap(), 'Result Properties')
        self.features_toolbar.EnableTool(self.Id_LayersTool, False)

        self.features_toolbar.Realize()

        self.tools_toolbar = wx.ToolBar(self, -1, wx.DefaultPosition,
                    wx.DefaultSize, 
                    wx.TB_FLAT|wx.TB_NODIVIDER)
        self.tools_toolbar.SetToolBitmapSize(wx.Size(24,24))
        
        self.Id_ChoiceTypes = wx.NewIdRef(count=1)
        self.choice_types = CustomChoice(self.tools_toolbar, 
                        self.Id_ChoiceTypes, wx.DefaultPosition, 
                        wx.Size(120,30))
        self.tools_toolbar.AddControl(self.choice_types)

        self.Id_ChoiceList = wx.NewIdRef(count=1)
        self.choice_list = CustomChoice(self.tools_toolbar, self.Id_ChoiceList, 
                        wx.DefaultPosition, wx.Size(120, 30))
        self.tools_toolbar.AddControl(self.choice_list)

        self.Id_Select = wx.NewIdRef(count=1)
        self.sel_multiple = self.tools_toolbar.AddTool(self.Id_Select,"Select Multiple", SelectAll.GetBitmap(), 
                'Select Multiple')
        self.sel_multiple.SetToggle(toggle=True)
        
        self.Id_Check = wx.NewIdRef(count=1)
        self.chk_multiple = self.tools_toolbar.AddTool(self.Id_Check,'Check Multiple', CheckAll.GetBitmap(), 
                'Check Multiple')
        self.chk_multiple.SetToggle(toggle=True)
        
        self.Id_Sort = wx.NewIdRef(count=1)
        
        self.tools_toolbar.AddTool(self.Id_Sort,'Sort', NotSorted.GetBitmap(),
                SortDisabled.GetBitmap(),
                shortHelp='Sort')
        
        # self.sort_tlbr.SetToggle(toggle=True)
        #self.tools_toolbar.AddTool(-1, 
        #                MoveUp.GetBitmap(), 'Move Up')
        #self.tools_toolbar.AddTool(-1, 
        #                MoveDown.GetBitmap(), 'Move Down')
        #self.tools_toolbar.AddTool(-1, 
        #                Undo.GetBitmap(), 'Undo')
        #self.tools_toolbar.AddTool(-1, 
        #                Redo.GetBitmap(), 'Redo')
        self.tools_toolbar.Realize()
        self.EnableToolsBar(False)
        self.choice_types.Activate("Types")
        self.choice_list.Activate("Geometry")

        self.manager.AddPane(self.file_toolbar, wx.aui.AuiPaneInfo().
                        Name('File Toolbar').Caption('File Toolbar').
                        CaptionVisible(False).
                        ToolbarPane().Top(). RightDockable(False))
        #self.manager.AddPane(self.license_toolbar, wx.aui.AuiPaneInfo().
        #                Name('License Toolbar').Caption('License Toolbar').
        #                CaptionVisible(False).
        #                ToolbarPane().Top(). RightDockable(False))
        self.manager.AddPane(self.features_toolbar, wx.aui.AuiPaneInfo().
                        Name('Features Toolbar').Caption('Features Toolbar').
                        CaptionVisible(False).
                        ToolbarPane().Top().Position(1).RightDockable(False))
        self.manager.AddPane(self.tools_toolbar, wx.aui.AuiPaneInfo().
                        Name('Tools Toolbar').Caption('Tools Toolbar').
                        CaptionVisible(False).
                        ToolbarPane().Top().Position(2).RightDockable(False))
        self.manager.GetPane('File Toolbar').Show();
        self.manager.GetPane('Tools Toolbar').Show();
        self.manager.GetPane('Features Toolbar').Hide();

        # Enable Features Toolbar
        self.manager.GetPane('Features Toolbar').Show()
        self.GetMenuBar().GetMenu(1).Check(self.Id_Features, True)

        self.Bind(wx.EVT_TOOL, self.OnItems)
        self.Bind(wx.EVT_BUTTON, self.OnItems)
        self.Bind(wx.EVT_CHOICE, self.OnItems)
        self.Bind(wx.EVT_RADIOBUTTON, self.OnItems)

    def addTreeCtrls(self):
        self.addPartTree()
        self.addResultTree()

    def addPartTree(self):
   
        self.part_tree = ct.CustomTreeCtrl(self, -1, wx.DefaultPosition, wx.DefaultSize, style=0,
                         agwStyle=wx.TR_DEFAULT_STYLE |
                         wx.TR_HAS_BUTTONS |
                         ct.TR_MULTIPLE|wx.TR_HIDE_ROOT)
        self.geom_root = None
        self.part_root = None
        self.classifier_nodes = {}
        self.classifier_node_names = []
        self.features_root = None
        self.feature_edges_root = None
        self.cutsec_root = None
        self.isosurf_root = None
        self.isovol_root = None
        self.egroup_root = None
        self.flowlines_root = None
        self.manager.AddPane(self.part_tree, wx.aui.AuiPaneInfo().
                        Name('Part Selection Pane').
                        Caption('Geometry and Features').
                        #CaptionVisible(False).
                        Center().Layer(0).
                        MaximizeButton(True).MinimizeButton(True).
                        CloseButton(False))
        # self.manager.Update()

    def on_treeitem_check(self, event):
    
        tree_item = event.GetItem()
        if tree_item.IsChecked() == wx.CHK_CHECKED:
            self.CheckChilds(tree_item, True)
            self.check_for_other_children_check(tree_item)
        elif tree_item.IsChecked() == wx.CHK_UNDETERMINED:
            self.SetItem3StateValue(
                tree_item, wx.CHK_UNCHECKED)
            self.CheckChilds(tree_item, False)
            self.check_for_other_children_uncheck(tree_item)
        elif tree_item.IsChecked() == wx.CHK_UNCHECKED:
            self.CheckChilds(tree_item, False)
        self.Refresh()
        
    def addResultTree(self):
        self.result_tree = ct.CustomTreeCtrl(self, -1, wx.DefaultPosition, wx.DefaultSize, style=0,
                         agwStyle=wx.TR_DEFAULT_STYLE |
                         wx.TR_HAS_BUTTONS |
                         ct.TR_MULTIPLE)
        # self.resprop_root = self.result_tree.AddRoot('Results and Properties')
        self.res_root = None
        self.prop_root = None
        self.manager.AddPane(self.result_tree, wx.aui.AuiPaneInfo().
                        Name('Result Selection Pane').
                        Caption('Results and Properties').
                        #CaptionVisible(False).
                        Center().Layer(1).
                        MaximizeButton(True).MinimizeButton(True).
                        CloseButton(False))


    def addAdditionalPanels(self):
        self.addInstancesPanel()
        #self.addCutSectionPanel()
        self.use_sliders = False
        if self.use_sliders:
            self.addCutSectionPanelWithSlider()
        else:
            self.addCutSectionPanel()
        self.addFeatureEdgePanel()
        self.addIsoSurfacePanel()
        self.addElementGroupPanel()
        self.addIsoVolumePanel()
        self.addFlowLinePanel()
        self.addAttributesPanel()
        self.addLayersPanel()
        self.manager.Update()

    def addInstancesPanel(self):
      
        self.instance_listbox = tclb.TriCheckListBox(self, id=wx.ID_ANY,
            
                   style=wx.LC_REPORT|wx.LC_NO_HEADER|wx.LC_EDIT_LABELS)
       
        inst_chck = self.instance_listbox.EnableCheckBoxes()
        # self.instance_listbox.Bind(wx.EVT_LIST_ITEM_CHECKED, self.on_instances_check)
            # wx.EVT_CHECKLISTBOX, self.on_instances_check)
        self.manager.AddPane(self.instance_listbox, wx.aui.AuiPaneInfo().
                        Name('Instance List').Caption('Instance List').
                        Bottom().Position(0).
                        MaximizeButton(True).MinimizeButton(True))
        self.manager.GetPane('Instance List').Hide()
        self.manager.Update()

    def addCutSectionPanel(self):
        cutsect_panel = wx.Panel(self, wx.ID_ANY, 
            wx.DefaultPosition, wx.DefaultSize, 
            wx.TAB_TRAVERSAL)

        static_text = wx.StaticText(cutsect_panel, wx.ID_ANY, 
                        'Plane Equation')
        self.cut_textctrl   = wx.TextCtrl(cutsect_panel, wx.ID_ANY, 'X=0')

        self.Id_Cut_Add = wx.NewIdRef(count=1)
        self.Id_Cut_Apply = wx.NewIdRef(count=1)
        add_button = wx.Button(cutsect_panel, self.Id_Cut_Add, "Add")
        self.cut_apply_button = wx.Button(cutsect_panel, self.Id_Cut_Apply, "Apply")
        self.cut_apply_button.Enable(False)

        sizer = wx.GridSizer(4, 4, 10, 5)

        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.Add(static_text, 0, wx.ALL, 5)
        sizer.Add(self.cut_textctrl, 0, wx.ALL, 5)
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.Add(add_button, 0, wx.ALL, 5)
        sizer.Add(self.cut_apply_button, 0, wx.ALL, 5)
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()

        cutsect_panel.SetAutoLayout(True)
        cutsect_panel.SetSizer(sizer)
        sizer.Fit(cutsect_panel)
        sizer.SetSizeHints(cutsect_panel)

        self.manager.AddPane(cutsect_panel, wx.aui.AuiPaneInfo().
                        Name('Cut-Section').Caption('Cut-Section').
                        Bottom().Position(0).
                        MaximizeButton(True).MinimizeButton(True))
        self.manager.GetPane('Cut-Section').Hide()
        self.manager.Update()


    def addCutSectionPanelWithSlider(self):
        cutsect_panel = wx.Panel(self, wx.ID_ANY, 
            wx.DefaultPosition, wx.DefaultSize, 
            wx.TAB_TRAVERSAL)

        static_text = wx.StaticText(cutsect_panel, wx.ID_ANY, 
                        'Plane Equation')
        self.cut_textctrl   = wx.TextCtrl(cutsect_panel, wx.ID_ANY, 'X=0')
        self.cut_slider = wx.Slider(cutsect_panel, wx.ID_ANY, 25, 1, 100, 
                        wx.DefaultPosition, wx.DefaultSize, wx.SL_HORIZONTAL)
        self.cut_slider.Enable(False)

        self.Id_Cut_Add = wx.NewIdRef(count=1)
        self.Id_Cut_Apply = wx.NewIdRef(count=1)
        self.Id_Cut_Compute = wx.NewIdRef(count=1)

        add_button = wx.Button(cutsect_panel, self.Id_Cut_Add, "Add")
        self.cut_apply_button = wx.Button(cutsect_panel, self.Id_Cut_Apply, "Apply")
        self.cut_apply_button.Enable(False)
        self.cut_compute_button = wx.Button(cutsect_panel, self.Id_Cut_Compute, "Compute")

        sizer = wx.GridSizer(4, 5, 10, 5)

        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.Add(static_text, 0, wx.ALL, 5)
        sizer.Add(self.cut_textctrl, 0, wx.ALL, 5)
        sizer.Add(self.cut_slider, 0, wx.ALL, 5)
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.Add(add_button, 0, wx.ALL, 5)
        sizer.Add(self.cut_apply_button, 0, wx.ALL, 5)
        sizer.Add(self.cut_compute_button, 0, wx.ALL, 5)
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()

        cutsect_panel.SetAutoLayout(True)
        cutsect_panel.SetSizer(sizer)
        sizer.Fit(cutsect_panel)
        sizer.SetSizeHints(cutsect_panel)

        self.manager.AddPane(cutsect_panel, wx.aui.AuiPaneInfo().
                        Name('Cut-Section').Caption('Cut-Section').
                        Bottom().Position(0).
                        MaximizeButton(True).MinimizeButton(True))
        self.manager.GetPane('Cut-Section').Hide()
        self.manager.Update()

    def addFeatureEdgePanel(self):
        featureedge_panel = wx.Panel(self, wx.ID_ANY, 
            wx.DefaultPosition, wx.DefaultSize, 
            wx.TAB_TRAVERSAL)

        self.feature_static_text = wx.StaticText(featureedge_panel, wx.ID_ANY, 
                        'Feature Edge Angle = ', 
                        size=wx.Size(200, 30))
        self.feature_textctrl   = wx.TextCtrl(featureedge_panel, wx.ID_ANY, '60')

        self.Id_FeatureEdge_Add = wx.NewIdRef(count=1)
        self.Id_FeatureEdge_Apply = wx.NewIdRef(count=1)
        add_button = wx.Button(featureedge_panel, self.Id_FeatureEdge_Add, "Add")
        self.feature_apply_button = wx.Button(featureedge_panel, self.Id_FeatureEdge_Apply, "Apply")
        self.feature_apply_button.Enable(False)

        #sizer = wx.FlexGridSizer(4, 4, 10, 5)
        sizer = wx.GridSizer(4, 4, 10, 5)

        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.Add(self.feature_static_text, 0, wx.ALL|wx.ALIGN_RIGHT, 5)
        sizer.Add(self.feature_textctrl, 0, wx.ALL|wx.ALIGN_LEFT, 5)
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.Add(add_button, 0, wx.ALL|wx.ALIGN_RIGHT, 5)
        sizer.Add(self.feature_apply_button, 0, wx.ALL|wx.ALIGN_LEFT, 5)
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()

        featureedge_panel.SetAutoLayout(True)
        featureedge_panel.SetSizer(sizer)
        sizer.Fit(featureedge_panel)
        sizer.SetSizeHints(featureedge_panel)

        self.manager.AddPane(featureedge_panel, wx.aui.AuiPaneInfo().
                        Name('Feature Edges').Caption('Feature Edges').
                        Bottom().Position(0).
                        MaximizeButton(True).MinimizeButton(True))
        self.manager.GetPane('Feature Edges').Hide()
        self.manager.Update()

    def addIsoSurfacePanel(self):
        isosurf_panel = wx.Panel(self, wx.ID_ANY, 
            wx.DefaultPosition, wx.DefaultSize, 
            wx.TAB_TRAVERSAL)

        self.iso_static_text = wx.StaticText(isosurf_panel, wx.ID_ANY, 
                        'Displacement - Resultant = ', 
                        size=wx.Size(200, 30))
        self.iso_textctrl   = wx.TextCtrl(isosurf_panel, wx.ID_ANY, '0')

        self.Id_Iso_Add = wx.NewIdRef(count=1)
        self.Id_Iso_Apply = wx.NewIdRef(count=1)
        add_button = wx.Button(isosurf_panel, self.Id_Iso_Add, "Add")
        self.iso_apply_button = wx.Button(isosurf_panel, self.Id_Iso_Apply, "Apply")
        self.iso_apply_button.Enable(False)

        #sizer = wx.FlexGridSizer(4, 4, 10, 5)
        sizer = wx.GridSizer(4, 4, 10, 5)

        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.Add(self.iso_static_text, 0, wx.ALL|wx.ALIGN_RIGHT, 5)
        sizer.Add(self.iso_textctrl, 0, wx.ALL|wx.ALIGN_LEFT, 5)
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.Add(add_button, 0, wx.ALL|wx.ALIGN_RIGHT, 5)
        sizer.Add(self.iso_apply_button, 0, wx.ALL|wx.ALIGN_LEFT, 5)
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()

        isosurf_panel.SetAutoLayout(True)
        isosurf_panel.SetSizer(sizer)
        sizer.Fit(isosurf_panel)
        sizer.SetSizeHints(isosurf_panel)

        self.manager.AddPane(isosurf_panel, wx.aui.AuiPaneInfo().
                        Name('Iso-Surface').Caption('Iso-Surface').
                        Bottom().Position(0).
                        MaximizeButton(True).MinimizeButton(True))
        self.manager.GetPane('Iso-Surface').Hide()
        self.manager.Update()

    def addElementGroupPanel(self):
        egroup_panel = wx.Panel(self, wx.ID_ANY, 
            wx.DefaultPosition, wx.DefaultSize, 
            wx.TAB_TRAVERSAL)

        self.Id_Result_Group = wx.NewIdRef(count=1)
        self.result_group_checkbox = wx.CheckBox(egroup_panel,
                        self.Id_Result_Group, "Group Elements with result")
        self.Id_No_Result_Group = wx.NewIdRef(count=1)
        self.no_result_group_checkbox = wx.CheckBox(egroup_panel, 
                        self.Id_No_Result_Group, 
                        "Group Elements with no result")

        self.result_group_checkbox.SetValue(False)
        self.no_result_group_checkbox.SetValue(False)

        sizer = wx.BoxSizer(wx.VERTICAL)

        sizer.AddStretchSpacer()
        sizer.Add(self.result_group_checkbox, 0, wx.ALL, 5)
        sizer.Add(self.no_result_group_checkbox, 0, wx.ALL, 5)
        sizer.AddStretchSpacer()

        egroup_panel.SetAutoLayout(True)
        egroup_panel.SetSizer(sizer)
        sizer.Fit(egroup_panel)
        sizer.SetSizeHints(egroup_panel)

        self.manager.AddPane(egroup_panel, wx.aui.AuiPaneInfo().
                        Name('Element Grouping').Caption('Element Grouping').
                        Bottom().Position(0).
                        MaximizeButton(True).MinimizeButton(True))
        self.manager.GetPane('Element Grouping').Hide()
        self.manager.Update()

    def addIsoVolumePanel(self):
        isovol_panel = wx.Panel(self, wx.ID_ANY, 
            wx.DefaultPosition, wx.DefaultSize, 
            wx.TAB_TRAVERSAL)

        self.isovol_static_text = wx.StaticText(isovol_panel, wx.ID_ANY, 
                        'Displacement - Resultant = ', 
                        size=wx.Size(200, 30))
        self.isovol_textctrl   = wx.TextCtrl(isovol_panel, wx.ID_ANY, '0,0')

        self.Id_Isovol_Add = wx.NewIdRef(count=1)
        self.Id_Isovol_Apply = wx.NewIdRef(count=1)
        add_button = wx.Button(isovol_panel, self.Id_Isovol_Add, "Add")
        self.isovol_apply_button = wx.Button(isovol_panel, self.Id_Isovol_Apply, "Apply")
        self.isovol_apply_button.Enable(False)

        #sizer = wx.FlexGridSizer(4, 4, 10, 5)
        sizer = wx.GridSizer(4, 4, 10, 5)

        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.Add(self.isovol_static_text, 0, wx.ALL|wx.ALIGN_RIGHT, 5)
        sizer.Add(self.isovol_textctrl, 0, wx.ALL|wx.ALIGN_LEFT, 5)
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.Add(add_button, 0, wx.ALL|wx.ALIGN_RIGHT, 5)
        sizer.Add(self.isovol_apply_button, 0, wx.ALL|wx.ALIGN_LEFT, 5)
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()

        isovol_panel.SetAutoLayout(True)
        isovol_panel.SetSizer(sizer)
        sizer.Fit(isovol_panel)
        sizer.SetSizeHints(isovol_panel)

        self.manager.AddPane(isovol_panel, wx.aui.AuiPaneInfo().
                        Name('Iso-Volume').Caption('Iso-Volume').
                        Bottom().Position(0).
                        MaximizeButton(True).MinimizeButton(True))
        self.manager.GetPane('Iso-Volume').Hide()
        self.manager.Update()

    def addFlowLinePanel(self):
        flowline_panel = wx.Panel(self, wx.ID_ANY, 
            wx.DefaultPosition, wx.DefaultSize, 
            wx.TAB_TRAVERSAL)

        self.Id_StreamRadio = wx.NewIdRef(count=1)
        self.Id_FlowLineRadio = wx.NewIdRef(count=1)
        self.streamline_button = wx.RadioButton(flowline_panel, self.Id_StreamRadio,
                        'Streamline', style=wx.RB_GROUP)
        self.flowline_button = wx.RadioButton(flowline_panel, self.Id_FlowLineRadio,
                        'Particle trace')

        starting_static_text = wx.StaticText(flowline_panel, wx.ID_ANY, 
                        'Starting Points')
        self.starting_textctrl   = wx.TextCtrl(flowline_panel, wx.ID_ANY, 
                        '(0.0011, 0.1895, 0.1027)')
        starting_numlines_text = wx.StaticText(flowline_panel, wx.ID_ANY, 
                        'Number of Lines')
        self.starting_numlines   = wx.TextCtrl(flowline_panel, wx.ID_ANY, 
                        '0')
        self.timestep_static_text = wx.StaticText(flowline_panel, wx.ID_ANY, 
                        'Time Step')
        self.timestep_textctrl   = wx.TextCtrl(flowline_panel, wx.ID_ANY, 
                        '0.001')
        self.steps_static_text = wx.StaticText(flowline_panel, wx.ID_ANY, 
                        'Number of Steps')
        self.steps_textctrl   = wx.TextCtrl(flowline_panel, wx.ID_ANY, 
                        '50')
        self.injection_static_text = wx.StaticText(flowline_panel, wx.ID_ANY, 
                        'Injection Frequency')
        self.injection_textctrl   = wx.TextCtrl(flowline_panel, wx.ID_ANY, 
                        '10')

        self.Id_FlowLine_Add = wx.NewIdRef(count=1)
        self.Id_FlowLine_Apply = wx.NewIdRef(count=1)
        add_button = wx.Button(flowline_panel, self.Id_FlowLine_Add, "Add")
        self.flowline_apply_button = wx.Button(
                        flowline_panel, self.Id_FlowLine_Apply, "Apply")
        self.flowline_apply_button.Enable(False)

        sizer = wx.GridSizer(9, 4, 10, 5)

        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.Add(self.streamline_button, 0, wx.ALL, 5)
        sizer.Add(self.flowline_button, 0, wx.ALL, 5)
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.Add(starting_static_text, 0, wx.ALL, 5)
        sizer.Add(self.starting_textctrl, 0, wx.ALL, 5)
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.Add(starting_numlines_text, 0, wx.ALL, 5)
        sizer.Add(self.starting_numlines, 0, wx.ALL, 5)
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.Add(self.timestep_static_text, 0, wx.ALL, 5)
        sizer.Add(self.timestep_textctrl, 0, wx.ALL, 5)
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.Add(self.steps_static_text, 0, wx.ALL, 5)
        sizer.Add(self.steps_textctrl, 0, wx.ALL, 5)
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.Add(self.injection_static_text, 0, wx.ALL, 5)
        sizer.Add(self.injection_textctrl, 0, wx.ALL, 5)
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.Add(add_button, 0, wx.ALL, 5)
        sizer.Add(self.flowline_apply_button, 0, wx.ALL, 5)
        sizer.AddStretchSpacer()

        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()
        sizer.AddStretchSpacer()

        flowline_panel.SetAutoLayout(True)
        flowline_panel.SetSizer(sizer)
        sizer.Fit(flowline_panel)
        sizer.SetSizeHints(flowline_panel)

        self.FlowLinesRadio(False)

        self.manager.AddPane(flowline_panel, wx.aui.AuiPaneInfo().
                        Name('Flow Lines').Caption('Flow Lines').
                        Bottom().Position(0).
                        MaximizeButton(True).MinimizeButton(True))
        self.manager.GetPane('Flow Lines').Hide()
        self.manager.Update()


    def addAttributesPanel(self):
        attributes_panel = wx.Panel(self, wx.ID_ANY, 
            wx.DefaultPosition, wx.DefaultSize, 
            wx.TAB_TRAVERSAL)

        self.attributes_dict = {}
        self.attributes_listbox = wx.ListBox(attributes_panel, id=wx.ID_ANY, 
                        style=wx.LB_SINGLE|wx.LB_SORT)
        self.attributes_listbox.Bind(wx.EVT_LISTBOX, self.SelectAttribute)

        name_text = wx.StaticText(attributes_panel, wx.ID_ANY, 'Name')
        self.attr_name_textctrl = wx.TextCtrl(attributes_panel, wx.ID_ANY, 
                        size = wx.Size(160, -1))
        value_text = wx.StaticText(attributes_panel, wx.ID_ANY, 'Value')
        self.attr_value_textctrl = wx.TextCtrl(attributes_panel, wx.ID_ANY, 
                        size = wx.Size(160, -1))

        self.Id_Attr_Add = wx.NewIdRef(count=1)
        attr_add_button = wx.Button(attributes_panel, self.Id_Attr_Add, "Add")
        self.Id_Attr_Apply = wx.NewIdRef(count=1)
        self.attr_apply_button = wx.Button(attributes_panel, 
                        self.Id_Attr_Apply, "Apply")
        self.attr_apply_button.Enable(False)
        self.Id_Attr_Delete = wx.NewIdRef(count=1)
        self.attr_delete_button = wx.Button(attributes_panel, 
                        self.Id_Attr_Delete, "Delete")
        self.attr_delete_button.Enable(False)

        prop_fields_sizer = wx.FlexGridSizer(2, 2, 10, 5)
        prop_fields_sizer.Add(name_text, 0, wx.ALL, 5)
        prop_fields_sizer.Add(self.attr_name_textctrl, 0, wx.EXPAND|wx.ALL, 5)
        prop_fields_sizer.Add(value_text, 0, wx.ALL, 5)
        prop_fields_sizer.Add(self.attr_value_textctrl, 0, wx.EXPAND|wx.ALL, 5)

        prop_buttons_sizer = wx.BoxSizer(wx.VERTICAL)
        prop_buttons_sizer.Add(attr_add_button, 0, wx.EXPAND|wx.ALL)#, 5)
        prop_buttons_sizer.Add(self.attr_delete_button, 0,wx.EXPAND|wx.ALL)#, 5)
        prop_buttons_sizer.Add(self.attr_apply_button, 0, wx.EXPAND|wx.ALL)#, 5)

        prop_sizer = wx.BoxSizer(wx.HORIZONTAL)
        prop_sizer.Add(prop_fields_sizer, 0,wx.EXPAND|wx.ALL, 5)
        prop_sizer.Add(prop_buttons_sizer, 0, wx.EXPAND|wx.ALL, 5)

        lbox = wx.StaticBox(attributes_panel, -1, "Added Attributes")
        lbox_sizer = wx.StaticBoxSizer(lbox, wx.VERTICAL)
        lbox_sizer.Add(self.attributes_listbox, 1, wx.EXPAND|wx.ALL, 5)
        pbox = wx.StaticBox(attributes_panel, -1, "Attribute Properties")
        pbox_sizer = wx.StaticBoxSizer(pbox, wx.VERTICAL)
        pbox_sizer.Add(prop_sizer, 1, wx.EXPAND|wx.ALL)#, 5)

        sizer = wx.BoxSizer(wx.HORIZONTAL)
        sizer.AddSpacer(40)
        sizer.Add(pbox_sizer, 1, wx.EXPAND|wx.ALIGN_RIGHT|wx.ALL, 5)
        sizer.AddSpacer(60)
        sizer.Add(lbox_sizer, 0, wx.EXPAND|wx.ALIGN_LEFT|wx.ALL, 5)
        sizer.AddSpacer(40)

        attributes_panel.SetAutoLayout(True)
        attributes_panel.SetSizer(sizer)
        sizer.Fit(attributes_panel)
        sizer.SetSizeHints(attributes_panel)

        self.manager.AddPane(attributes_panel, wx.aui.AuiPaneInfo().
                        Name('Attributes').Caption('Attributes').
                        Bottom().Position(0).
                        MaximizeButton(True).MinimizeButton(True))
        self.manager.GetPane('Attributes').Hide()
        self.manager.Update()

    def addLayersPanel(self):
        layers_panel = wx.Panel(self, wx.ID_ANY, 
            wx.DefaultPosition, wx.DefaultSize, 
            wx.TAB_TRAVERSAL)

        self.layer_objects = [ 
                        {'label':'Top Section', 'value': 1, 'checkbox': None },
                        {'label':'Bottom Section', 'value': 2, 'checkbox': None },
                        {'label':'Mid Section', 'value': 4, 'checkbox': None },
                        {'label':'Maximum', 'value': 8, 'checkbox': None },
                        {'label':'Average', 'value': 16, 'checkbox': None },
                        {'label':'Minimum', 'value': 32, 'checkbox': None } ]

        for item in self.layer_objects:
            item['checkbox'] = wx.CheckBox(layers_panel, -1, item['label'])

        self.Id_Layers_Apply = wx.NewIdRef(count=1)
        self.layers_apply_button = wx.Button(layers_panel, 
                        self.Id_Layers_Apply, "Apply")

        cb_sizer = wx.GridSizer(2, 3, 5, 5)
        for item in self.layer_objects:
            cb_sizer.Add(item['checkbox'], 1, wx.EXPAND|wx.ALL, 5)

        lay_box = wx.StaticBox(layers_panel, -1, "Sections and Layers")
        lay_sizer = wx.StaticBoxSizer(lay_box, wx.VERTICAL)
        lay_sizer.Add(cb_sizer, 1, wx.EXPAND|wx.ALL, 5);

        type_options = ['Default', 'Nodal', 'Elemental'];
        self.type_rb = wx.RadioBox(layers_panel, -1, "Result type", 
                wx.DefaultPosition, wx.DefaultSize, type_options, 
                3, wx.RA_SPECIFY_ROWS)
        self.type_rb.SetMinSize(wx.Size(150, 80))

        sizer = wx.BoxSizer(wx.HORIZONTAL)
        sizer.Add(self.type_rb, 0, wx.EXPAND|wx.ALL, 5)
        sizer.Add(lay_sizer, 1, wx.EXPAND|wx.ALL, 5)
        sizer.Add(self.layers_apply_button, 0, wx.EXPAND|wx.ALL, 5)

        layers_panel.SetAutoLayout(True)
        layers_panel.SetSizer(sizer)
        sizer.Fit(layers_panel)
        sizer.SetSizeHints(layers_panel)

        self.manager.AddPane(layers_panel, wx.aui.AuiPaneInfo().
                        Name('Layers').Caption('Result Properties').
                        Bottom().Position(0).
                        MaximizeButton(True).MinimizeButton(True))
        self.manager.GetPane('Layers').Hide()
        self.manager.Update()

    def SelectAttribute(self, evt):
        if not evt.IsSelection():
            return

        key = evt.GetString()
        value = self.attributes_dict[key]

        self.attr_name_textctrl.SetValue(key)
        self.attr_value_textctrl.SetValue(value)
        self.attr_apply_button.Enable(True)

    def createUpgradeOdbWizard(self):
        self.Id_Wizard = wx.NewIdRef(count=1)
        self.wizard = wiz.Wizard(self, self.Id_Wizard, 'Upgrade ODB file',
                    WizardIcon.GetBitmap())
        self.wizard_page = wiz.WizardPageSimple(self.wizard)
        self.wizard_text = wx.StaticText(self.wizard_page, wx.NewIdRef(count=1), 
                            '', wx.Point(5, 5))

        self.Id_Wizard_TextCtrl = wx.NewIdRef(count=1)
        self.wizard_textctrl = wx.TextCtrl(self.wizard_page, 
                        self.Id_Wizard_TextCtrl, '')
        self.wizard_textctrl.SetMinSize(wx.Size(280, 30))

        self.Id_Wizard_Button = wx.NewIdRef(count=1)
        self.wizard_button = wx.Button(self.wizard_page, 
                        self.Id_Wizard_Button, 'Browse ...')
        self.wizard_button.SetMinSize(wx.Size(80, 30))

        file_sizer = wx.BoxSizer(wx.HORIZONTAL)
        file_sizer.Add(self.wizard_textctrl)
        file_sizer.AddSpacer(20)
        file_sizer.Add(self.wizard_button)
    
        main_sizer = wx.BoxSizer(wx.VERTICAL)
        main_sizer.Add(self.wizard_text, 0, wx.EXPAND|wx.ALL, 5)
        main_sizer.Add(file_sizer, 0, wx.EXPAND|wx.ALL, 5)

        self.wizard_page.SetSizer(main_sizer)
        main_sizer.Fit(self.wizard_page)
        self.wizard.FitToPage(self.wizard_page)
        self.wizard.GetPageAreaSizer().Add(self.wizard_page)

        self.wizard_button.Bind(wx.EVT_BUTTON, self.OnWizardBrowse)

    def EnableToolsBar(self, type):
        if type:
            self.tools_toolbar.EnableTool(self.Id_ChoiceTypes, True)
            self.tools_toolbar.EnableTool(self.Id_Select, True)
            self.tools_toolbar.EnableTool(self.Id_Check, True)
            self.tools_toolbar.EnableTool(self.Id_ChoiceList, True)
            self.EnableSortTool(True)
        else:
            self.tools_toolbar.EnableTool(self.Id_ChoiceTypes, False)
            self.tools_toolbar.EnableTool(self.Id_Select, False)
            self.tools_toolbar.EnableTool(self.Id_Check, False)
            self.tools_toolbar.EnableTool(self.Id_ChoiceList, False)
            self.EnableSortTool(False)

    def EnableSortTool(self, onoff):
        if onoff:
            sstate = SORT_STATE_NOT_APPLIED
        else:
            sstate = SORT_STATE_DISABLED
        self.sort_states[GEOM_TREE] = sstate
        self.sort_states[RESULT_TREE] = sstate
        #self.sort_states[INSTANCE_LIST] = SORT_STATE_DISABLED
        self.UpdateSortTool()

    def UpdateSortTool(self):
        ctype = self.choice_types.GetChoice()
        sstate = self.sort_states.get(ctype, SORT_STATE_DISABLED)
        if sstate == SORT_STATE_DISABLED:
            self.tools_toolbar.SetToolNormalBitmap(self.Id_Sort,
                    NotSorted.GetBitmap())
            #self.tools_toolbar.SetToolDisabledBitmap(self.Id_Sort,
            #        SortDisabled.GetBitmap())
            self.tools_toolbar.EnableTool(self.Id_Sort, False)
        elif sstate == SORT_STATE_NOT_APPLIED:
            self.tools_toolbar.SetToolNormalBitmap(self.Id_Sort,
                    NotSorted.GetBitmap())
            self.tools_toolbar.EnableTool(self.Id_Sort, True)
        elif sstate == SORT_STATE_ASCENDING:
            self.tools_toolbar.SetToolNormalBitmap(self.Id_Sort,
                    SortedAsc.GetBitmap())
            self.tools_toolbar.EnableTool(self.Id_Sort, True)
        elif sstate == SORT_STATE_DESCENDING:
            self.tools_toolbar.SetToolNormalBitmap(self.Id_Sort,
                    SortedDesc.GetBitmap())
            self.tools_toolbar.EnableTool(self.Id_Sort, True)

    def OnClose(self, event):
        self.engine.DestroyDataManager()
        if self.engine:
            self.engine.ReleaseLicense()
        if self.tmpdir:
            self.tmpdir.destroy()

        #dial = wx.MessageDialog(None, 'Are you sure to quit?', 'Question',
        #    wx.YES_NO | wx.NO_DEFAULT | wx.ICON_QUESTION)
        #ret = dial.ShowModal()
        #if ret == wx.ID_YES:
        #    self.Destroy()
        #else:
        #    event.Veto()
        
        #(w, h) = self.GetSizeTuple()
        #self.cfg.WriteInt("width", w)
        #self.cfg.WriteInt("height", h)
        self.cfg.Write('cwd', os.getcwd())
        self.manager.UnInit()
        event.Skip()

    def OnSize(self, evt):
       self.SetSize([-1, -1])
       evt.Skip()

    def OnItems(self, event):
        id = event.GetId()
        diff = 8
        if wx.ID_EXIT == id:
            if self.engine:
                self.engine.DestroyDataManager()
                self.engine.ReleaseLicense()
            if self.tmpdir:
                self.tmpdir.destroy()
            if self.cfg:
                self.cfg.Write('cwd', os.getcwd())
            self.Close(True)
        elif wx.ID_ABOUT == id:
            # First we create and fill the info object
            info = wx.adv.AboutDialogInfo()
            info.SetName(APP_NAME_VER)
            arch=Common.GetArchitecture()
            #info.Version = "2.1.223.331 (Beta)"
            #info.Version = "2.1.223.331"
            #if arch in ['win64', 'linux64']:
                #info.Version = "2.1.223.331 (64-bit, Beta)"
                #info.Version = "2.1.223.331 (64-bit)"
            info.SetCopyright("(C) 2008-23 Visual Collaboration Technologies Inc.")
            ceid_str = self.engine.GetCeid()
            descr_lines = ("\nBuild # " 
                #"2.1.223.331 (64-bit, Beta)"
                "2.1.223.331 (64-bit)"
            )
            if ceid_str:
                descr_lines += "\nMSC Customer Entitlement ID : " + ceid_str
            descr_lines += (
                "\n"
                "\nVMove CAE is a direct reader of CAE output results."
                "It converts the native CAE results into highly compressed "
                "VCollab CAx files based on user inputs for easy sharing and "
                "viewing of Simulation Results.\n")
            info.SetDescription(wordwrap(descr_lines,
                350, wx.ClientDC(self)))
            info.SetWebSite("http://www.vcollab.com/", 
                            "Visual Collaboration Technologies")
            #licenseText = "Type: Float \n Expiration: never"
            #info.License = wordwrap(licenseText, 500, wx.ClientDC(self))
            warningText = (
                    "This computer program is protected by copyright law"
                    " and international treties.  Unauthorized reproduction or"
                    " distribution of this program, or any portion of it"
                    " will be prosecuted.")
    
            # Then we call wx.AboutBox giving it that info object
            wx.adv.AboutBox(info)
        elif self.Id_Help == id:
            if self.help_file:
                if os.path.exists(self.help_file) and self.arch in ['win32', 'win64']:
                    os.startfile(self.help_file)
                else:
                    webbrowser.open(self.help_file)
            else:
                help_link = 'http://training.vcollab.com/etraining.html?page=VMoveCAE_CS.html'
                webbrowser.open(help_link)
        elif self.Id_Basic == id:
            self.manager.GetPane('Features Toolbar').Hide()
            self.manager.GetPane('Cut-Section').Hide()
            self.manager.GetPane('Iso-Surface').Hide()
            self.manager.GetPane('Iso-Volume').Hide()
            self.GetMenuBar().GetMenu(1).Check(self.Id_Features, False)
        elif self.Id_Advanced == id:
            self.manager.GetPane('Features Toolbar').Show()
            self.GetMenuBar().GetMenu(1).Check(self.Id_Features, True)
        elif self.Id_Instances == id:
            if event.IsChecked():
                self.manager.GetPane('Instance List').Show()
            else:
                self.manager.GetPane('Instance List').Hide()
        elif self.Id_Features == id:
            if event.IsChecked():
                self.manager.GetPane('Features Toolbar').Show()
            else:
                self.manager.GetPane('Features Toolbar').Hide()
        elif self.Id_FeatureEdge == id:
            self.manager.GetPane('Feature Edges').Show()
        elif self.Id_AttributesTool == id:
            self.attr_apply_button.Enable(False)
            self.manager.GetPane('Attributes').Show()
        elif self.Id_Cut == id:
            selections = self.part_tree.GetSelections()
            self.cut_apply_button.Enable(False)
            if 1 == len(selections):
                for item in selections:
                    p_item = item.GetParent()
                    if p_item == self.cutsec_root:
                        self.cut_apply_button.Enable(True)

            self.manager.GetPane('Cut-Section').Show()
            self.manager.GetPane('Iso-Surface').Hide()
            self.manager.GetPane('Instance List').Hide()
            self.manager.GetPane('Element Grouping').Hide()
        elif self.Id_Iso == id:
            selections = self.result_tree.GetSelections()
            if 1 == len(selections):
                for item in selections:
                    label = item.GetText()
                    parent = item.GetParent()
                    parent_label = parent.GetText()
                    if parent == self.res_root:
                        self.iso_static_text.SetLabel(label + ' = ')
                    else:
                        self.iso_static_text.SetLabel(parent_label +
                                        ' - ' + label + ' = ')
            #selections = self.result_tree.GetSelections()
            #if 1 == len(selections):
            #    self.cut_apply_button.Enable(True)
            #else:
            #    self.cut_apply_button.Enable(False)

            self.manager.GetPane('Cut-Section').Hide()
            if not self.manager.GetPane('Cut-Section').IsShown():
                self.manager.GetPane('Iso-Surface').Show()
            self.manager.GetPane('Instance List').Hide()
            self.manager.GetPane('Element Grouping').Hide()
        elif self.Id_IsoVolume == id:
            selections = self.result_tree.GetSelections()
            if 1 == len(selections):
                for item in selections:
                    label = item.GetText()
                    parent = item.GetParent()
                    parent_label = parent.GetText()
                    if parent == self.res_root:
                        self.isovol_static_text.SetLabel(label + ' = ')
                    else:
                        self.isovol_static_text.SetLabel(parent_label +
                                        ' - ' + label + ' = ')
            #selections = self.result_tree.GetSelections()
            #if 1 == len(selections):
            #    self.cut_apply_button.Enable(True)
            #else:
            #    self.cut_apply_button.Enable(False)

            self.manager.GetPane('Iso-Volume').Hide()
            if not self.manager.GetPane('Iso-Volume').IsShown():
                self.manager.GetPane('Iso-Volume').Show()
            self.manager.GetPane('Cut-Section').Hide()
            self.manager.GetPane('Iso-Surface').Hide()
            self.manager.GetPane('Instance List').Hide()
            self.manager.GetPane('Element Grouping').Hide()
        elif self.Id_EGroup == id:
            self.manager.GetPane('Cut-Section').Hide()
            self.manager.GetPane('Iso-Surface').Hide()
            self.manager.GetPane('Instance List').Show()
            self.manager.GetPane('Element Grouping').Show()
        elif self.Id_Stream == id:
            self.manager.GetPane('Flow Lines').Show()
        elif self.Id_NewResultTool == id:
            selections = self.result_tree.GetSelections()
            for item in selections:
                label = item.GetText()
                parent = item.GetParent()
                parent_label = parent.GetText()
                result_displayname = parent_label + " - " + label
                new_item = self.result_tree.AppendItem(self.res_root, 
                        result_displayname, 1)
                self.result_tree.SetItem3State(new_item, True)
                self.result_tree.SetItem3StateValue(new_item, wx.CHK_CHECKED)
                # self.result_tree.SetItem3State(parent, False)
                # self.result_tree.SetItem3StateValue(parent, wx.CHK_UNCHECKED)
                self.result_tree.SetItem3StateValue(
                parent, wx.CHK_UNCHECKED)
                self.result_tree.CheckChilds(parent, False)
                # self.result_tree.CheckChilds(tree_item, False)
                self.result_tree_check_for_other_children_uncheck(parent)
                # self.result_tree.CheckItem(new_item, True)
                # self.result_tree.CheckItem(parent, False)
                parent_data = parent.GetData()
                res_trans_prop = parent_data[4]
                new_item_data = item.GetData()
                new_item_data[4] = res_trans_prop
                new_item.SetData(new_item_data)
        elif self.Id_ChoiceTypes == id:
            self.choice_list.Activate(self.choice_types.GetChoice())
            self.UpdateSortTool()
        elif self.Id_ChoiceList == id:
            self.choice_list.OptionChanged()
        elif self.Id_Select == id:
            if self.tools_toolbar.GetToolState(self.Id_Select):
                self.UpdateSelCheck(self.choice_types.GetChoice(),
                            'Select',
                            self.choice_list.GetChoice())
            else:
                self.UpdateSelCheck(self.choice_types.GetChoice(),
                            'Deselect',
                            self.choice_list.GetChoice())
        elif self.Id_Check == id:
            if self.tools_toolbar.GetToolState(self.Id_Check):
                self.UpdateSelCheck(self.choice_types.GetChoice(),
                            'Check',
                            self.choice_list.GetChoice())
            else:
                self.UpdateSelCheck(self.choice_types.GetChoice(),
                            'Uncheck',
                            self.choice_list.GetChoice())
        elif self.Id_Sort == id:
            self.UpdateSortState()
        elif id in [self.Id_LoadModelTool, self.Id_LoadModelItem]:
            self.LoadModel()
            self.SetTitle(self.frame_title)
        elif id in [self.Id_AppendResultsTool, self.Id_AppendResultsItem]:
            self.AppendResults()
        elif id in [self.Id_SaveCaxTool, self.Id_SaveCaxItem]:
            self.SaveCaxNew()
        elif self.Id_SaveConfigItem == id:
            self.SaveConfiguration()
        #if self.Id_Select == id:
        #    active_window = self.choice_list.GetActive()
        #    what = " Choice " + self.choice_list.GetChoice()
        #    if 'Geometry' == active_window:
        #        self.statusbar.SetStatusText('Selecting Geometry' + what)
        #    if 'Results' == active_window:
        #        self.statusbar.SetStatusText('Selecting Results' + what)
        #    if 'Instances' == active_window:
        #        self.statusbar.SetStatusText('Selecting Instances' + what)
        #if self.Id_Check == id:
        #    active_window = self.choice_list.GetActive()
        #    what = " Choice " + self.choice_list.GetChoice()
        #    if 'Geometry' == active_window:
        #        self.statusbar.SetStatusText('Checking Geometry' + what)
        #    if 'Results' == active_window:
        #        self.statusbar.SetStatusText('Checking Results' + what)
        #    if 'Instances' == active_window:
        #        self.statusbar.SetStatusText('Checking Instances' + what)
        elif self.Id_FeatureEdge_Add == id:
            self.AddFeatureEdges()
        #elif self.Id_Cut_Compute == id:
        #    self.
        elif self.Id_Cut_Add == id:
            not_found = True
            axis_name, cutsec_list = self.ProcessCutSectionInput(self.cut_textctrl.GetValue())
            for cutsec_val in cutsec_list:
                cutsec_name = axis_name + ' = ' + str(cutsec_val)
                if self.cutsec_root:
                    (nextchild, cookie) = self.part_tree.GetFirstChild(
                                self.cutsec_root)
                    while not_found and nextchild:
                        if nextchild.GetText() == cutsec_name:
                            not_found = False
                        (nextchild, cookie) = self.part_tree.GetNextChild(
                                self.cutsec_root, cookie)
                if not_found:
                    self.AddCutSection(cutsec_name)
                else:
                    wx.MessageBox('Cut-Section already exists.', 'Information!')
        elif self.Id_Cut_Apply == id:
            not_found = True
            cutsec_name = self.cut_textctrl.GetValue()
            if self.cutsec_root:
                (nextchild, cookie) = self.part_tree.GetFirstChild(
                            self.cutsec_root)
                while not_found and nextchild:
                    if nextchild.GetText() == cutsec_name:
                        not_found = False
                    (nextchild, cookie) = self.part_tree.GetNextChild(
                                self.cutsec_root, cookie)
            if not_found:
                for item in self.part_tree.GetSelections():
                    item.SetText(cutsec_name)
                    item.SetData([-1, cutsec_name])
                    self.part_tree.Refresh()
            else:
                wx.MessageBox('Cut-Section already exists.', 'Information!')
        elif self.Id_Iso_Add == id:
            not_found = True
            res_data = None
            isosurf_name = self.iso_static_text.GetLabel() + self.iso_textctrl.GetValue()
            if self.isosurf_root:
                (nextchild, cookie) = self.part_tree.GetFirstChild(
                            self.isosurf_root)
                while not_found and nextchild:
                    if nextchild.GetText() == isosurf_name:
                        not_found = False
                    (nextchild, cookie) = self.part_tree.GetNextChild(
                                self.isosurf_root, cookie)
            if not_found:
                self.AddIsoSurface(isosurf_name)
            else:
                wx.MessageBox('Iso-Surface already exists.', 'Information!')
        elif self.Id_Iso_Apply == id:
            not_found = True
            isosurf_name = self.iso_static_text.GetLabel() + self.iso_textctrl.GetValue()
            if self.isosurf_root:
                (nextchild, cookie) = self.part_tree.GetFirstChild(
                            self.isosurf_root)
                while not_found and nextchild:
                    if nextchild.GetText() == isosurf_name:
                        not_found = False
                    (nextchild, cookie) = self.part_tree.GetNextChild(
                                self.isosurf_root, cookie)
            if not_found:
                for item in self.part_tree.GetSelections():
                    item.SetText(isosurf_name)
                    self.SetIsoProp(item)
                self.part_tree.Refresh()
            else:
                wx.MessageBox('Iso-Surface already exists.', 'Information!')
        elif self.Id_Isovol_Add == id:
            not_found = True
            res_data = None
            isovol_name = self.isovol_static_text.GetLabel() + '(' + self.isovol_textctrl.GetValue() + ')'
            if self.isovol_root:
                (nextchild, cookie) = self.part_tree.GetFirstChild(
                            self.isovol_root)
                while not_found and nextchild:
                    if nextchild.GetText() == isovol_name:
                        not_found = False
                    (nextchild, cookie) = self.part_tree.GetNextChild(
                                self.isovol_root, cookie)
            if not_found:
                self.AddIsoVolume(isovol_name)
            else:
                wx.MessageBox('Iso-Volume already exists.', 'Information!')
        elif self.Id_Isovol_Apply == id:
            not_found = True
            isovol_name = self.isovol_static_text.GetLabel() + '(' + self.isovol_textctrl.GetValue() + ')'
            if self.isovol_root:
                (nextchild, cookie) = self.part_tree.GetFirstChild(
                            self.isovol_root)
                while not_found and nextchild:
                    if nextchild.GetText() == isovol_name:
                        not_found = False
                    (nextchild, cookie) = self.part_tree.GetNextChild(
                                self.isovol_root, cookie)
            if not_found:
                for item in self.part_tree.GetSelections():
                    item.SetText(isovol_name)
                    self.SetIsoVolProp(item)
                self.part_tree.Refresh()
            else:
                wx.MessageBox('Iso-Volume already exists.', 'Information!')
        elif self.Id_FlowLine_Add == id:
            self.AddFlowLines()
        elif self.Id_FlowLine_Apply == id:
            self.ApplyFlowLines()
        elif self.Id_Attr_Add == id:
            self.AddAttribute()
        elif self.Id_Attr_Delete == id:
            self.DeleteAttribute()
        elif self.Id_Attr_Apply == id:
            self.AlterAttribute()
        elif self.Id_Preferences == id:
            self.OpenPreferencesDialog()
        elif self.Id_Result_Group == id:
            self.AddResultGroup(event)
        elif self.Id_No_Result_Group == id:
            self.AddNoResultGroup(event)
        elif self.Id_StreamRadio == id:
            self.FlowLinesRadio(False)
        elif self.Id_FlowLineRadio == id:
            self.FlowLinesRadio(True)
        elif self.Id_LayersTool == id:
            selections = self.result_tree.GetSelections()
            if 1 == len(selections):
                for item in selections:
                    data = item.GetData()
                    parent = item.GetParent()
                    res_trans_prop = data[4]
                    if parent == self.res_root and None != res_trans_prop:
                        self.SetResultProperties(res_trans_prop)
                    self.manager.GetPane('Instance List').Hide()
                    self.manager.GetPane('Layers').Show()
        elif self.Id_Layers_Apply == id:
            selections = self.result_tree.GetSelections()
            if 1 == len(selections):
                for item in selections:
                    data = item.GetData()
                    parent = item.GetParent()
                    res_trans_prop = data[4]
                    if parent == self.res_root:
                        res_trans_prop[0] = self.type_rb.GetSelection()
                        if res_trans_prop[1]:
                            res_trans_prop[2] = self.GetLayerSelection()
                        else:
                            res_trans_prop[2] = 0

        self.manager.Update()

    def LoadModel(self):
        # Create the dialog. In this case the current directory is forced as 
        # the starting directory for the dialog, and no default file name 
        # is forced. This can easilly be changed in your program. This is an 
        # 'open' dialog, and allows multitple file selections as well.
        #
        # Finally, if the directory is changed in the process of getting 
        # files, this dialog is set up to change the current working 
        # directory to the path chosen.
        wildcard = self.engine.GetWildCards(self.engine.MODEL_FILE)
        wildcard = wildcard.replace(wildcard.split('|')[0], 
                                            'All Supported Files', 1)
        #print wildcard
        femunzip_path = Extractor.get_femzip_dyna_path()
        if femunzip_path:
            all_sup_wc = wildcard.split('|')[1]
            all_sup_wc_new = all_sup_wc + ";*.fz;Zd3plot*"
            wildcard = wildcard.replace(all_sup_wc, all_sup_wc_new, 1)
        #print wildcard
        dlg = wx.FileDialog(self, message='Select CAE Model file',
            defaultDir=os.getcwd(), 
            defaultFile='',
            wildcard=wildcard,
            #style=wx.OPEN | wx.MULTIPLE | wx.CHANGE_DIR)
            style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST | wx.FD_CHANGE_DIR)

        # Show the dialog and retrieve the user response. If it is the 
        # OK response, process the data.
        if dlg.ShowModal() == wx.ID_OK:
            model_file_path = dlg.GetPath()
            ds_dat_file_path = None
            sets_inp_file_path = None
            (fname, fext) = os.path.splitext(model_file_path)
            if (fext == '.rst' or fext == '.rth') and self.ansys_input_commands_prompt_on:
                ds_dat_query_dlg = wx.MessageDialog(self, 'Do you want to load Ansys input commands file', 'Yes or No', wx.YES_NO | wx.ICON_QUESTION)
                load_ds_dat = ds_dat_query_dlg.ShowModal() == wx.ID_YES
                ds_dat_query_dlg.Destroy()

                if load_ds_dat:
                    ds_dat_wild_cards = "All Supported Files (*.dat)|*.dat|"
                    ds_dat_wild_cards += "DAT files (*.dat)|*.dat|"
                    ds_dat_wild_cards += "All Files (*.*)|*.*||"

                    ds_dat_dlg = wx.FileDialog(self, 
                            message='Select Ansys input commands file',
                            defaultDir=os.getcwd(), 
                            defaultFile='',
                            wildcard=ds_dat_wild_cards,
                            #style=wx.OPEN | wx.MULTIPLE | wx.CHANGE_DIR)
                            style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST | wx.FD_CHANGE_DIR)
                    if ds_dat_dlg.ShowModal() == wx.ID_OK:
                        ds_dat_file_path = ds_dat_dlg.GetPath()
                    ds_dat_dlg.Destroy()
            elif (fext == '.odb') and self.abaqus_input_sets_prompt_on:
                sets_inp_query_dlg = wx.MessageDialog(self, 'Do you want to load Abaqus input file', 'Yes or No', wx.YES_NO | wx.ICON_QUESTION)
                load_sets_inp = sets_inp_query_dlg.ShowModal() == wx.ID_YES
                sets_inp_query_dlg.Destroy()

                if load_sets_inp:
                    sets_inp_wild_cards = "All Supported Files (*.inp)|*.inp|"
                    sets_inp_wild_cards += "Abaqus INP files (*.inp)|*.inp|"
                    sets_inp_wild_cards += "All Files (*.*)|*.*||"

                    sets_inp_dlg = wx.FileDialog(self, 
                            message='Select Abaqus input file',
                            defaultDir=os.getcwd(), 
                            defaultFile='',
                            wildcard=sets_inp_wild_cards,
                            #style=wx.OPEN | wx.MULTIPLE | wx.CHANGE_DIR)
                            style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST | wx.FD_CHANGE_DIR)
                    if sets_inp_dlg.ShowModal() == wx.ID_OK:
                        sets_inp_file_path = sets_inp_dlg.GetPath()
                    sets_inp_dlg.Destroy()
            self.LoadModelInternal(model_file_path, ds_dat_file_path, sets_inp_file_path)
        # Destroy the dialog. Don't do this until you are done with it!
        # BAD things can happen otherwise!
        dlg.Destroy()

    def EncodedModelFileName(self, file_path):
        return file_path.encode('UTF-8')
        #fn, ext = os.path.splitext(file_path)
        #if(ext.lower() == '.odb'):
        #    return file_path.encode('UTF-8')
        #else:
        #    return file_path.encode(self.mb_encoding)
        
    def LoadModelInternal(self, path, ds_dat_path = None, sets_inp_path = None):
        if not os.path.exists(path):
            (fname, fext) = os.path.splitext(path)
            path = fname
        exfiles = Common.ExtractedFiles(path, self.tmpdir.getPath(), 
                    self.engine.GetWildCards(self.engine.MODEL_FILE),
                    self.enable_local_file_caching)
        path = exfiles[1][0]
        #self.elem_res_trans = False
        #print 'Disabling element result translation'
        if not os.path.exists(path):
            (fname, fext) = os.path.splitext(path)
            path = fname
        if path != self.model_file:
            if self.model_file:
                self.DestroyLoaded()
            self.model_file = path
            
            self.SetTitle('VMoveCAE: Processing ' + repr(self.model_file))
            self.statusbar.SetStatusText('Loading Model ...')

            if ds_dat_path:
                meta_data = self.engine.GetAnsysRstModelMetadata(
                        self.EncodedModelFileName(self.model_file),
                        ds_dat_path.encode(self.mb_encoding),
                        self.interface_grouping)
            elif sets_inp_path:
                self.engine.OdbLoadZeroFrames(self.odb_load_zero_frames_on)
                self.engine.OdbLoadInternalSets(self.odb_load_internal_sets_on)
                self.engine.OdbLoadInstanceParts(self.odb_load_instance_parts_on)
                meta_data = self.engine.GetModelMetadataWithExtSets(
                        self.EncodedModelFileName(self.model_file),
                        sets_inp_path.encode(self.mb_encoding),
                        self.interface_grouping)
            else:
                self.engine.OdbFastLoad(self.odb_fast_load_on)
                self.engine.OdbLoadZeroFrames(self.odb_load_zero_frames_on)
                self.engine.OdbLoadInternalSets(self.odb_load_internal_sets_on)
                self.engine.OdbLoadInstanceParts(self.odb_load_instance_parts_on)
                self.engine.MarcExperimentalFeatures(self.marc_experimental_features_on)
                #self.engine.BdfUseSets(self.bdf_use_sets_on)
                #self.engine.DisableParts(self.disable_parts)
                self.engine.NodalAveragedLoads(self.nodal_averaged_loads_on)
                #self.engine.ExtractModeProperties(self.extract_mode_properties_on)
                meta_data = self.engine.GetModelMetadata(
                        self.EncodedModelFileName(self.model_file),
                        self.interface_grouping)

            #print meta_data
            data_tree = et.fromstring(meta_data)
            upgraded_file = None
            if 'error' == data_tree.tag:
                wx.MessageBox(data_tree.get('message', 'Error!'), 'Error!')
                self.statusbar.SetStatusText('Loading Model ... failed')
                self.DestroyLoaded()
            if 'updateodb' == data_tree.tag:
                upgraded_file = self.UpgradeOdbWizard(
                                self.model_file,
                                self.engine.GetAbaqusOdbVersion())
                if upgraded_file:
                    self.statusbar.SetStatusText('Upgrading ODB file ... ')
                    wx.BeginBusyCursor()
                    meta_data = self.engine.UpgradeOdb(
                                self.EncodedModelFileName(self.model_file),
                                self.EncodedModelFileName(upgraded_file))
                    wx.EndBusyCursor()
                    self.DestroyLoaded()
                    if meta_data == 'success':
                        self.statusbar.SetStatusText('Upgrading ODB file ... done')
                        self.model_file = upgraded_file
                        self.SetTitle('VMoveCAE: Processing ' + self.model_file)
                        wx.BeginBusyCursor()
                        self.statusbar.SetStatusText('Loading Model ...')
                        if sets_inp_path:
                            meta_data = self.engine.GetModelMetadataWithExtSets(
                                self.EncodedModelFileName(self.model_file),
                                sets_inp_path.encode(self.mb_encoding),
                                self.interface_grouping)
                        else:
                            meta_data = self.engine.GetModelMetadata(
                                self.EncodedModelFileName(self.model_file),
                                self.interface_grouping)
                        wx.EndBusyCursor()
                        #print meta_data
                        data_tree = et.fromstring(meta_data)
                        self.file_type = data_tree.get('type', 'Unknown')
                    else:
                        data_tree = et.fromstring(meta_data)
                        if 'error' == data_tree.tag:
                            wx.MessageBox(data_tree.get('message', 'Error!'), 'Error!')
                            self.statusbar.SetStatusText('Loading Model ... failed')
                else:
                    self.model_file = None
                    self.results_file = None
                    self.file_type = 'Unknown'
            self.statusbar.SetStatusText('Loading Model ... done')
            if 'metadata' == data_tree.tag:
                if 'true' == data_tree.get('appendable', 'false'):
                    self.is_appendable = True
                else:
                    self.is_appendable = False
                self.file_type = data_tree.get('type', 'Unknown')

            if self.model_file:
                fenc = self.model_file.encode(self.mb_encoding)
                self.attributes_dict['Model File'] = os.path.basename(fenc)
                self.attributes_dict['Model File Size'] = self.engine.GetLinkedFilesSize(fenc)

                self.result_comp_dict = {}
                self.model_suffix_enabled = True
                if self.file_type == "Ensight":
                    self.model_suffix_enabled = False
                if self.file_type == "Marc Post" and self.marc_experimental_features_on:
                    self.model_suffix_enabled = False
                self.UpdateLists(data_tree)
                self.ApplyCheckDefaults()
                self.file_menu.Enable(self.Id_AppendResultsItem, 
                                                    self.is_appendable)
                self.file_toolbar.EnableTool(self.Id_AppendResultsTool, 
                                                    self.is_appendable)
                if self.results_use_instances_on:
                    self.engine.SetResultsInstanceTitle(self.results_instance_title_value.encode('UTF-8'))
                    self.engine.EnableResultsInstanceTitle()
                self.file_menu.Enable(self.Id_SaveCaxItem, True)
                self.file_toolbar.EnableTool(self.Id_SaveCaxTool, True)
                self.EnableToolsBar(True)
                self.file_menu.Enable(self.Id_SaveConfigItem, True)
                #self.features_toolbar.EnableTool(self.Id_FeatureEdge, True)
                self.features_toolbar.EnableTool(self.Id_Cut, True)
                self.features_toolbar.EnableTool(self.Id_AttributesTool, True)
                self.manager.Update()
        else:
            wx.MessageBox('Model file "' + path + '" is already loaded', 
                        'Information!')

    def AppendResults(self):
        # Create the dialog. In this case the current directory is forced as 
        # the starting directory for the dialog, and no default file name 
        # is forced. This can easilly be changed in your program. This is an 
        # 'open' dialog, and allows multitple file selections as well.
        #
        # Finally, if the directory is changed in the process of getting 
        # files, this dialog is set up to change the current working 
        # directory to the path chosen.

        # Use the self.engine_root nodes instead of the GetWildCards
        wildcard=self.engine.GetWildCards(self.engine.RESULTS_FILE)
        dlg = wx.FileDialog(self, message="Select CAE Results file",
            defaultDir=os.getcwd(), 
            defaultFile="",
            wildcard=wildcard,
            #style=wx.OPEN | wx.MULTIPLE | wx.CHANGE_DIR)
            style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST | wx.FD_CHANGE_DIR)

        # Show the dialog and retrieve the user response. If it is the 
        # OK response, process the data.
        if dlg.ShowModal() == wx.ID_OK:
            self.AppendResultsInternal(dlg.GetPath())

        # Destroy the dialog. Don't do this until you are done with it!
        # BAD things can happen otherwise!
        dlg.Destroy()

    def AppendResultsInternal(self, path):
        exfiles = Common.ExtractedFiles(path, self.tmpdir.getPath(), 
                    self.engine.GetWildCards(self.engine.RESULTS_FILE),
                    self.enable_local_file_caching)
        path = exfiles[1][0]
        extn = os.path.splitext(os.path.basename(path.encode(self.mb_encoding)))[1]
        # if '.csve' == extn.lower():
        #     self.elem_res_trans = True
        #     print 'Enabling element result translation'

        fenc = path.encode(self.mb_encoding)
        self.attributes_dict['Results File'] = os.path.basename(fenc)
        self.attributes_dict['Results File Size'] = self.engine.GetLinkedFilesSize(fenc)

        self.statusbar.SetStatusText('Loading Results ...')
        wx.BeginBusyCursor()
        addl_meta_data = self.engine.GetResultsMetadata(self.EncodedModelFileName(path))
        wx.EndBusyCursor()
        self.results_file = path
        addl_data_tree = et.fromstring(addl_meta_data)
        #print addl_meta_data
        if 'error' == addl_data_tree.tag:
            wx.MessageBox(addl_data_tree.get('message', 'Warning!'), 'Warning!')
            self.statusbar.SetStatusText('Loading Results ... failed')
        else:
            self.statusbar.SetStatusText('Loading Results ... done')

        if self.file_type == 'Ansys input' and 'metadata' == addl_data_tree.tag and addl_data_tree.get('type', 'Unknown') == 'ANSYS result':
            self.ClearAllUI()

        self.UpdateLists(addl_data_tree)

        self.is_appendable = False
        if self.file_type == 'Fluent msh/cas':
            self.is_appendable = True
        if self.results_use_instances_on:
            self.is_appendable = True

        self.file_menu.Enable(self.Id_AppendResultsItem, 
                                                    self.is_appendable)
        self.file_toolbar.EnableTool(self.Id_AppendResultsTool, 
                                                self.is_appendable)
        self.features_toolbar.EnableTool(self.Id_Cut, True)
        self.features_toolbar.EnableTool(self.Id_AttributesTool, True)


    ################## Translation String Generation ##########
 
    def GetTransStringOld(self):
        trans_string = ''
        (nextchild, cookie) = self.part_tree.GetFirstChild(self.part_root)
        while nextchild:
            if nextchild.IsChecked():
                data = nextchild.GetData()
                label = nextchild.GetText()
                trans_string += str(data[0]) + '\t'
                trans_string += str(label) + '\n'
            (nextchild, cookie) = self.part_tree.GetNextChild(
                            self.part_root, cookie)
        if self.features_root:
            if self.cutsec_root:
                (nextchild, cookie) = self.part_tree.GetFirstChild(
                                                    self.cutsec_root)
                while nextchild:
                    if nextchild.IsChecked():
                        data = nextchild.GetData()
                        label = nextchild.GetText()
                        trans_string += str(data[0]) + '\t'
                        trans_string += str(label) + '\n'
                    (nextchild, cookie) = self.part_tree.GetNextChild(
                                    self.cutsec_root, cookie)
            if self.isosurf_root:
                (nextchild, cookie) = self.part_tree.GetFirstChild(
                                                    self.isosurf_root)
                while nextchild:
                    if nextchild.IsChecked():
                        data = nextchild.GetData()
                        trans_string += str(data[0]) + '\t'
                        trans_string += str(data[1]) + '\n'
                    (nextchild, cookie) = self.part_tree.GetNextChild(
                                    self.isosurf_root, cookie)
        trans_string += "\n\n"
        if self.res_root:
            (nextchild, cookie) = self.result_tree.GetFirstChild(
                                                        self.res_root)
            while nextchild:
                trans_string = self.GetInstanceStrings(
                                            nextchild, trans_string)
                (nextchild, cookie) = self.result_tree.GetNextChild(
                            self.res_root, cookie)
        return trans_string


    def GetPartTransString(self, parent_node):
        trans_string = ''
        (nextchild, cookie) = self.part_tree.GetFirstChild(parent_node)
        while nextchild:
            if nextchild.IsChecked():
                data = nextchild.GetData()
                label = nextchild.GetText()
                if label not in self.classifier_node_names:
                    trans_string += str(data[0]) + '\t'
                    trans_string += str(0) + '\t'
                    trans_string += str(0) + '\t'
                    trans_string += str(label) + '\n'
            (nextchild, cookie) = self.part_tree.GetNextChild(parent_node, cookie)
        return trans_string
        
    def GetTransStringNew(self):
        trans_string = ''
        trans_string += 'Parts\n'
        if self.classifier_node_names:
            for k in self.classifier_node_names:
                v = self.classifier_nodes[k]
                trans_string += self.GetPartTransString(v)
        else:
            trans_string += self.GetPartTransString(self.part_root)

        if self.features_root:
            if self.feature_edges_root:
                trans_string += '\nFeature Edges\n'
                (nextchild, cookie) = self.part_tree.GetFirstChild(
                                                    self.feature_edges_root)
                while nextchild:
                    if nextchild.IsChecked():
                        data = nextchild.GetData()
                        label = nextchild.GetText()
                        trans_string += str(data[0]) + '\t'
                        trans_string += str(0) + '\t'
                        trans_string += str(0) + '\t'
                        trans_string += str(label) + '\n'
                    (nextchild, cookie) = self.part_tree.GetNextChild(
                                    self.feature_edges_root, cookie)
            if self.cutsec_root:
                trans_string += '\nCut-Sections\n'
                (nextchild, cookie) = self.part_tree.GetFirstChild(
                                                    self.cutsec_root)
                while nextchild:
                    if nextchild.IsChecked():
                        data = nextchild.GetData()
                        label = nextchild.GetText()
                        trans_string += str(data[0]) + '\t'
                        trans_string += str(0) + '\t'
                        trans_string += str(0) + '\t'
                        trans_string += str(label) + '\n'
                    (nextchild, cookie) = self.part_tree.GetNextChild(
                                    self.cutsec_root, cookie)
            if self.isosurf_root:
                trans_string += '\nIso-Surfaces\n'
                (nextchild, cookie) = self.part_tree.GetFirstChild(
                                                    self.isosurf_root)
                while nextchild:
                    if nextchild.IsChecked():
                        data = nextchild.GetData()
                        label = nextchild.GetText()
                        trans_string += str(data[0]) + '\t'
                        trans_string += str(0) + '\t'
                        trans_string += str(1) + '\t'
                        trans_string += str(data[1]) + '\t'
                        trans_string += str(label) + '\n'
                    (nextchild, cookie) = self.part_tree.GetNextChild(
                                    self.isosurf_root, cookie)
            if self.isovol_root:
                trans_string += '\nIso-Volumes\n'
                (nextchild, cookie) = self.part_tree.GetFirstChild(
                                                    self.isovol_root)
                while nextchild:
                    if nextchild.IsChecked():
                        data = nextchild.GetData()
                        trans_string += str(data[0]) + '\t'
                        trans_string += str(0) + '\t'
                        trans_string += str(0) + '\t'
                        trans_string += str(data[1]) + '\n'
                    (nextchild, cookie) = self.part_tree.GetNextChild(
                                    self.isovol_root, cookie)

            if self.flowlines_root:
                trans_string += '\nFlow Lines\n'

                (nextchild, cookie) = self.part_tree.GetFirstChild(
                                                    self.flowlines_root)
                while nextchild:
                    if nextchild.IsChecked():
                        label = nextchild.GetText()
                        data = nextchild.GetData()
                        trans_string += str(data[0]) + '\t'
                        trans_string += str(0) + '\t'
                        trans_string += str(0) + '\t'
                        trans_string += 'From ' + str(data[2]) + ' number of lines ' + str(data[3]) + ' for result ' + str(data[1].GetData()[0])
                        if -2 == data[0]:
                            trans_string += ' time step ' + str(data[4])
                            trans_string += ' steps ' + str(data[5])
                            trans_string += ' frequency ' + str(data[6])
                        trans_string += '\n'
                    (nextchild, cookie) = self.part_tree.GetNextChild(
                                self.flowlines_root, cookie)

        if self.res_root:
            trans_string += '\nResult Instances\n'
            (nextchild, cookie) = self.result_tree.GetFirstChild(
                                                        self.res_root)
            while nextchild:
                trans_string = self.GetInstanceStrings(
                                            nextchild, trans_string)
                (nextchild, cookie) = self.result_tree.GetNextChild(
                            self.res_root, cookie)

        '''
        if self.res_root:
            trans_string += '\nResult Layers\n'
            (nextchild, cookie) = self.result_tree.GetFirstChild(
                                                        self.res_root)
            while nextchild:
                data = nextchild.GetData()
                res_trans_prop = data[4]
                mask = 0
                if res_trans_prop[0] == 1:
                    mask = 256
                elif res_trans_prop[0] == 2:
                    mask = 512
                if res_trans_prop[0] == 0 and (data[0] == 'THICKNESS.EL'  or data[0] == 'THICKNESS.E'):
                    mask = 512
                if res_trans_prop[0] == 0 and (data[0] == 'SFM.EL'  or data[0] == 'SFM.E'):
                    mask = 512
                if None != res_trans_prop:
                    if None != data[2]:
                        for instance in data[2]:
                            if instance[2]:
                                trans_string += '%d\t0\t0\t%d\n' %(instance[0], res_trans_prop[2] | mask)
                    else:
                            trans_string += '%d\t0\t0\t%d\n' %(data[3], 0 | mask)
                (nextchild, cookie) = self.result_tree.GetNextChild(
                            self.res_root, cookie)
        '''

        if self.egroup_root:
            trans_string += '\nElement Groups\n'
            (nextchild, cookie) = self.part_tree.GetFirstChild(self.egroup_root)
            while nextchild:
                if nextchild.IsChecked():
                    data = nextchild.GetData()
                    label = nextchild.GetText()
                    trans_string += str(data) + '\t'
                    trans_string += str(0) + '\t'
                    trans_string += str(0) + '\t'
                    trans_string += str(label) + '\n'
                (nextchild, cookie) = self.part_tree.GetNextChild(
                        self.egroup_root, cookie)

        return trans_string


    def GetTransStringAllNew(self):
        trans_string = ''
        for group in self.groups:
            if group.GetSave():
                trans_string += '\n' + str(group) + '\n'
                item_id_list = self.vmove_tree.GetItemChildren(group.GetItem())
                for item_id in item_id_list:
                    item = self.vmove_tree.GetItemData(item_id)
                    if item.IsChecked():
                        trans_string += str(item.GetId()) + '\t'
                        label = item.GetLabel()
                        if label:
                            trans_string += str(label) + '\n'
                        else:
                            trans_string += str(item) + '\n'

        return trans_string
        parts_string = ''
        results_string = ''
        cutsec_string = ''

        part_group_item = self.group_tree_item[self.part_group]
        result_group_item = self.group_tree_item[self.result_group]
        cutsec_group_item = self.group_tree_item[self.cutsec_group]

        part_item_list = part_group_item.GetChildren()
        result_item_list = result_group_item.GetChildren()
        cutsec_item_list = cutsec_group_item.GetChildren()

        for part_item in part_item_list:
            if part_item.IsChecked():
                item_data = self.vmove_tree.GetNodeData(part_item)

                parts_string += str(item_data.id) + '\t'
                parts_string += str(item_data.name) + '\n'

        for cutsec_item in cutsec_item_list:
            if cutsec_item.IsChecked():
                item_data = self.vmove_tree.GetNodeData(cutsec_item)

                cutsec_string += str(item_data.id) + '\t'
                cutsec_string += str(item_data.name) + '\n'

        for result_item in result_item_list:
            if result_item.IsChecked():
                item_data = self.vmove_tree.GetNodeData(result_item)
                results_string += self.GetInstanceStrings(item_data)

        return parts_string + cutsec_string + '\n\n' + results_string

    def GetInstanceStrings(self, data):
        label = data.id
        instance_trans_string = ''
        for instance in data.links:
            instance_trans_string += str(instance[0]) + '\t'
            instance_trans_string += str(label)+' '+str(instance[1]) + '\n'

        return instance_trans_string

    def SaveCaxNew(self):
        # Create the dialog. In this case the current directory is forced as 
        # the starting directory for the dialog, and no default file name is 
        # forced. This can easilly be changed in your program. This is an 
        # 'save' dialog.
        #
        # Unlike the 'open dialog' example found elsewhere, this example does 
        # NOT force the current working directory to change if the user 
        # chooses a different directory than the one initially set.
        bbug = 'All Supported Files|*.cax;*.cax.gz;*.cax.bz2|Cax Files (*.cax)|*.cax;*.cax.gz;*.cax.bz2|All Files (*.*)|*.*'
        new_wild_card = "All Supported Files|*.cax;*.cax.gz;*.cax.bz2|Cax Files (*.cax)|*.cax;*.cax.gz;*.cax.bz2|All Files (*.*)|*.*"
        #self.engine.GetWildCards(self.engine.OUTPUT_FILE)
        out_file = os.path.splitext(os.path.basename(self.model_file))[0]+'.cax'
        dlg = wx.FileDialog(self, message="Save CAx file",
            wildcard= new_wild_card,
            defaultDir=os.getcwd(), 
            defaultFile=out_file,
            #self.engine.GetWildCards(self.engine.OUTPUT_FILE),
            style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT | wx.FD_CHANGE_DIR)

        # Show the dialog and retrieve the user response. If it is the 
        # OK response, process the data.
        if dlg.ShowModal() == wx.ID_OK:
            # This returns a Python list of files that were selected.
            path = dlg.GetPath()
            #trans_root = et.Element("translation")
            #part_root = et.SubElement(trans_root, "geometry")
            trans_string = self.GetTransStringNew()
            trans_res = ''
            self.engine.SeparatePartMeshes(self.sep_partsets)

            #print self.file_type
            if 'Nastran OP2' == self.file_type:
                if self.op2_rigid_rotation_var_enabled and self.op2_enable_rigid_rotation_node_value:
                    self.engine.SetVirtualRotationNode(self.op2_rigid_rotation_node_index)

            if 'Abaqus ODB' != self.file_type:
                pi_file_path = self.engine.GetPIFile()
                pi_file = None
                next_pi_line = 'Please wait.  Generating Cax. '
                pattern = re.compile(r'(\[=*\s*\]\s*)(\d*)(%\s*\[)(\s*\d*/\s*\d*)(\])')
                thread = TranslationThread(self.engine, 
                        path.encode(self.mb_encoding),
                        trans_string.encode(self.mb_encoding), 
                        self.ignore_midnodes, 
                        self.elem_res_trans, 
                        self.en_to_e_avg,
                        self.attributes_dict)
                thread.start()
                self.statusbar.SetStatusText(next_pi_line)
                self.progressbar.Show()

                while thread.is_alive():
                    self.progressbar.Update()
                    self.progressbar.Refresh()
                    wx.SafeYield()
                    if pi_file:
                        where = pi_file.tell()
                        next_pi_line = pi_file.readline()
                        if next_pi_line:
                            matches = pattern.match(next_pi_line)
                            if matches:
                                groups = matches.groups()
                                if len(groups) > 1:
                                    percent=int(groups[1])
                                    self.progressbar.SetValue(percent)
                                if len(groups) > 2:
                                    next_pi_line = 'Translating Result ' + groups[3]
                            self.statusbar.SetStatusText(next_pi_line)
                        else:
                            pi_file.seek(where)
                            time.sleep(0.05)
                    else:
                        try:
                            pi_file = open(pi_file_path, 'r')
                        except Exception as ex:
                            pass
                if pi_file:
                    pi_file.close()

                self.progressbar.Hide()
                trans_res = thread.getResult()
            else:
                trans_res = self.engine.Translate(
                        path.encode(self.mb_encoding),
                        trans_string.encode(self.mb_encoding), 
                        self.ignore_midnodes, 
                        self.elem_res_trans, 
                        self.en_to_e_avg,
                        self.attributes_dict,
                        None, None)

            if 'success' == trans_res:
                wx.MessageBox('Translated Successfully.', 'Information!')
                self.statusbar.SetStatusText('Translated Successfully')
            else:
                wx.MessageBox('Translation Failed.', 'Error!')
        # Destroy the dialog. Don't do this until you are done with it!
        # BAD things can happen otherwise!
        dlg.Destroy()

    def SaveCaxOld(self):
        # Create the dialog. In this case the current directory is forced as 
        # the starting directory for the dialog, and no default file name is 
        # forced. This can easilly be changed in your program. This is an 
        # 'save' dialog.
        #
        # Unlike the 'open dialog' example found elsewhere, this example does 
        # NOT force the current working directory to change if the user 
        # chooses a different directory than the one initially set.
        
        out_file = os.path.splitext(self.model_file) + ".cax"
        dlg = wx.FileDialog(self, message="Save CAx file",
            defaultDir=os.getcwd(), 
            defaultFile=out_file,
            wildcard=self.engine.GetWildCards(self.engine.OUTPUT_FILE),
            style=wx.SAVE | wx.FD_OVERWRITE_PROMPT | wx.FD_CHANGE_DIR)

        # Show the dialog and retrieve the user response. If it is the 
        # OK response, process the data.
        if dlg.ShowModal() == wx.ID_OK:
            # This returns a Python list of files that were selected.
            path = dlg.GetPath()
            #trans_root = et.Element("translation")
            #part_root = et.SubElement(trans_root, "geometry")
            trans_string = ''
            trans_string += 'Geometry\n'
            (nextchild, cookie) = self.part_tree.GetFirstChild(self.part_root)
            while nextchild:
                if nextchild.IsChecked():
                    trans_string += nextchild.GetText() + "\n"
                (nextchild, cookie) = self.part_tree.GetNextChild(
                                self.part_root, cookie)
            if self.features_root:
                trans_string += 'Features\n'
                if self.cutsec_root:
                    trans_string += 'Cut-Sections\n'
                    (nextchild, cookie) = self.part_tree.GetFirstChild(
                                                        self.cutsec_root)
                    while nextchild:
                        if nextchild.IsChecked():
                            trans_string += nextchild.GetText() + "\n"
                        (nextchild, cookie) = self.part_tree.GetNextChild(
                                        self.cutsec_root, cookie)
                if self.isosurf_root:
                    trans_string += 'Iso-Surfaces\n'
                    (nextchild, cookie) = self.part_tree.GetFirstChild(
                                                        self.isosurf_root)
                    while nextchild:
                        if nextchild.IsChecked():
                            trans_string += nextchild.GetText() + "\n"
                        (nextchild, cookie) = self.part_tree.GetNextChild(
                                        self.isosurf_root, cookie)
            trans_string += "\n\n"
            (nextchild, cookie) = self.result_tree.GetFirstChild(self.res_root)
            while nextchild:
                trans_string = self.GetInstanceStrings(nextchild, trans_string)
                (nextchild, cookie) = self.result_tree.GetNextChild(
                                self.res_root, cookie)
            trans_res = self.engine.Translate(path.encode(self.mb_encoding), 
                            trans_string.encode(self.mb_encoding), 
                            self.attributes_dict,
                            None, None)
            if 'success' == trans_res:
                wx.MessageBox('Translated Successfully.', 'Information!')
            else:
                wx.MessageBox('Translation Failed.', 'Error!')
        # Destroy the dialog. Don't do this until you are done with it!
        # BAD things can happen otherwise!
        dlg.Destroy()

    def GetInstConfString(self, item):
        inputs = ''

        data = item.GetData()
        label = item.GetText()
        checked_inst = []
        unchecked_inst = []
        if data[2]:
            for instance in data[2]:
                if(instance[2] and item.IsChecked()):
                    checked_inst.append(instance[1].lstrip(':'))
                else:
                    unchecked_inst.append(instance[1].lstrip(':'))

        if not checked_inst and not unchecked_inst:
            inputs += '        [result]\n'
            inputs += '            name = "%s"\n' %(label)
            inputs += '            translate = %s\n' %(str(item.IsChecked()).lower())
            inputs += '        []\n'

        if checked_inst:
            inst_str = ','.join(checked_inst)
            inputs += '        [result]\n'
            inputs += '            name = "%s"\n' %(label)
            inputs += '            instances = "%s"\n' %(inst_str)
            inputs += '            translate = %s\n' %(str(True).lower())
            inputs += '        []\n'

        if unchecked_inst:
            inst_str = ','.join(unchecked_inst)
            inputs += '        [result]\n'
            inputs += '            name = %s\n' %(label)
            inputs += '            instances = "%s"\n' %(inst_str)
            inputs += '            translate = %s\n' %(str(False).lower())
            inputs += '        []\n'

        return inputs

    def GenerateConfigParameters(self):
        inputs = ''
        inputs += '##########################################################################\n'
        inputs += '#                                                                         \n'
        inputs += '# VMoveCAE - Creates cax files from native CAE files                 \n'
        inputs += '# Copyright (C) Visual Collaboration Technologies Inc.               \n'
        inputs += '#                                                                         \n'
        inputs += '##########################################################################\n'

        inputs += '\n'
        inputs += '[VMoveCAE]\n'
        inputs += '    version = 2.0\n'
        inputs += '\n'
        inputs += '    [translation]\n'
        inputs += '        model file = "%s"\n' %(self.model_file)
        if self.results_file:
            inputs += '        results file = "%s"\n' %(self.results_file)
        out_file = os.path.splitext(self.model_file)[0] + ".cax"
        inputs += '        output file = "%s"\n' %(out_file)
        inputs += '\n'
        inputs += '        [defaults]\n'
        inputs += '            parts = translate\n'
        inputs += '            results = filter\n'
        inputs += '        []\n'
        inputs += '        [preferences]\n'
        if self.ignore_midnodes:
            inputs += '            mid-nodes = turn off\n'
        else:
            inputs += '            mid-nodes = turn on\n'
        inputs += '        []\n'

        (nextchild, cookie) = self.part_tree.GetFirstChild(self.part_root)
        while nextchild:
            data = nextchild.GetData()
            label = nextchild.GetText()
            if data:
                inputs += '        [part]\n'
                inputs += '            id = %d\n' %(data[0])
                inputs += '            name = "%s"\n' %(str(label))
                inputs += '            translate = %s\n' %(bool(str(nextchild.IsChecked())).lower())
                inputs += '        []\n'
            else:
                (subchild, cookie_2) = self.part_tree.GetFirstChild(nextchild)
                while subchild:
                    data_2 = subchild.GetData()
                    label_2 = subchild.GetText()
                    if data_2:
                        inputs += '        [part]\n'
                        inputs += '            id = %d\n' %(data_2[0])
                        inputs += '            name = "%s"\n' %(str(label_2))
                        inputs += '            translate = %s\n' %(str(bool(subchild.IsChecked())).lower())
                        inputs += '        []\n'
                    (subchild, cookie_2) = self.part_tree.GetNextChild(nextchild, cookie_2)
            (nextchild, cookie) = self.part_tree.GetNextChild(self.part_root, cookie)

        if self.res_root:
            (nextchild, cookie) = self.result_tree.GetFirstChild(
                                                        self.res_root)
            while nextchild:
                inputs += self.GetInstConfString(nextchild)
                (nextchild, cookie) = self.result_tree.GetNextChild(
                            self.res_root, cookie)

        if self.features_root:
            if self.feature_edges_root:
                (nextchild, cookie) = self.part_tree.GetFirstChild(
                                                    self.feature_edges_root)
                while nextchild:
                    data = nextchild.GetData()
                    label = nextchild.GetText()
                    inputs += '        [feature-edge]\n'
                    inputs += '            id = %d\n' %(data[0])
                    inputs += '            name = "%s"\n' %(str(label))
                    inputs += '            angle = %s\n' %(data[2])
                    inputs += '            translate = %s\n' %(bool(str(nextchild.IsChecked())).lower())
                    inputs += '        []\n'
                    (nextchild, cookie) = self.part_tree.GetNextChild(
                                    self.feature_edges_root, cookie)

            if self.cutsec_root:
                (nextchild, cookie) = self.part_tree.GetFirstChild(
                                                    self.cutsec_root)
                while nextchild:
                    data = nextchild.GetData()
                    label = nextchild.GetText()
                    inputs += '        [cut-section]\n'
                    inputs += '            plane equation = "%s"\n' %(str(label))
                    inputs += '            translate = %s\n' %(bool(str(nextchild.IsChecked())).lower())
                    inputs += '        []\n'
                    (nextchild, cookie) = self.part_tree.GetNextChild(
                                    self.cutsec_root, cookie)

            if self.isosurf_root:
                (nextchild, cookie) = self.part_tree.GetFirstChild(
                                                    self.isosurf_root)
                while nextchild:
                    data = nextchild.GetData()
                    label = nextchild.GetText()
                    llist = label.encode(self.mb_encoding).split(' = ')
                    res_name = llist[0]
                    res_dt = None
                    res_val = llist[1]
                    try:
                        res_data = data[2].GetData()
                        if res_data[1] != 'Scalar':
                            dtlist = res_name.split(' - ')
                            res_dt = dtlist.pop()
                            res_name = ' - '.join(dtlist)
                    except Exception as ex:
                        print (ex)
                    inputs += '        [iso-surface]\n'
                    inputs += '            result = "%s"\n' %(res_name)
                    if res_dt:
                        inputs += '            derived type = "%s"\n' %(res_dt)
                    inputs += '            value = %s\n' %(res_val)
                    inputs += '            translate = %s\n' %(bool(str(nextchild.IsChecked())).lower())
                    inputs += '        []\n'
                    (nextchild, cookie) = self.part_tree.GetNextChild(
                                    self.isosurf_root, cookie)

            if self.isovol_root:
                (nextchild, cookie) = self.part_tree.GetFirstChild(
                                                    self.isovol_root)
                while nextchild:
                    data = nextchild.GetData()
                    label = nextchild.GetText()
                    llist = label.encode(self.mb_encoding).split(' = ')
                    res_name = llist[0]
                    res_dt = None
                    res_val = llist[1]
                    res_val = res_val.lstrip(' \t\n(').rstrip(' \t\n)')
                    res_val_range = res_val.split(',')
                    res_low = res_val_range[0].strip()
                    res_high = res_val_range[1].strip()

                    try:
                        res_data = data[2].GetData()
                        if res_data[1] != 'Scalar':
                            dtlist = res_name.split(' - ')
                            res_dt = dtlist.pop()
                            res_name = ' - '.join(dtlist)
                    except Exception as ex:
                        print (ex)
                    inputs += '        [iso-volume]\n'
                    inputs += '            result = "%s"\n' %(res_name)
                    if res_dt:
                        inputs += '            derived type = "%s"\n' %(res_dt)
                    inputs += '            from = %s\n' %(res_low)
                    inputs += '            to = %s\n' %(res_high)
                    inputs += '        []\n'
                    (nextchild, cookie) = self.part_tree.GetNextChild(
                                    self.isovol_root, cookie)

            if self.flowlines_root:
                (nextchild, cookie) = self.part_tree.GetFirstChild(
                                                    self.flowlines_root)
                while nextchild:
                    label = nextchild.GetText()
                    data = nextchild.GetData()
                    numline_label = ' number of lines '
                    from_info = str(data[2])
                    start_loc = label
                    if start_loc.startswith('From '):
                        start_loc = start_loc[5:]
                    if -2 == data[0]:
                        inputs += '        [particle-trace]\n'
                        inputs += '            from = "%s"\n' %(start_loc)
                        inputs += '            result = "%s"\n' %(data[1].GetText().encode(self.mb_encoding))
                        inputs += '            number of lines = %s\n' %(data[3])
                        inputs += '            time step = %s\n' %(str(data[4]))
                        inputs += '            number of steps = %s\n' %(str(data[5]))
                        inputs += '            injection frequency = %s\n' %(str(data[6]))
                    else:
                        inputs += '        [field-line]\n'
                        inputs += '            from = "%s"\n' %(start_loc)
                        inputs += '            result = "%s"\n' %(data[1].GetText().encode(self.mb_encoding))
                        inputs += '            number of lines = %s\n' %(data[3])
                    inputs += '            translate = %s\n' %(bool(str(nextchild.IsChecked())).lower())
                    inputs += '        []\n'
                    (nextchild, cookie) = self.part_tree.GetNextChild(
                                self.flowlines_root, cookie)

            # Element Groups are not support as of now
            if self.egroup_root:
                (nextchild, cookie) = self.part_tree.GetFirstChild(self.egroup_root)
                while nextchild:
                    data = nextchild.GetData()
                    label = nextchild.GetText()

                    er = label
                    ei = None
                    ev = None
                    evtmp = None

                    if data > 0:
                        evtmp = ' Specified'
                        ev = 'Any'
                    else:
                        evtmp = ' Not Specified'
                        ev = 'Not Specified'

                    ri = er.rfind(evtmp)
                    if ri != -1:
                        er = er[0:ri]
                    ii = er.rfind(' L')
                    if ii != -1:
                        ei = er[ii+1:]
                        ei = ei.replace('L', ':', 1).replace('M', ':', 1)
                        er = er[0:ii]

                    inputs += '        [element-group]\n'
                    inputs += '            result = "%s"\n' %(er)
                    inputs += '            instance = "%s"\n' %(ei)
                    inputs += '            value = "%s"\n' %(ev)
                    inputs += '            translate = %s\n' %(bool(str(nextchild.IsChecked())).lower())
                    inputs += '        []\n'
                    (nextchild, cookie) = self.part_tree.GetNextChild(
                                self.egroup_root, cookie)

        inputs += '    []\n'
        inputs += '[]\n'

        return inputs

    def SaveConfiguration(self):
        wild_cards = "All Supported Files (*.txt;*.xml)|*.txt;*.xml|"
        wild_cards += "Text files (*.txt)|*.txt|"
        wild_cards += "XML files (*.xml)|*.xml|"
        wild_cards += "All Files (*.*)|*.*||"

        out_file = os.path.splitext(os.path.basename(self.model_file))[0] + "_parameters.txt"
        dlg = wx.FileDialog(self, message="Save translation parameters file",
            defaultDir=os.getcwd(), 
            defaultFile=out_file,
            wildcard=wild_cards,
            style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT | wx.FD_CHANGE_DIR)

        # Show the dialog and retrieve the user response. If it is the 
        # OK response, process the data.
        if dlg.ShowModal() == wx.ID_OK:
            # This returns a Python list of files that were selected.
            path = dlg.GetPath()
            inputs = self.GenerateConfigParameters()
            extn = os.path.splitext(os.path.basename(
                    path.encode(self.mb_encoding)))[1]
            if '.xml' == extn.lower():
                reader = InpFileReader()
                reader.FromString(inputs)
                inputs = reader.GetXmlString()
            try:
                file = open(path.encode(self.mb_encoding), 'wb')
                file.write(inputs.encode('iso-8859-1'))
                file.close()
            except os.error as msg:
                print (msg)
            wx.MessageBox('Translation parameters saved into %s.' %(path), 'Information!')
        # Destroy the dialog. Don't do this until you are done with it!
        # BAD things can happen otherwise!
        dlg.Destroy()

    def OnPartTreeSelect(self, event):
 
        self.file_menu.Enable(self.Id_SaveCaxItem, True)
        self.file_toolbar.EnableTool(self.Id_SaveCaxTool, True)
        if  not self.part_root.IsChecked():
            if not self.features_root:
                self.file_menu.Enable(self.Id_SaveCaxItem, False)
                self.file_toolbar.EnableTool(self.Id_SaveCaxTool, False)
            elif not self.features_root.IsChecked():
                self.file_menu.Enable(self.Id_SaveCaxItem, False)
                self.file_toolbar.EnableTool(self.Id_SaveCaxTool, False)


        self.cut_apply_button.Enable(False)
        self.iso_apply_button.Enable(False)
        self.isovol_apply_button.Enable(False)
        self.flowline_apply_button.Enable(False)
        self.features_toolbar.EnableTool(self.Id_LayersTool, False)
        selections = self.part_tree.GetSelections()
        if 1 == len(selections):
            for item in selections:
                p_item = item.GetParent()
                pp_item = None
                if p_item:
                    pp_item = p_item.GetParent()
                if pp_item and pp_item == self.part_root or p_item == self.part_root:
                    if self.manager.GetPane('Flow Lines').IsShown():
                        self.starting_textctrl.SetValue(item.GetText())
                elif p_item == self.cutsec_root:
                    self.cut_apply_button.Enable(True)
                    self.manager.GetPane('Iso-Surface').Hide()
                    self.manager.GetPane('Iso-Volume').Hide()
                    self.manager.GetPane('Cut-Section').Show()
                elif p_item == self.isosurf_root:
                    self.iso_apply_button.Enable(True)
                    self.manager.GetPane('Iso-Surface').Show()
                    self.manager.GetPane('Cut-Section').Hide()
                    self.manager.GetPane('Iso-Volume').Hide()
                elif p_item == self.isovol_root:
                    self.isovol_apply_button.Enable(True)
                    self.manager.GetPane('Iso-Volume').Show()
                    self.manager.GetPane('Cut-Section').Hide()
                    self.manager.GetPane('Iso-Surface').Hide()
          

        self.manager.GetPane('Instance List').Hide()
        self.manager.Update()
        
   
#---------PART--------------------------------------------------------------------------------------------

    def part_tree_check_for_other_children_check(self, tree_item):
        parent = tree_item.GetParent()
        if parent:
            if  parent != self.geom_root:
                child, cookie = self.part_tree.GetFirstChild(parent)
                if(child):
                    if not self.part_tree.IsItemChecked(child):
                        self.part_tree.SetItem3StateValue(
                            parent, wx.CHK_UNDETERMINED)
                        self.part_tree.Refresh()
                        self.part_tree_set_parent_undetermined(parent)
                        return
                while(child):
                    child, cookie = self.part_tree.GetNextChild(parent, cookie)
                    if(child):
                        if not self.part_tree.IsItemChecked(child):
                            self.part_tree.SetItem3StateValue(
                                parent, wx.CHK_UNDETERMINED)
                            self.part_tree.Refresh()
                            self.part_tree_set_parent_undetermined(parent)
                            return
                self.part_tree.SetItem3StateValue(parent, wx.CHK_CHECKED)
                self.part_tree.Refresh()
                self.part_tree_check_for_other_children_check(parent)

    def part_tree_check_for_other_children_uncheck(self, tree_item):
        parent = tree_item.GetParent()
        if parent:
            if  parent != self.geom_root:
                child, cookie = self.part_tree.GetFirstChild(parent)
                if(child):
                    if self.part_tree.IsItemChecked(child):
                        self.part_tree.SetItem3StateValue(
                            parent, wx.CHK_UNDETERMINED)
                        self.part_tree.Refresh()
                        self.part_tree_set_parent_undetermined(parent)
                        return
                while(child):
                    child, cookie = self.part_tree.GetNextChild(parent, cookie)
                    if(child):
                        if self.part_tree.IsItemChecked(child):
                            self.part_tree.SetItem3StateValue(
                                parent, wx.CHK_UNDETERMINED)
                            self.part_tree.Refresh()
                            self.part_tree_set_parent_undetermined(parent)
                            return
                self.part_tree.SetItem3StateValue(parent, wx.CHK_UNCHECKED)
                self.part_tree.Refresh()
                self.part_tree_check_for_other_children_uncheck(parent)

    def part_tree_set_parent_undetermined(self, tree_item):
        parent = tree_item.GetParent()
        if parent:
            if  parent != self.geom_root:
                self.part_tree.SetItem3StateValue(
                    parent, wx.CHK_UNDETERMINED)
                self.part_tree.Refresh()
                self.part_tree_set_parent_undetermined(parent)

    def part_tree_all_check_in_tree(self, status):
        self.part_tree.CheckItem(self.root, status)      
#----------RESULT-------------------------------------------------------------------------------------------

    def result_tree_check_for_other_children_check(self, tree_item):
        parent = tree_item.GetParent()
        if parent:
            child, cookie = self.result_tree.GetFirstChild(parent)
            if(child):
                if not self.result_tree.IsItemChecked(child):
                    self.result_tree.SetItem3StateValue(
                        parent, wx.CHK_UNDETERMINED)
                    self.result_tree.Refresh()
                    self.result_tree_set_parent_undetermined(parent)
                    return
            while(child):
                child, cookie = self.result_tree.GetNextChild(parent, cookie)
                if(child):
                    if not self.result_tree.IsItemChecked(child):
                        self.result_tree.SetItem3StateValue(
                            parent, wx.CHK_UNDETERMINED)
                        self.result_tree.Refresh()
                        self.result_tree_set_parent_undetermined(parent)
                        return
            self.result_tree.SetItem3StateValue(parent, wx.CHK_CHECKED)
            self.result_tree.Refresh()
            self.result_tree_check_for_other_children_check(parent)

    def result_tree_check_for_other_children_uncheck(self, tree_item):
        parent = tree_item.GetParent()
        if parent:
            child, cookie = self.result_tree.GetFirstChild(parent)
            if(child):
                if self.result_tree.IsItemChecked(child):
                    self.result_tree.SetItem3StateValue(
                        parent, wx.CHK_UNDETERMINED)
                    self.result_tree.Refresh()
                    self.result_tree_set_parent_undetermined(parent)
                    return
            while(child):
                child, cookie = self.result_tree.GetNextChild(parent, cookie)
                if(child):
                    if self.result_tree.IsItemChecked(child):
                        self.result_tree.SetItem3StateValue(
                            parent, wx.CHK_UNDETERMINED)
                        self.result_tree.Refresh()
                        self.result_tree_set_parent_undetermined(parent)
                        return
            self.result_tree.SetItem3StateValue(parent, wx.CHK_UNCHECKED)
            self.result_tree.Refresh()
            self.result_tree_check_for_other_children_uncheck(parent)

    def result_tree_set_parent_undetermined(self, tree_item):
        parent = tree_item.GetParent()
        if parent:
            
            self.result_tree.SetItem3StateValue(
                parent, wx.CHK_UNDETERMINED)
            self.result_tree.Refresh()
            self.result_tree_set_parent_undetermined(parent)

    def result_tree_all_check_in_tree(self, status):
        self.result_tree.CheckItem(self.root, status)     
#----------PART-------------------------------------------------------------------------------------------

    def OnPartTreeCheck(self, event):
      
        tree_item = event.GetItem()
        if tree_item.IsChecked() == wx.CHK_CHECKED:
            self.part_tree.CheckChilds(tree_item, True)
            self.part_tree_check_for_other_children_check(tree_item)
        elif tree_item.IsChecked() == wx.CHK_UNDETERMINED:
            self.part_tree.SetItem3StateValue(
                tree_item, wx.CHK_UNCHECKED)
            self.part_tree.CheckChilds(tree_item, False)
            self.part_tree_check_for_other_children_uncheck(tree_item)
        elif tree_item.IsChecked() == wx.CHK_UNCHECKED:
            self.part_tree.CheckChilds(tree_item, False)
        self.part_tree.Refresh()

    def all_selection_in_tree(self, status):
        for branch in self.branches:
            child, cookie = self.GetFirstChild(branch)
            if(child):
                self.SelectItem(child, status)
            while(child):
                child, cookie = self.GetNextChild(branch, cookie)
                if(child):
                    self.SelectItem(child, status)

    def invert_selection_in_tree(self):
        for branch in self.branches:
            child, cookie = self.GetFirstChild(branch)
            if(child):
                self.ToggleItemSelection(child)
            while(child):
                child, cookie = self.GetNextChild(branch, cookie)
                if(child):
                    self.ToggleItemSelection(child)

    def checked_selection_in_tree(self, status):
        for branch in self.branches:
            child, cookie = self.GetFirstChild(branch)
            if(child):
                if(self.IsItemChecked(child)):
                    self.SelectItem(child, status)
            while(child):
                child, cookie = self.GetNextChild(branch, cookie)
                if(child):
                    if(self.IsItemChecked(child)):
                        self.SelectItem(child, status)

    def unchecked_selection_in_tree(self, status):
        for branch in self.branches:
            child, cookie = self.GetFirstChild(branch)
            if(child):
                if not self.IsItemChecked(child):
                    self.SelectItem(child, status)
            while(child):
                child, cookie = self.GetNextChild(branch, cookie)
                if(child):
                    if not self.IsItemChecked(child):
                        self.SelectItem(child, status)

    def selected_selection_in_tree(self, status):
        if not status:
            for branch in self.branches:
                child, cookie = self.GetFirstChild(branch)
                if(child):
                    if self.IsSelected(child):
                        self.SelectItem(child)
                while(child):
                    child, cookie = self.GetNextChild(branch, cookie)
                    if(child):
                        if self.IsSelected(child):
                            self.SelectItem(child)
        self.manager.Update()

    def deselected_selection_in_tree(self):
        for branch in self.branches:
            child, cookie = self.GetFirstChild(branch)
            if(child):
                if not self.IsSelected(child):
                    self.SelectItem(child, select=True)
            while(child):
                child, cookie = self.GetNextChild(branch, cookie)
                if(child):
                    if not self.IsSelected(child):
                        self.SelectItem(child, select=True)

    def invert_check_in_tree(self):
        for branch in self.branches:
            child, cookie = self.GetFirstChild(branch)
            if(child):
                if self.IsItemChecked(child):
                    self.CheckItem(child, checked=False)
                else:
                    self.CheckItem(child, checked=True)
            while(child):
                child, cookie = self.GetNextChild(branch, cookie)
                if(child):
                    if self.IsItemChecked(child):
                        self.CheckItem(child, checked=False)
                    else:
                        self.CheckItem(child, checked=True)

    def checked_check_in_tree(self, status):
        for branch in self.branches:
            child, cookie = self.GetFirstChild(branch)
            if(child):
                if self.IsItemChecked(child):
                    self.CheckItem(child, status)
            while(child):
                child, cookie = self.GetNextChild(branch, cookie)
                if(child):
                    if self.IsItemChecked(child):
                        self.CheckItem(child, status)

    def unchecked_check_in_tree(self, status):
        for branch in self.branches:
            child, cookie = self.GetFirstChild(branch)
            if(child):
                if not self.IsItemChecked(child):
                    self.CheckItem(child, status)
            while(child):
                child, cookie = self.GetNextChild(branch, cookie)
                if(child):
                    if not self.IsItemChecked(child):
                        self.CheckItem(child, status)

    def selected_ckeck_in_tree(self, status):
        for branch in self.branches:
            child, cookie = self.GetFirstChild(branch)
            if(child):
                if child.IsSelected():
                    self.CheckItem(child, status)
            while(child):
                child, cookie = self.GetNextChild(branch, cookie)
                if(child):
                    if child.IsSelected():
                        self.CheckItem(child, status)

    def deselected_check_in_tree(self, status):
        for branch in self.branches:
            child, cookie = self.GetFirstChild(branch)
            if(child):
                if not child.IsSelected():
                    self.CheckItem(child, status)
            while(child):
                child, cookie = self.GetNextChild(branch, cookie)
                if(child):
                    if not child.IsSelected():
                        self.CheckItem(child, status)

    def get_updated_table(self):
        if self.grping_tree is None:
                return None
        if not self.root.IsChecked():
            self.grping_tree['check_box'] = False
            return self.grping_tree
        for i, branch in enumerate(self.branches):
            if not branch.IsChecked():
                self.grping_tree['check_box'][self.grping_tree['name']
                                              == branch.GetText().encode("utf-8")] = False
                self.grping_tree['check_box'][self.grping_tree['parent_id']
                                              == i+2] = False
                continue
            leaves = branch.GetChildren()
            for leaf in leaves:
                if not leaf.IsChecked():
                    self.grping_tree['check_box'][self.grping_tree['name']
                                                  == leaf.GetText().encode("utf-8")] = False
        return self.grping_tree
#----------RESULT-------------------------------------------------------------------------------------------

    def OnResultCheck(self, event):
        
        tree_item = event.GetItem()
        parent = tree_item.GetParent()
        if parent != None:
            if parent.GetText() != 'Results':
                if parent.IsChecked():
                    self.result_tree.CheckChilds(parent, checked=True)
                 
                    return
                else:
                    self.result_tree.CheckChilds(parent, checked=False)
                 
                    return
        if tree_item.IsChecked() == wx.CHK_CHECKED:
            self.result_tree.CheckChilds(tree_item, True)
            self.result_tree_check_for_other_children_check(tree_item)
        elif tree_item.IsChecked() == wx.CHK_UNDETERMINED: # IsChecked()
            self.result_tree.SetItem3StateValue(
                tree_item, wx.CHK_UNCHECKED)
            self.result_tree.CheckChilds(tree_item, False)
      
            self.result_tree_check_for_other_children_uncheck(tree_item)
        elif tree_item.IsChecked() == wx.CHK_UNCHECKED:
            self.result_tree.CheckChilds(tree_item, False)
        self.result_tree.Refresh()

    def on_treeitem_selection(self, event):
        cb = event.GetItem()
        pane = self.manager.GetPane('Instance List')
        name = self.GetItemText(cb)
        pos = np.where(
            self.result_tree['result_name'] == name.encode("utf-8"))[0]
        self.data = self.result_tree[pos]['data'][0]
        if self.data is None:
            pane.Hide()
            self.manager.Update()
            return
        substep = self.data["frame"]
        instances_list = [f'L{l}M{substep[i]}' for i,
                          l in enumerate(self.data['step']) if l != 0]
        check_these = np.where(self.data['check_box'])[0]
        if instances_list:
            self.instance_listbox.ClearAll()
            self.instance_listbox.Set(instances_list)
            if len(check_these) != 0:
                self.instance_listbox.SetCheckedItems(
                    check_these)
            pane.Show()
        else:
            pane.Hide()
        self.manager.Update()

    def on_instances_check(self, event):
        cb = event.GetSelection()
        self.data['check_box'][cb] = self.instance_listboxI.sChecked(
            cb)

    def all_selection_in_tree(self, status):
        for branch in self.branches:
            self.SelectItem(branch, status)

    def invert_selection_in_tree(self):
        for branch in self.branches:
            self.ToggleItemSelection(branch)

    def checked_selection_in_tree(self, status):
        for branch in self.branches:
            if self.IsItemChecked(branch):
                self.SelectItem(branch, status)

    def unchecked_selection_in_tree(self, status):
        for branch in self.branches:
            if not self.IsItemChecked(branch):
                self.SelectItem(branch, status)

    def selected_selection_in_tree(self, status):
        if not status:
            for branch in self.branches:
                if self.IsSelected(branch):
                    self.SelectItem(branch)

    def deselected_selection_in_tree(self, status):
        for branch in self.branches:
            if not self.IsSelected(branch):
                self.SelectItem(branch, status)

    def all_selection_in_instances(self, status):
        if not status:
            for i in range(len(self.data)):
                self.instance_listbox.Deselect(i)
        else:
            for i in range(len(self.data)):
                self.instance_listbox.SetSelection(i)

    def invert_selection_in_instances(self):
        selected_list = self.instance_listbox.GetSelections()
        for i in range(len(self.data)):
            if i in selected_list:
                self.instance_listbox.Deselect(i)
            else:
                self.instance_listbox.SetSelection(i)

    def checked_selection_in_instances(self, status):
        checked_items = self.instance_listbox.GetCheckedItems()
        if status:
            for item in checked_items:
                self.instance_listbox.SetSelection(item)
        else:
            for item in checked_items:
                self.instance_listbox.Deselect(item)

    def unchecked_selection_in_instances(self, status):
        if status:
            for i in range(len(self.data)):
                if not self.instance_listbox.IsChecked(i):
                    self.instance_listbox.SetSelection(i)
        else:
            for i in range(len(self.data)):
                if not self.instance_listbox.IsChecked(i):
                    self.instance_listbox.Deselect(i)

    def deselected_selection_in_instances(self):
        for i in range(len(self.data)):
            if not self.instance_listbox.IsSelected(i):
                self.instance_listbox.SetSelection(i)

    def selected_selection_in_instances(self, status):
        if not status:
            for i in range(len(self.data)):
                if self.instance_listbox.IsSelected(i):
                    self.instance_listbox.Deselect(i)

    def invert_check_in_tree(self):
        for branch in self.branches:
            if self.IsItemChecked(branch):
                self.CheckItem(branch, checked=False)
            else:
                self.CheckItem(branch, checked=True)

    def checked_check_in_tree(self, status):
        for branch in self.branches:
            if self.IsItemChecked(branch):
                self.CheckItem(branch, status)

    def unchecked_check_in_tree(self, status):
        for branch in self.branches:
            if not self.IsItemChecked(branch):
                self.CheckItem(branch, status)

    def selected_ckeck_in_tree(self, status):
        for branch in self.branches:
            if branch.IsSelected():
                self.CheckItem(branch, status)

    def deselected_check_in_tree(self, status):
        for branch in self.branches:
            if not branch.IsSelected():
                self.CheckItem(branch, status)

    def all_check_in_instances(self, status):
        for i in range(len(self.data)):
            self.instance_listbox.Check(i, status)
        self.data['check_box'] = status

    def invert_check_in_instances(self):
        for i in range(len(self.data)):
            if self.instance_listbox.IsChecked(i):
                self.instance_listbox.Check(i, False)
                self.data['check_box'][i] = False
            else:
                self.instance_listbox.Check(i, True)
                self.data['check_box'][i] = True

    def checked_check_in_instances(self, status):
        for i in range(len(self.data)):
            if self.instance_listbox.IsChecked(i):
                self.instance_listbox.Check(i, status)
                self.data['check_box'][i] = status

    def unchecked_check_in_instances(self, status):
        for i in range(len(self.data)):
            if not self.instance_listbox.IsChecked(i):
                self.instance_listbox.Check(i, status)
                self.data['check_box'][i] = status

    def selected_check_in_instances(self, status):
        for i in range(len(self.data)):
            if self.instance_listbox.IsSelected(i):
                self.instance_listbox.Check(i, status)
                self.data['check_box'][i] = status

    def deselected_check_in_instances(self, status):
        for i in range(len(self.data)):
            if not self.instance_listbox.IsSelected(i):
                self.instance_listbox.Check(i, status)
                self.data['check_box'][i] = status

    def checkall_and_expand(self):
        self.part_tree.ExpandAll()
        self.part_tree.CheckItem(self.root, checked=True)

    def get_updated_table(self):
        if self.result_tree is None:
            return None
        if not self.root.IsChecked():
            self.result_tree['check_box'] = False
            return self.result_tree
        for i, branch in enumerate(self.branches):
            if not branch.IsChecked():
                self.result_tree['check_box'][self.result_tree['result_name']
                                              == branch.GetText().encode("utf-8")] = False
        return self.result_tree

#-----------------------------------------------------------------------------------------------------
    def OnResultSel(self, event):
        self.manager.GetPane('Instance List').Hide()
        self.manager.GetPane('Layers').Hide()
        self.features_toolbar.EnableTool(self.Id_Stream, False)
        self.features_toolbar.EnableTool(self.Id_LayersTool, False)
        self.features_toolbar.EnableTool(self.Id_NewResultTool, False)

        parent_item = event.GetItem().GetParent()
        if self.res_root == parent_item:
            self.InstanceUpdate()
            # self.InstanceUpdateOld()

        # if self.result_tree.GetRootItem() != parent_item:
        if self.manager.GetPane('Iso-Surface').IsShown():
            self.iso_on = True
        self.manager.GetPane('Iso-Surface').Hide()
        self.features_toolbar.EnableTool(self.Id_Iso, False)
        #self.features_toolbar.EnableTool(self.Id_LayersTool, False)
        self.features_toolbar.EnableTool(self.Id_NewResultTool, False)
        selections = self.result_tree.GetSelections()
        if 1 == len(selections):
            for item in selections:
                data = item.GetData()
                is_dt = True
                if self.res_root == parent_item:
                    is_dt = False
                res_trans_prop = data[4]
                if is_dt:
                    parent_data = parent_item.GetData() 
                    res_trans_prop = parent_data[4]
                no_layers = True
                if res_trans_prop and res_trans_prop[1]:
                    no_layers = False

                #if 'Scalar' == data[1] and no_layers:
                if 'Scalar' == data[1]:
                    if is_dt:
                        self.features_toolbar.EnableTool(self.Id_NewResultTool, True)
                    self.features_toolbar.EnableTool(self.Id_Iso, True)
                    #self.features_toolbar.EnableTool(self.Id_IsoVolume, True)

                    if self.iso_on:
                        label = item.GetText()
                        parent = item.GetParent()
                        parent_label = parent.GetText()
                        if parent == self.res_root:
                            self.iso_static_text.SetLabel(label + ' = ')
                        else:
                            self.iso_static_text.SetLabel(parent_label +
                                        ' - ' + label + ' = ')
                        self.manager.GetPane('Iso-Surface').Show()
                elif 'Vector' == data[1]:
                    self.features_toolbar.EnableTool(self.Id_Stream, True)
                    #self.features_toolbar.EnableTool(self.Id_Stream, False)
            self.features_toolbar.EnableTool(self.Id_LayersTool, True)

        self.manager.Update()

    def OnCreateResultUnUsed(self, event):
        id = event.GetId()
        if not self.result_info_under_mouse:
            event.Veto()
            return
        [item, parent] = self.result_info_under_mouse
        result_displayname = parent.GetText() + " - " + item.GetText()
        new_item = self.result_tree.AppendItem(self.res_root, 
                        result_displayname, 1)
        self.result_tree.SetItem3State(new_item, True)
        self.result_tree.SetItem3StateValue(new_item, wx.CHK_CHECKED)
        self.result_tree.SetItem3State(parent, False)
        self.result_tree.SetItem3StateValue(parent, wx.CHK_UNCHECKED)
        
        # self.result_tree.CheckItem(new_item, True)
        # self.result_tree.CheckItem(parent, False)
        new_item_data = item.GetData()
        new_item.SetData(new_item_data)
        self.result_info_under_mouse = None
        event.Skip()

    def OnResultRightUpUnUsed(self, event):
        self.result_info_under_mouse = None
        pt = event.GetPosition()
        item, flags = self.result_tree.HitTest(pt)
        menu = None
        if self.result_tree.GetRootItem() != item and self.result_tree.GetRootItem() != item.GetParent():
            parent = item.GetParent()
            data = item.GetData()
            if 'Scalar' == data[1] and parent.GetData():
                contextMenu = wx.Menu()
                id_create_res = wx.NewIdRef(count=1)
                create_res = contextMenu.Append(id_create_res, 
                        "&Create Result", "Create Result")
                self.result_info_under_mouse = [item, parent]
                self.Bind(wx.EVT_MENU, self.OnCreateResult, id = contextMenu)
        
        if contextMenu:
            self.PopupMenu(contextMenu)
            contextMenu.Destroy()
        self.manager.Update()

    def OnResultRightDown(self, event):
        pt = event.GetPosition()
        item, flags = self.result_tree.HitTest(pt)
        
        self.manager.Update()

    def OnResultRightUp(self, event):
        #pt = event.GetPosition()
        #item, flags = self.result_tree.HitTest(pt)
        
        vectors_found = False
        sixdofs_found = False
        tensors_found = False

        selections = self.result_tree.GetSelections()
        if 0 < len(selections):
            selected = []
            for item in selections:
                if self.result_tree.GetRootItem() != item and self.result_tree.GetRootItem() != item.GetParent():
                    data = item.GetData()
                    if 'Vector' == data[1]:
                        vectors_found = True
                    if 'SixDof' == data[1]:
                        sixdofs_found = True
                    if 'Tensor' == data[1]:
                        tensors_found = True

        menu = wx.Menu()

        vector_types_menu = None
        sixdof_types_menu = None
        tensor_types_menu = None

        id_vec_x = wx.NewIdRef(count=1)
        id_vec_y = wx.NewIdRef(count=1)
        id_vec_z = wx.NewIdRef(count=1)
        id_vec_r = wx.NewIdRef(count=1)

        id_six_tx = wx.NewIdRef(count=1)
        id_six_ty = wx.NewIdRef(count=1)
        id_six_tz = wx.NewIdRef(count=1)
        id_six_tr = wx.NewIdRef(count=1)
        id_six_rx = wx.NewIdRef(count=1)
        id_six_ry = wx.NewIdRef(count=1)
        id_six_rz = wx.NewIdRef(count=1)
        id_six_rr = wx.NewIdRef(count=1)

        if vectors_found:
            vector_types_menu = wx.Menu()
            vec_x = vector_types_menu.AppendCheckItem(id_vec_x, "X")
            vec_y = vector_types_menu.AppendCheckItem(id_vec_y, "Y")
            vec_z = vector_types_menu.AppendCheckItem(id_vec_z, "Z")
            vec_r = vector_types_menu.AppendCheckItem(id_vec_r, "Magnitude")
            menu.AppendSubMenu(vector_types_menu, '&Vector')
        if sixdofs_found:
            sixdof_types_menu = wx.Menu()
            six_tx = sixdof_types_menu.AppendCheckItem(id_six_tx, "TX")
            six_ty = sixdof_types_menu.AppendCheckItem(id_six_ty, "TY")
            six_tz = sixdof_types_menu.AppendCheckItem(id_six_tz, "TZ")
            six_rx = sixdof_types_menu.AppendCheckItem(id_six_rx, "RX")
            six_ry = sixdof_types_menu.AppendCheckItem(id_six_ry, "RY")
            six_rz = sixdof_types_menu.AppendCheckItem(id_six_rz, "RZ")
            six_tr = sixdof_types_menu.AppendCheckItem(id_six_tr, "TMag")
            six_rr = sixdof_types_menu.AppendCheckItem(id_six_rr, "RMag")
            menu.AppendSubMenu(sixdof_types_menu, '&SixDof')
        if tensors_found:
            tensor_types_menu = wx.Menu()
            menu.AppendSubMenu(tensor_types_menu, '&Tensor')

        self.PopupMenu(menu)
        menu.Destroy()

        self.manager.Update()

    # def OnResultCheck(self, event):
    #     print("i am here2")
    #     parent = event.GetItem().GetParent()
    #     if parent not in [self.result_tree.GetRootItem(), self.res_root]:
    #         event.Veto()
    #     else:
    #         event.Skip()

        
    def OnInstanceFocused(self, event):
        # self.choice_list.Activate('Instances')
        self.features_toolbar.EnableTool(self.Id_EGroup, True)
        self.result_group_checkbox.SetValue(False)
        self.no_result_group_checkbox.SetValue(False)
        event.Skip()
    

    def OnInstanceUnCheck(self, event):
        row = event.GetIndex()
        col = event.GetColumn()
        item = event.GetItem()
        item_name = event.GetText()
        object = event.GetEventObject()
        image_index = item.GetImage()

        selections = self.result_tree.GetSelections()
        if 0 < len(selections):
            for item in selections:
                data = item.GetData()
                for instance in data[2]:
                    instance_str = instance[1].replace(':', 'L', 1).replace(':', 'M', 1)
                    instance_name = instance[4]
                    if item_name == instance_str or item_name == instance_name:
                        if tclb.TriState_Checked == image_index:
                            instance[2] = True
                        elif tclb.TriState_NotChecked == image_index:
                            instance[2] = False
        
        # self.Refresh()  
        # event.Skip() 
        
    def OnInstanceCheck(self, event):
        row = event.GetIndex()
        col = event.GetColumn()
        item = event.GetItem()
        item_name = event.GetText()
        object = event.GetEventObject()
        image_index = item.GetImage()

        selections = self.result_tree.GetSelections()
        if 0 < len(selections):
            for item in selections:
                data = item.GetData()
                for instance in data[2]:
                    instance_str = instance[1].replace(':', 'L', 1).replace(':', 'M', 1)
                    instance_name = instance[4]
                    if item_name == instance_str or item_name == instance_name:
                        if tclb.TriState_Checked == image_index:
                            instance[2] = False
                        elif tclb.TriState_NotChecked == image_index:
                            instance[2] = True
        
        # self.Refresh()  
        # event.Skip()           

    def UpdateSelCheckItem(self, type, choice, tree, item):
        if 'Invert' == choice:
            if type in ['Select', 'Deselect']:
                if item.IsSelected():
                    tree.SelectItem(item, False)
                else:
                    tree.SelectItem(item, True)
            elif type in ['Check', 'Uncheck']:
                if item.IsChecked():
                    tree.CheckItem(item, False)
                else:
                    tree.CheckItem(item, True)
        else:
            if 'Select' == type and not item.IsSelected():
                if choice in ['All', 'Deselected'] or \
                    'Checked' == choice and item.IsChecked() or \
                    'Unchecked' == choice and not item.IsChecked():
                    tree.SelectItem(item, True)
            elif 'Deselect' == type and item.IsSelected():
                if choice in ['All', 'Selected'] or \
                    'Checked' == choice and item.IsChecked() or \
                    'Unchecked' == choice and not item.IsChecked():
                    tree.SelectItem(item, False)
            elif 'Check' == type and not item.IsChecked():
                if choice in ['All', 'Unchecked'] or \
                    'Selected' == choice and item.IsSelected() or \
                    'Deselected' == choice and not item.IsSelected():
                    tree.CheckItem(item, True)
            elif 'Uncheck' == type and item.IsChecked(): 
                if choice in ['All', 'Checked'] or \
                    'Selected' == choice and item.IsSelected() or \
                    'Deselected' == choice and not item.IsSelected():
                    tree.CheckItem(item, False)

    def UpdateSelCheckChildren(self, type, choice, tree, item):
        p_item = item.GetParent()
        pp_item = None
        if p_item:
            pp_item = p_item.GetParent()
        #if pp_item and pp_item == self.part_root or p_item == self.part_root:
        if pp_item and pp_item == self.part_root:
            self.UpdateSelCheckItem(type, choice, tree, item)
        if p_item == self.res_root:
            self.result_tree.Collapse(item)
            self.UpdateSelCheckItem(type, choice, tree, item)
        #elif self.resprop_root != item.GetParent() and item.IsSelected():
        #    self.result_tree.SelectItem(item, False)

        if item.HasChildren() and item.IsExpanded():
            for child in item.GetChildren():
                self.UpdateSelCheckChildren(type, choice, tree, child)

    def UpdateSelCheckTree(self, type, choice, tree):
        rootItem = tree.GetRootItem()
        if rootItem:
            self.UpdateSelCheckChildren(type, choice, tree, rootItem)

    def UpdateSelCheckLBox(self, type, choice, listbox):
        idx = listbox.GetNextItem(-1)
        while -1 != idx:
            if 'Invert' == choice:
                if type in ['Select', 'Deselect']:
                    if listbox.IsItemChecked(idx):
                        listbox.Select(idx, False)
                    else:
                        listbox.Select(idx, True)
                elif type in ['Check', 'Uncheck']:
                    if listbox.IsItemChecked(idx):
                        listbox.CheckItem(idx, False)
                    else:
                        listbox.CheckItem(idx, True)
            else:
                if 'Select' == type and not listbox.IsItemChecked(idx):
                    if choice in ['All', 'Deselected'] or \
                        'Checked' == choice and listbox.IsItemChecked(idx) or \
                        'Unchecked' == choice and not listbox.IsItemChecked(idx):
                        listbox.Select(idx, True)
                elif 'Deselect' == type and listbox.IsSelected(idx):
                    if choice in ['All', 'Selected'] or \
                        'Checked' == choice and listbox.IsItemChecked(idx) or \
                        'Unchecked' == choice and not listbox.IsItemChecked(idx):
                        listbox.Select(idx, False)
                elif 'Check' == type and not listbox.IsItemChecked(idx):
                    if choice in ['All', 'Unchecked'] or \
                        'Selected' == choice and listbox.IsItemChecked(idx) or \
                        'Deselected' == choice and not listbox.IsItemChecked(idx):
                        listbox.CheckItem(idx, True)
                elif 'Uncheck' == type and listbox.IsItemChecked(idx): 
                    if choice in ['All', 'Checked'] or \
                        'Selected' == choice and listbox.IsSelected(idx) or \
                        'Deselected' == choice and not listbox.IsSelected(idx):
                        listbox.CheckItem(idx, False)

            previdx = idx
            idx = listbox.GetNextItem(previdx)

    def UpdateSelCheck(self, treetype, type, choice):
        if 'Geometry' == treetype:
            self.UpdateSelCheckTree(type, choice, self.part_tree)
        elif 'Results' == treetype:
            self.UpdateSelCheckTree(type, choice, self.result_tree)
        elif 'Instances' == treetype:
            self.UpdateSelCheckLBox(type, choice, self.instance_listbox)

    def AddPart(self, element):
        part_id = int(element.get('id', '-1'))
        part_name = element.get('name', '')
        #if appending is enabled
        #part_name = part_name + str(part_id)
        part_classifier = element.get('classifier', 'Geometry')
        parent_path = element.get('parent_path', 'Geometry')
        parent_path_list = parent_path.split('$')
        if '-1' == part_id:
            raise Exception("\nERROR: Error in Part Data")
        if '' == part_name:
            #part_name = 'Object ' + str(part_id)
            #part_name = 'Body ' + str(part_id) + ' " Solid"'
            part_name = str(part_id)
        if not  self.geom_root:
            self.geom_root = self.part_tree.AddRoot('Geometry and Features')
            self.part_tree.SetItem3State(self.geom_root, True)
            self.part_tree.SetItem3StateValue(self.geom_root, wx.CHK_CHECKED)
            # self.part_root = self.part_tree.AddRoot('Geometry',1)
            self.part_root = self.part_tree.AppendItem(self.geom_root, 
                            'Geometry', 1)
            self.part_tree.SetItem3State(self.part_root, True)
            self.part_tree.SetItem3StateValue(self.part_root, wx.CHK_CHECKED)
            # self.part_tree.CheckItem(self.part_root, True)
            # self.part_tree.CheckItem(self.part_root, True)
            
            # self.part_tree.CheckChilds(self.part_root)
        item = None
        if part_classifier == 'Geometry':
            item = self.part_tree.AppendItem(self.part_root, part_name, 1)
            self.part_tree.SetItem3State(item , True)
            self.part_tree.SetItem3StateValue(item , wx.CHK_CHECKED)
        else:
            if part_classifier not in self.classifier_node_names:
                self.classifier_node_names.append(part_classifier)
                self.classifier_nodes[part_classifier] = self.part_tree.AppendItem(self.part_root, part_classifier, 1)
                self.part_tree.SetItem3State(self.classifier_nodes[part_classifier] , True)
                self.part_tree.SetItem3StateValue(self.classifier_nodes[part_classifier] , wx.CHK_CHECKED)
                
            if parent_path_list[0] == '' and parent_path_list[1] == part_classifier:
                for pind in range(2, len(parent_path_list)):
                    pppname = parent_path_list[pind-1]
                    pppnode = self.classifier_nodes[pppname]
                    ppname = parent_path_list[pind]
                    if ppname not in self.classifier_node_names:
                        self.classifier_node_names.append(ppname)
                        self.classifier_nodes[ppname] = self.part_tree.AppendItem(pppnode, ppname, 1)
                        self.part_tree.SetItem3State(self.classifier_nodes[ppname] , True)
                        self.part_tree.SetItem3StateValue(self.classifier_nodes[ppname], wx.CHK_CHECKED)
                part_classifier = parent_path_list[-1]
            item = self.part_tree.AppendItem(self.classifier_nodes[part_classifier], part_name, 1)
            self.part_tree.SetItem3State(item , True)
            self.part_tree.SetItem3StateValue(item , wx.CHK_CHECKED)
            
        item.SetData([part_id, part_name])
        
        # self.part_tree.CheckItem(item)

    def IsValidResultComponent(self, compname, datatype, contents):
        #if compname in ['X.N', 'THICKNESS.EL', 'DELETED.E']: 
        if compname == 'X.N' and contents == 'Position': 
            return False

        if compname in ['DELETED.E']: 
            return False

        if compname.startswith('ROT_ANG.') and compname.endswith('.EL'):
            return False

        return True

    def ComputeInstanceName(self, element):
        instance_title_1 = element.get('instance_title_1', '')
        instance_value_1 = element.get('instance_value_1', '')
        instance_title_2 = element.get('instance_title_2', '')
        instance_value_2 = element.get('instance_value_2', '')
        instance_name = ''
        if(instance_title_1):
            instance_name = instance_name + instance_title_1
        if(instance_value_1):
            instance_name = instance_name + ' = ' + instance_value_1
        if(instance_title_2):
            instance_name = instance_name + ' ' + instance_title_2
        if(instance_value_2):
            instance_name = instance_name + ' = ' + instance_value_2
        return instance_name
        
    def AddResult(self, element):
        res_trans_prop = [0, 0, 0]
        for attr in element.iter():
            name = attr.attrib.get("name")
            if name == 'Link.Section':
                res_trans_prop[1] = 1
                res_trans_prop[2] = self.layer_objects[0]['value'] | self.layer_objects[1]['value']
        result_index = int(element.get('index', '-999999'))
        result_contents = element.get('contents', '')
        result_dsname = element.get('dsname', '')
        result_datatype = element.get('datatype', 'Scalar')
        result_model = int(element.get('model', 0))
        if result_datatype not in DerivedTypeSettings.keys():
            return

        result_displayname = element.get('displayname', result_contents)

        result_dsname = re.sub(r'\.\[Step=\d*\]\.', '.', result_dsname, 1)
        result_dsname = re.sub(r'\,Step=\d*', '', result_dsname, 1)

        result_instance_info = result_dsname.split(':')
        if result_dsname.startswith('UNKNOWN.') and len(result_instance_info) > 2 and result_displayname:
            result_dsname = ':'.join([result_displayname] + result_instance_info[1:3])
            #print result_dsname

        result_instance_info = result_dsname.split(':')
        result_inst_name = self.ComputeInstanceName(element)
        #print result_inst_name
        result_compname = result_instance_info[0]
        result_displayname_compname_pair = '{%s}-{%s}' % (result_displayname, result_compname)
        check_by_default = True

        if self.IsValidResultComponent(result_compname, result_datatype, result_contents):
            #result_displayname = result_contents
            '''
            if 'S.E' == result_compname:
                result_displayname = 'Stress (Centroidal)'
            if 'S.SEC.BOT.EL' == result_compname:
                result_displayname = 'Bottom Section Stress'
            if 'S.SEC.TOP.EL' == result_compname:
                result_displayname = 'Top Section Stress'
            if 'S.SEC.BOT.E' == result_compname:
                result_displayname = 'Bottom Section Stress (Centroidal)'
            if 'S.SEC.TOP.E' == result_compname:
                result_displayname = 'Top Section Stress (Centroidal)'
            if 'E_EQUIV_PLAST.SEC.BOT.E' == result_compname:
                result_displayname = 'Bottom Section Equivalent Plastic Strain'
            if 'E_EQUIV_PLAST.SEC.TOP.E' == result_compname:
                result_displayname = 'Top Section Equivalent Plastic Strain'
                '''

            if not self.res_root:
                self.res_root = self.result_tree.AddRoot('Results', 1)
               
                self.result_tree.SetItem3State(self.res_root, True)
                self.result_tree.SetItem3StateValue(self.res_root, wx.CHK_CHECKED)
                
            new_item = None
            new_item_data = None
            instances_exist = 1 < len(result_instance_info)
            instance_name = None

            if instances_exist:       # Instances Exist
                instance_name = result_dsname.replace(result_compname, '')
                if result_model != 0 and self.model_suffix_enabled:
                    instance_name = instance_name + ':' + str(result_model)

            if result_displayname_compname_pair not in self.result_comp_dict:
                new_item = self.result_tree.AppendItem(self.res_root, 
                        result_displayname, 1)
                
                if instances_exist:
                    new_item_data = [result_compname, result_datatype,
                        [[result_index, instance_name, check_by_default, result_model, result_inst_name]], 999999, res_trans_prop]
                else:
                    new_item_data = [result_compname, result_datatype, None, result_index, res_trans_prop]
                new_item.SetData(new_item_data)
                # self.result_tree.CheckItem(new_item, check_by_default)
                self.result_comp_dict[result_displayname_compname_pair] = new_item
                self.result_tree.SetItem3State(new_item, True)
                self.result_tree.SetItem3StateValue(new_item, wx.CHK_CHECKED)
                
            elif instances_exist:       # Instances Exist
                existing_item = self.result_comp_dict[result_displayname_compname_pair]
                existing_item_data = existing_item.GetData()
                if result_datatype != existing_item_data[1]:
                    raise Exception("\nERROR: Data types not matching")
                item_instance_exists = False;
                for existing_item_data_instance in existing_item_data[2]:
                    if existing_item_data_instance[0] == result_index and existing_item_data_instance[3] == result_model:
                        item_instance_exists = True

                if not item_instance_exists:
                    existing_item_data[2].append([result_index, instance_name, check_by_default, result_model, result_inst_name])
                    #print result_inst_name
                    
                    existing_item.SetData(existing_item_data)
            


    def UpdateLists(self, metadata_tree):
        # self.ClearAll()
        # self.part_tree.ClearAll()
        for parent in metadata_tree.iter():
            for child in parent:
                if "part" == child.tag:
                    self.AddPart(child)
                if "result" == child.tag:
                    self.AddResult(child)
        if self.res_root:
            self.UpdateDerivedTypeLists()

        for k in self.classifier_node_names:
            v = self.classifier_nodes[k]
            # self.part_tree.Expand(v)
            self.part_tree.ExpandAll()
        if self.part_root:
            # self.update()self.features_root
            self.part_tree.ExpandAll()
        if self.res_root:
            # self.result_tree.Expand(self.res_root)
            self.result_tree.ExpandAll()
    def UpdateSortState(self):
        ctype = self.choice_types.GetChoice()
        sstate = self.sort_states[ctype]

        new_state = None
        if sstate == SORT_STATE_NOT_APPLIED:
            new_state = SORT_STATE_ASCENDING
        elif self.sort_states[ctype] == SORT_STATE_ASCENDING:
            new_state = SORT_STATE_DESCENDING
        elif self.sort_states[ctype] == SORT_STATE_DESCENDING:
            new_state = SORT_STATE_NOT_APPLIED
        
        if new_state is None:
            return

        self.sort_states[ctype] = new_state
        self.UpdateSortTool()
        self.TreeSortUpdate()

    def TreeSortUpdate(self):
        ctype = self.choice_types.GetChoice()
        sstate = self.sort_states[ctype]

        tree_sort_type = None
        if sstate == SORT_STATE_NOT_APPLIED:
            tree_sort_type = ct.SORT_ORDER_INSERTED
        elif sstate == SORT_STATE_ASCENDING:
            tree_sort_type = ct.SORT_ORDER_ASCENDING
        elif sstate == SORT_STATE_DESCENDING:
            tree_sort_type = ct.SORT_ORDER_DESCENDING

        if tree_sort_type is None:
            return

        if ctype == GEOM_TREE:
            self.SortPartTree(tree_sort_type)
        elif ctype == RESULT_TREE:
            self.SortResultTree(tree_sort_type)

    def SortPartTree(self, sort_order):
        self.part_tree.SetSortOrder(sort_order)
        if self.part_root:
            self.part_tree.SortChildren(self.part_root)
            # if self.part_root:
            #     self.part_tree.SortChildren(self.part_root)
            if self.part_root:
                self.part_tree.SortChildren(self.part_root)
            if self.features_root:
                self.part_tree.SortChildren(self.features_root)
            if self.feature_edges_root:
                self.part_tree.SortChildren(self.feature_edges_root)
            if self.cutsec_root:
                self.part_tree.SortChildren(self.cutsec_root)
            if self.isosurf_root:
                self.part_tree.SortChildren(self.isosurf_root)
            if self.isovol_root:
                self.part_tree.SortChildren(self.isovol_root)
            if self.flowlines_root:
                self.part_tree.SortChildren(self.flowlines_root)
            if self.classifier_node_names:
                for k in self.classifier_node_names:
                    v = self.classifier_nodes[k]
                    if v:
                        self.part_tree.SortChildren(v)

    def SortResultTree(self, sort_order):
        self.result_tree.SetSortOrder(sort_order)
        if self.res_root:
            self.result_tree.SortChildren(self.res_root)
                
    def SetResultProperties(self, res_trans_prop):
        self.type_rb.SetSelection(res_trans_prop[0])
        self.type_rb.Enable(True)
        if self.model_file.lower().endswith(('.rst', '.rth')):
            if self.sep_partsets:
                self.type_rb.Enable(False)
        if res_trans_prop[1]:
            val = res_trans_prop[2]
            for item in self.layer_objects:
                checkbox = item['checkbox']
                checkbox.Enable(True)
                if val & item['value']: 
                    checkbox.SetValue(True)
                else:
                    checkbox.SetValue(False)
        else:
            for item in self.layer_objects:
                checkbox = item['checkbox']
                checkbox.SetValue(False)
                checkbox.Enable(False)

    def GetLayerSelection(self):
        val = 0
        for item in self.layer_objects:
            checkbox = item['checkbox']
            if item['checkbox'].GetValue():
                val = val | item['value'] 

        return val

    def UncheckODBTreeNodes(self, parent_item):
        part_name_list = [ part_item.GetData()[1] for part_item in parent_item]
        for part_item in parent_item:
            part_name = part_item.GetData()[1]
            if self.odb_all_elements_off:
                if part_name == ' ALL ELEMENTS' or part_name.startswith('WarnElem'):
                    self.part_tree.CheckItem(part_item, False)
            if self.odb_duplicate_set_instances_off:
                inst_set_split = part_name.split('.')
                if len(inst_set_split) > 1:
                    set_name = inst_set_split[1]
                    if set_name in part_name_list:
                        self.part_tree.CheckItem(part_item, False)

    def ApplyCheckDefaults(self):
        if 'Abaqus ODB' != self.file_type:
            return

        if not self.part_root:
            return

        if self.classifier_node_names:
            for k in self.classifier_node_names:
                v = self.classifier_nodes[k]
                self.UncheckODBTreeNodes(v.GetChildren())
        else:
            self.UncheckODBTreeNodes(self.part_root.GetChildren())

    def CreateDerivedTypeList(self, item):
        item_data = item.GetData()
        item_comp = item_data[0]
        item_type = item_data[1]
        item_inst_data = item_data[2]

        derived_type_list = DerivedTypeSettings[item_type]
        check_by_default = True
        if derived_type_list:
            for dt_name in derived_type_list:
                dt_item = self.result_tree.AppendItem(item,
                                dt_name, 1)

                dt_item_data = [item_comp, 'Scalar', item_inst_data, 
                        derived_type_list.index(dt_name)+1, None]
                # self.result_tree.CheckItem2(dt_item, check_by_default)
                self.result_tree.SetItem3State(dt_item, True)
                self.result_tree.SetItem3StateValue(dt_item, wx.CHK_CHECKED)
                dt_item.SetData(dt_item_data)
                

    def UpdateDerivedTypeLists(self):
        (nextchild, cookie) = self.result_tree.GetFirstChild(self.res_root)
        while nextchild:
            self.CreateDerivedTypeList(nextchild)
            (nextchild, cookie) = self.result_tree.GetNextChild(
                            self.res_root, cookie)

    def InstanceUpdateOld(self):
        selections = self.result_tree.GetSelections()
        sel_instance_list = []
        all_checked = True
        all_unchecked = True
        if 0 < len(selections):
            for item in selections:
                if self.result_tree.GetRootItem() != item and self.result_tree.GetRootItem() != item.GetParent():
                    data = item.GetData()
                    if data[2]:
                        for instance in data[2]:
                            sel_instance_list.append(instance[1])
                            if instance[2]:
                                all_unchecked = False
                            else:
                                all_checked = False

        if sel_instance_list:
            self.instance_listbox.ClearAll()
            for instance_str in uniqueList(sel_instance_list):
                state = tclb.TriState_PartChecked
                if all_checked:
                    state = tclb.TriState_Checked
                if all_unchecked:
                    state = tclb.TriState_NotChecked
                index = self.instance_listbox.InsertItem(sys.maxint, state)
                self.instance_listbox.SetItem(index, 1, instance_str)
            self.manager.GetPane('Instance List').Show()


    def InstanceUpdate(self):
        self.manager.GetPane('Instance List').Hide()
        selections = self.result_tree.GetSelections()
        instance_data_list = []
        if 0 < len(selections):
            for item in selections:
                if self.res_root == item.GetParent():
                    data = item.GetData()
                    instance_data = data[2]
                    if instance_data:
                        instance_data_list.extend(instance_data)

        if 0 == len(instance_data_list):
            return
        
        self.instance_listbox.DeleteAllItems()
        instance_data_dict = {}
        instance_label_dict = {}
        # print('hello')
        
        for instance in instance_data_list:
            instance_name = instance[1]
            instance_state = instance[2]
            inst_label = instance[4]

            if instance_state:
                instance_check_tristate = tclb.TriState_Checked
            else:
                instance_check_tristate = tclb.TriState_NotChecked

            if instance_name not in instance_data_dict:
                instance_data_dict[instance_name] = instance_check_tristate
                instance_label_dict[instance_name] = inst_label
            elif instance_data_dict[instance_name] != instance_check_tristate:
                instance_data_dict[instance_name] = tclb.TriState_PartChecked
        
        # if self.instance_listbox:
        #     self.instance_listbox.ClearAll()
        instance_list = instance_data_dict #instance_data_dict.keys()
        SortInstances(instance_data_dict)#instance_list)
        instance_list = instance_data_dict.keys()
        idx=0
        index=0
        for instance in instance_list:
            inst_label = instance_label_dict[instance]
            instance_str = instance.replace(':', 'L', 1).replace(':', 'M', 1)
   
            tristate = instance_data_dict[instance]
       
            index = self.instance_listbox.InsertItem(idx,instance_str)#, 
             
            setitem = self.instance_listbox.SetItem(index,1,instance_str)
            self.instance_listbox.CheckItem(index)
            idx+=1

        self.manager.GetPane('Instance List').Show()
        # self.manager.Update()


    def GetInstanceStrings(self, item, trans_string):
        avg_type = 0
        if item.IsChecked():
            data = item.GetData()
            label = item.GetText()

            res_trans_prop = data[4]
            mask = 0
            if None != res_trans_prop:
                if res_trans_prop[0] == 1:
                    mask = 256
                elif res_trans_prop[0] == 2:
                    mask = 512
                if res_trans_prop[0] == 0 and (data[0] == 'THICKNESS.EL'  or data[0] == 'THICKNESS.E'):
                    mask = 512
                if res_trans_prop[0] == 0 and (data[0] == 'SFM.EL'  or data[0] == 'SFM.E'):
                    mask = 512

            if data[2]:
                for instance in data[2]:
                    if instance[2]:
                        trans_string += str(instance[0]) + '\t'
                        trans_string += str(instance[3]) + '\t'
                        if data[3] == 999999:
                            trans_string += '2\t%d\t-1\t' %(res_trans_prop[2] | mask)
                        else:
                            trans_string += '2\t%d\t%d\t' %(res_trans_prop[2] | mask, data[3])
                        trans_string += str(label) + ' ' + instance[1] + '\n'
            else:
                trans_string += str(data[3]) 
                trans_string += '\t0\t3\t%d\t-1\t%d\t' %(0 | mask, avg_type)
                trans_string += str(label) + '\n'
        return trans_string

    def InvokeUpgradeOdbWizard(self, odb_file, odb_version):
        wizard_message = APP_NAME_VER + ' supports Abaqus .odb files of version ' + odb_version + ' only.\n\n'
        wizard_message = wizard_message + 'Input file "' + odb_file + '" belongs to a older version.\n\n' 
        wizard_message = wizard_message + 'Please provide the upgrade file path to proceed, or cancel to stop.'
        self.wizard_text.SetLabel(label=wizard_message)
        self.wizard_text.Wrap(300)
        self.wizard_text.SetFont(wx.Font(14, wx.FONTFAMILY_DEFAULT, 
            wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))

        upgrade_file = odb_file.replace('.odb', '_v'+odb_version+'.odb')
        self.wizard_textctrl.ChangeValue(upgrade_file)

        if self.wizard.RunWizard(self.wizard_page):
            return self.wizard_textctrl.GetValue()
        else:
            return None

    def GetOdbUpgradeWizardMessageOld(self, odb_file, odb_version):
        wizard_message = APP_NAME_VER + ' supports Abaqus .odb files of version ' + odb_version + ' only.\n\n'
        wizard_message = wizard_message + 'Input file "' + odb_file + '" belongs to a older version.\n\n' 
        wizard_message = wizard_message + 'Please provide the upgrade file path to proceed, or cancel to stop.'
        return wizard_message

    def GetOdbUpgradeWizardMessage(self, odb_file, odb_version):
        wizard_message = 'Input file "' + odb_file + '" is generated from an older Abaqus version. ' 
        wizard_message = wizard_message + 'VMoveCAE needs to upgrade this to an Abaqus ODB file of version ' + odb_version + ' to load the model.\n\n'
        wizard_message = wizard_message + 'The upgraded file will be deleted after the use. Please change the destination folder to skip the deletion and retain it for future use.\n'
        return wizard_message

    def UpgradeOdbWizard(self, odb_file, odb_version):
        self.upgraded_odb_file = os.path.join(self.tmpdir.getPath(), 
                    os.path.basename(odb_file).replace(
                        '.odb', '_v'+odb_version+'.odb'))

        if self.odb_upgrade_wizard_skip_on:
            return self.upgraded_odb_file

        wizard = wiz(self, self.Id_Wizard, 'Upgrade ODB file',
                    WizardIcon.GetBitmap())
        wizard_message = self.GetOdbUpgradeWizardMessage(odb_file,
                odb_version)
        
        wizard_page = WizardPageSimple(wizard)
        wizard_text = wx.StaticText(wizard_page, wx.NewIdRef(count=1), 
                            wizard_message, wx.Point(5, 5))

        wizard_text.Wrap(300)
        wizard_text.SetFont(wx.Font(14, wx.FONTFAMILY_DEFAULT, 
            wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))

        self.wizard_textctrl = wx.TextCtrl(wizard_page, 
                        self.Id_Wizard_TextCtrl, self.upgraded_odb_file)

        self.wizard_textctrl.SetMinSize(wx.Size(280, 30))

        wizard_button = wx.Button(wizard_page, 
                        self.Id_Wizard_Button, 'Browse ...')
        wizard_button.SetMinSize(wx.Size(80, 30))

        file_sizer = wx.BoxSizer(wx.HORIZONTAL)
        file_sizer.Add(self.wizard_textctrl)
        file_sizer.AddSpacer(20)
        file_sizer.Add(wizard_button)
    
        main_sizer = wx.BoxSizer(wx.VERTICAL)
        main_sizer.Add(wizard_text, 0, wx.EXPAND|wx.ALL, 5)
        main_sizer.Add(file_sizer, 0, wx.EXPAND|wx.ALL, 5)

        wizard_page.SetSizer(main_sizer)
        main_sizer.Fit(wizard_page)
        wizard.FitToPage(wizard_page)
        wizard.GetPageAreaSizer().Add(wizard_page)
        wizard_button.Bind(wx.EVT_BUTTON, self.OnWizardBrowse)

        back_btn = wizard.FindWindowById(wx.ID_BACKWARD)
        if back_btn:
            back_btn.Hide()

        if wizard.RunWizard(wizard_page):
            upgraded_odb_file = self.wizard_textctrl.GetValue()
        else:
            upgraded_odb_file = None

        wizard.Destroy()
        self.wizard_textctrl = None
        return upgraded_odb_file

    def OnWizardBrowse(self, event):
        file = self.wizard_textctrl.GetValue()
        wild_cards = 'ABAQUS ODB files (*.odb)|*.odb|All Files (*.*)|*.*'
        dlg = wx.FileDialog(self, message='Select ODB file path',
            defaultDir=os.getcwd(), defaultFile=file, wildcard=wild_cards,
            style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT | wx.FD_CHANGE_DIR)

        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPath()
            if path:
                self.wizard_textctrl.ChangeValue(path)

    def ClearAllUI(self):
        for k in self.classifier_node_names:
            v = self.classifier_nodes[k]
            self.part_tree.DeleteChildren(v)
        self.classifier_nodes.clear()
        self.classifier_node_names = []
        if self.geom_root:
            self.part_tree.Delete(self.geom_root)
      
        if self.res_root:
            self.result_tree.Delete(self.res_root)

        self.instance_listbox.DeleteAllItems()
        self.result_comp_dict = {}
        self.geom_root = None
        self.part_root = None
        self.features_root = None
        self.cutsec_root = None
        self.isosurf_root = None
        self.flowlines_root = None
        self.egroups_root = None
        self.isovol_root = None
        self.res_root = None
        self.prop_root = None
        self.feature_edges_root = None
        self.manager.GetPane('Cut-Section').Hide()
        self.manager.GetPane('Iso-Surface').Hide()
        self.manager.GetPane('Flow Lines').Hide()
        self.manager.GetPane('Iso-Volume').Hide()
        self.manager.GetPane('Element Grouping').Hide()
        self.manager.GetPane('Feature Edges').Hide()
  
        self.features_toolbar.EnableTool(self.Id_Cut, False)
        self.features_toolbar.EnableTool(self.Id_Iso, False)
        self.features_toolbar.EnableTool(self.Id_Stream, False)
        self.features_toolbar.EnableTool(self.Id_EGroup, False)
        self.features_toolbar.EnableTool(self.Id_IsoVolume, False)

    def DestroyLoaded(self):
        self.engine.DestroyDataManager()
        self.ClearAllUI()
        #self.model_file = None
        #self.results_file = None
        self.file_type = 'Unknown'

    def AddFeatureEdges(self):
        if not self.feature_edges_root:
            if not self.features_root:
                # self.features_root = self.part_tree.AddRoot('Features', 1)
                self.features_root = self.part_tree.AppendItem(self.geom_root, 
                            'Features', 1)
                self.part_tree.SetItem3State(self.features_root, True)
                self.part_tree.SetItem3StateValue(self.features_root, wx.CHK_CHECKED)

            self.feature_edges_root = self.part_tree.AppendItem(
                            self.features_root, 'Feature Edges', 1)
            self.part_tree.SetItem3State(self.feature_edges_root, True)
            self.part_tree.SetItem3StateValue(self.feature_edges_root, wx.CHK_CHECKED)
            # self.part_tree.SetItem3State(self.feature_edges_root, True)
            # self.part_tree.SetItem3StateValue(self.feature_edges_root, wx.CHK_CHECKED)
            (nextchild, cookie) = self.part_tree.GetFirstChild(self.geom_root)
            while nextchild:
                data = nextchild.GetData()
                label = nextchild.GetText()
                (nextchild, cookie) = self.part_tree.GetNextChild(
                            self.geom_root, cookie)
                item = self.part_tree.AppendItem(self.feature_edges_root, 
                            label, 1)
                
                self.part_tree.SetItem3State(item, True)
                self.part_tree.SetItem3StateValue(item , wx.CHK_CHECKED)
                
                feature_data = data
                feature_data.append(self.feature_textctrl.GetValue().encode(
                        self.mb_encoding))
                item.SetData(feature_data)
                self.part_tree.CheckItem(item)
            self.part_tree.Expand(self.feature_edges_root)
            self.part_tree.Expand(self.features_root)
        else:
            wx.MessageBox("Feature Edges Exist", "Information!")

    def AddCutSection(self, cutsec_name):
        if not self.features_root:
    
            self.features_root = self.part_tree.AppendItem(self.geom_root, 
                            'Features', 1)
            self.part_tree.SetItem3State(self.features_root, True)
            self.part_tree.SetItem3StateValue(self.features_root, wx.CHK_CHECKED)
        if not self.cutsec_root:
            self.cutsec_root = self.part_tree.AppendItem(self.features_root, 
                            'Cut-Sections', 1)
            self.part_tree.SetItem3State(self.cutsec_root, True)
            self.part_tree.SetItem3StateValue(self.cutsec_root, wx.CHK_CHECKED)
            
        item = self.part_tree.AppendItem(self.cutsec_root, cutsec_name, 1)
        self.part_tree.SetItem3State(item , True)
        self.part_tree.SetItem3StateValue(item , wx.CHK_CHECKED)
        
        item.SetData([-1, cutsec_name])
        self.part_tree.CheckItem(item)
        self.part_tree.Expand(self.cutsec_root)
        self.part_tree.Expand(self.features_root)
    
    def AddIsoSurface(self, isosurf_name):
        if not self.features_root:
            # self.features_root = self.part_tree.AddRoot('Features', 1)
            self.features_root = self.part_tree.AppendItem(self.geom_root, 
                            'Features', 1)
            self.part_tree.SetItem3State(self.features_root, True)
            self.part_tree.SetItem3StateValue(self.features_root, wx.CHK_CHECKED)
        if not self.isosurf_root:
            self.isosurf_root = self.part_tree.AppendItem(self.features_root, 
                            'Iso-Surfaces', 1)
            self.part_tree.SetItem3State(self.isosurf_root, True)
            self.part_tree.SetItem3StateValue(self.isosurf_root, wx.CHK_CHECKED)
        item = self.part_tree.AppendItem(self.isosurf_root, isosurf_name, 1)
        
        self.part_tree.SetItem3State(item, True)
        self.part_tree.SetItem3StateValue(item, wx.CHK_CHECKED)
        self.SetIsoProp(item)
        self.part_tree.CheckItem(item)
        self.part_tree.Expand(self.isosurf_root)
        self.part_tree.Expand(self.features_root)
        

    def SetIsoProp(self, iso_item):
        selections = self.result_tree.GetSelections()
        if len(selections) != 1:
            return

        res_item = None
        res_parent = None
        res_data = None
        for item in selections:
            res_item = item
            res_parent = item.GetParent()
            res_data = item.GetData()

        surf_num = -2
        ref_item = res_item
        if res_parent != self.res_root:
            surf_num -= res_data[3]
            ref_item = res_parent
        isosurf_name = res_data[0] + '=' + self.iso_textctrl.GetValue()
        iso_item.SetData([surf_num, isosurf_name, ref_item])
        isosurf_name = self.iso_static_text.GetLabel() + self.iso_textctrl.GetValue()

    def AddIsoVolume(self, isovol_name):
        if not self.features_root:
            # self.features_root = self.part_tree.AddRoot('Features', 1)
            self.features_root = self.part_tree.AppendItem(self.geom_root, 
                            'Features', 1)
            self.part_tree.SetItem3State(self.features_root, True)
            self.part_tree.SetItem3StateValue(self.features_root, wx.CHK_CHECKED)
            
        if not self.isovol_root:
            self.isovol_root = self.part_tree.AppendItem(self.features_root, 
                            'Iso-Volumes', 1)
            self.part_tree.SetItem3State(self.isovol_root, True)
            self.part_tree.SetItem3StateValue(self.isovol_root, wx.CHK_CHECKED)
            
        item = self.part_tree.AppendItem(self.isovol_root, isovol_name, 1)
        self.part_tree.SetItem3State(item, True)
        self.part_tree.SetItem3StateValue(item, wx.CHK_CHECKED)
            
        self.SetIsoVolProp(item)
        self.part_tree.CheckItem(item)
        self.part_tree.Expand(self.isovol_root)
        self.part_tree.Expand(self.features_root)

    def SetIsoVolProp(self, isovol_item):
        selections = self.result_tree.GetSelections()
        if len(selections) != 1:
            return

        res_item = None
        res_parent = None
        res_data = None
        for item in selections:
            res_item = item
            res_parent = item.GetParent()
            res_data = item.GetData()

        vol_num = -2
        ref_item = res_item
        if res_parent != self.res_root:
            vol_num -= res_data[3]
            ref_item = res_parent
        isovol_name = res_data[0] + '=(' + self.isovol_textctrl.GetValue() + ')'
        isovol_item.SetData([vol_num, isovol_name, ref_item])
        isovol_name = self.isovol_static_text.GetLabel() + '(' + self.isovol_textctrl.GetValue() + ')'

    def AddFlowLines(self):
        if not self.flowlines_root:
            if not self.features_root:
                # self.features_root = self.part_tree.AddRoot('Features', 1)
                self.features_root = self.part_tree.AppendItem(self.geom_root, 
                            'Features', 1)
                self.part_tree.SetItem3State(self.features_root, True)
                self.part_tree.SetItem3StateValue(self.features_root, wx.CHK_CHECKED)

            self.flowlines_root = self.part_tree.AppendItem(
                            self.features_root, 'Flow Lines', 1)
            self.part_tree.SetItem3State(self.flowlines_root, True)
            self.part_tree.SetItem3StateValue(self.flowlines_root, wx.CHK_CHECKED)
                
        selections = self.result_tree.GetSelections()
        if 1 == len(selections):
            for item in selections:
                label = item.GetText()
                parent = item.GetParent()
                parent_label = parent.GetText()
                data = item.GetData()
                flowline_name = 'From ' + str(self.starting_textctrl.GetValue())
                flowline_item = self.part_tree.AppendItem(
                            self.flowlines_root, flowline_name , 1)
                self.part_tree.SetItem3State(flowline_item, True)
                self.part_tree.SetItem3StateValue(flowline_item, wx.CHK_CHECKED)
                fl_data = []
                if self.streamline_button.GetValue():
                    fl_data.append(-1)
                else:
                    fl_data.append(-2)
                #fl_data.append(data[0])
                fl_data.append(item)

                stval = str(self.starting_textctrl.GetValue())
                prefix = ''
                if '(' == stval[0]:
                     prefix = 'Point ' + stval
                else:
                    part_name = stval
                    part_num = 0
                    for part_item in self.part_root.GetChildren():
                        if part_item.GetText() == part_name:
                            part_num = part_item.GetData()[0]
                        for child_item in part_item.GetChildren():
                            if child_item.GetText() == part_name:
                                part_num = child_item.GetData()[0]
                    prefix = 'Part id ' + str(part_num)
                fl_data.append(prefix)

                fl_data.append(int(self.starting_numlines.GetValue()))
                if self.flowline_button.GetValue():
                    fl_data.append(self.timestep_textctrl.GetValue())
                    fl_data.append(int(self.steps_textctrl.GetValue()))
                    fl_data.append(int(self.injection_textctrl.GetValue()))

                flowline_item.SetData(fl_data)
                self.part_tree.CheckItem(flowline_item)

                self.part_tree.Expand(self.flowlines_root)
                self.part_tree.Expand(self.features_root)

    def ApplyFlowLines(self):
        selections = self.result_tree.GetSelections()
        if 1 == len(selections):
            for item in selections:
                label = item.GetText()
                parent = item.GetParent()
                parent_label = parent.GetText()
                data = item.GetData()
                flowline_name = 'From ' + str(self.starting_textctrl.GetValue())
                flowline_item = self.part_tree.AppendItem(
                            self.flowlines_root, flowline_name , 1)
                self.part_tree.SetItem3State(flowline_item, True)
                self.part_tree.SetItem3StateValue(flowline_item, wx.CHK_CHECKED)
                fl_data = []
                if self.streamline_button.GetValue():
                    fl_data.append(-1)
                else:
                    fl_data.append(-2)
                #fl_data.append(data[0])
                fl_data.append(item)

                stval = str(self.starting_textctrl.GetValue())
                prefix = ''
                if '(' == stval[0]:
                     prefix = 'Point ' + stval
                else:
                    part_name = stval
                    part_num = 0
                    for part_item in self.part_root.GetChildren():
                        if part_item.GetText() == part_name:
                            part_num = part_item.GetData()[0]
                        for child_item in part_item.GetChildren():
                            if child_item.GetText() == part_name:
                                part_num = child_item.GetData()[0]
                    prefix = 'Part id ' + str(part_num)
                fl_data.append(prefix)

                fl_data.append(int(self.starting_numlines.GetValue()))
                if self.flowline_button.GetValue():
                    fl_data.append(self.timestep_textctrl.GetValue())
                    fl_data.append(int(self.steps_textctrl.GetValue()))
                    fl_data.append(int(self.injection_textctrl.GetValue()))

                flowline_item.SetData(fl_data)
                self.part_tree.CheckItem(flowline_item)

                self.part_tree.Expand(self.flowlines_root)
                self.part_tree.Expand(self.features_root)

    def AddAttribute(self):
        key = self.attr_name_textctrl.GetValue()
        value = self.attr_value_textctrl.GetValue()

        if key in  self.attributes_dict:
            wx.MessageBox("Attribute exists. Please click 'Apply' to change the value", 'Notice!')
            return

        if not key:
            wx.MessageBox('Attribute name not defined!', 'Notice!')
            return

        if not value:
            wx.MessageBox('Attribute value not defined!', 'Notice!')
            return

        self.attributes_dict[key] = value
        self.attributes_listbox.InsertItems([key],0)# SetFirstItem([key])
        self.attributes_listbox.EnsureVisible(self.attributes_listbox.FindString(key))
        # FindString
        self.attributes_listbox.SetStringSelection(key, True)
        self.attr_apply_button.Enable(True)
        self.attr_delete_button.Enable(True)

    def DeleteAttribute(self):
        selected_index = self.attributes_listbox.GetSelection()
        selected_key = self.attributes_listbox.GetString(selected_index)
        self.attributes_listbox.Delete(selected_index)

        del self.attributes_dict[selected_key]

        self.attr_apply_button.Enable(False)
        self.attr_delete_button.Enable(False)

    def AlterAttribute(self):
        selected_index = self.attributes_listbox.GetSelection()
        selected_key = self.attributes_listbox.GetString(selected_index)

        new_key = self.attr_name_textctrl.GetValue()
        new_value = self.attr_value_textctrl.GetValue()

        if new_key == selected_key:
            self.attributes_dict[selected_key] = new_value
        else:
            if new_key in self.attributes_dict:
                wx.MessageBox("Attribute exists. Can't alter attribute properties", 'Notice!')
                return

            self.DeleteAttribute()
            self.AddAttribute()

    def GetDomainLimit(self, axis, which):
        extent = { ('x', 0) : 0.0, 
                   ('x', 1) : 0.0, 
                   ('y', 0) : 0.0, 
                   ('y', 1) : 0.0, 
                   ('z', 0) : 0.0, 
                   ('z', 1) : 0.0 }
        try:
            extent_str = self.engine.GetGlobalDomainExtent()
            extent_tree = et.fromstring(extent_str)
            if 'domain' == extent_tree.tag:
                min_ls = extent_tree.get('min', '0,0,0').split(',')
                max_ls = extent_tree.get('max', '0,0,0').split(',')
                extent[ ('x', 0) ] = float(min_ls[0])
                extent[ ('y', 0) ] = float(min_ls[1])
                extent[ ('z', 0) ] = float(min_ls[2])
                extent[ ('x', 1) ] = float(max_ls[0])
                extent[ ('y', 1) ] = float(max_ls[1])
                extent[ ('z', 1) ] = float(max_ls[2])
        except Exception as ex:
            pass

        return extent[ (axis.lower(), which) ] 
            
    def ProcessCutSectionInput(self, value):
        sep_loc = value.find("=")
        axis_name = value[0:sep_loc]
        axis_val_str = None
        if -1 != axis_val_str:
            axis_val_str = value[sep_loc+1:]
        axis_name.strip()
        axis_vals = []
        for val in axis_val_str.split(':', 4):
            val.strip()
            axis_vals.append(str(val))
        vlen = len(axis_vals)
        from_next = False
        to_next = False
        try:
            if axis_vals[0]:
                cs_from = float(axis_vals[0])
            else:
                cs_from = self.GetDomainLimit(axis_name, 0)
                from_next = True

            if vlen < 3:
                return axis_name, [cs_from]

            if axis_vals[1]:
                cs_to = float(axis_vals[1])
            else:
                cs_to = self.GetDomainLimit(axis_name, 1)
                to_next = True

            cs_num = int(axis_vals[2])
            if from_next:
                cs_num = cs_num + 1
            if to_next:
                cs_num = cs_num + 1
            if cs_num < 2:
                wx.MessageBox('Number of cut-section lines should be greater than one')
                return None, None
            cs_inc = (cs_to - cs_from)/(cs_num - 1)
            vlist = []
            if from_next:
                cs_from = cs_from + cs_inc
                cs_num = cs_num - 1
            if to_next:
                cs_to = cs_to - cs_inc
                cs_num = cs_num - 1
            for num in range(cs_num):
                vlist.append(cs_from + num * cs_inc)
            return axis_name, vlist
        except:
            return None, None

    def OpenPreferencesDialog(self):
        dlg = PreferenceDialog(self, -1, 'VMoveCAE Settings', 
                    size=(450, 250), style=wx.DEFAULT_DIALOG_STYLE)

        settings_dict = {
                 self.local_file_caching_key: self.enable_local_file_caching,
                 self.ignore_midnodes_key: self.ignore_midnodes,
                 #self.disable_parts_key: self.disable_parts,

                 self.sep_partsets_key: self.sep_partsets,
                 self.element_results_key: self.elem_res_trans,
                 self.entoe_key: self.en_to_e_avg,
                 self.odb_all_elements_key: self.odb_all_elements_off,
                 self.odb_duplicate_set_instances_key:
                       self.odb_duplicate_set_instances_off,
                 self.odb_fast_load_key: self.odb_fast_load_on,
                 self.odb_load_zero_frames_key: self.odb_load_zero_frames_on,
                 self.odb_load_internal_sets_key: self.odb_load_internal_sets_on,
                 self.odb_load_instance_parts_key: self.odb_load_instance_parts_on,
                 self.abaqus_input_sets_prompt_key: self.abaqus_input_sets_prompt_on,
                 self.odb_upgrade_wizard_skip_key: self.odb_upgrade_wizard_skip_on,
                 self.ansys_input_commands_prompt_key: self.ansys_input_commands_prompt_on,
                 self.marc_experimental_features_key: self.marc_experimental_features_on,
                 self.results_use_instances_key: self.results_use_instances_on,
                 self.results_instance_title_key: self.results_instance_title_value,
                 #self.bdf_use_sets_key: self.bdf_use_sets_on,
                 #self.disable_parts_key: self.disable_parts,
                 self.op2_enable_rigid_rotation_node_key: self.op2_enable_rigid_rotation_node_value,
                 self.op2_rigid_rotation_node_index_key: self.op2_rigid_rotation_node_index,
                 self.encoding_key: self.mb_encoding,
                 self.interface_info_key: self.interface_info,
                 self.interface_grouping_key: {},
                 self.nodal_averaged_loads_key: self.nodal_averaged_loads_on,
                 #self.extract_mode_properties_key: self.extract_mode_properties_on,
         }

        for interface in self.interface_info.interfaces:
            settings_dict[self.interface_grouping_key][interface] = self.interface_grouping[interface]

        dlg.SetPreferences(settings_dict)
        dlg.CenterOnScreen()

        # this does not return until the dialog is closed.
        state = dlg.ShowModal()
    
        if state == wx.ID_OK:
            settings_dict = dlg.GetPreferences()
            self.enable_local_file_caching = settings_dict[self.local_file_caching_key]
            self.ignore_midnodes = settings_dict[self.ignore_midnodes_key]
            #self.disable_parts = settings_dict[self.disable_parts_key]
            self.sep_partsets = settings_dict[self.sep_partsets_key]
            self.elem_res_trans = settings_dict[self.element_results_key]
            self.en_to_e_avg = settings_dict[self.entoe_key]
            #self.mb_encoding = settings_dict[self.encoding_key]
            self.odb_all_elements_off = settings_dict[self.odb_all_elements_key]
            self.odb_duplicate_set_instances_off = settings_dict[self.odb_duplicate_set_instances_key]
            self.odb_fast_load_on = settings_dict[self.odb_fast_load_key]
            self.odb_load_zero_frames_on = settings_dict[self.odb_load_zero_frames_key]
            self.odb_load_internal_sets_on = settings_dict[self.odb_load_internal_sets_key]
            self.odb_load_instance_parts_on = settings_dict.get(self.odb_load_instance_parts_key, False)
            self.abaqus_input_sets_prompt_on = settings_dict[self.abaqus_input_sets_prompt_key]
            self.odb_upgrade_wizard_skip_on = settings_dict[self.odb_upgrade_wizard_skip_key]
            self.ansys_input_commands_prompt_on = settings_dict[self.ansys_input_commands_prompt_key]
            self.marc_experimental_features_on = settings_dict[self.marc_experimental_features_key]
            self.results_use_instances_on = settings_dict[self.results_use_instances_key]
            self.results_instance_title_value = settings_dict.get(self.results_instance_title_key,self.engine.DefaultResultsInstanceTitle())
            #self.bdf_use_sets_on = settings_dict[self.bdf_use_sets_key]
            if self.op2_enable_rigid_rotation_node_key in settings_dict:
                self.op2_enable_rigid_rotation_node_value = settings_dict[self.op2_enable_rigid_rotation_node_key]
            if self.op2_rigid_rotation_node_index_key in settings_dict:
                self.op2_rigid_rotation_node_index = settings_dict[self.op2_rigid_rotation_node_index_key]
            if self.interface_grouping_key in settings_dict:
                for interface, grouping_type in settings_dict[self.interface_grouping_key].items():
                    self.interface_grouping[interface] = grouping_type
            self.nodal_averaged_loads_on = settings_dict[self.nodal_averaged_loads_key]
            #self.extract_mode_properties_on = settings_dict[self.extract_mode_properties_key]

            self.cfg.Write(self.local_file_caching_key, str(self.enable_local_file_caching))
            self.cfg.Write(self.ignore_midnodes_key, str(self.ignore_midnodes))
            #self.cfg.Write(self.disable_parts_key, str(self.disable_parts))
            self.cfg.Write(self.sep_partsets_key, str(self.sep_partsets))
            self.cfg.Write(self.element_results_key, str(self.elem_res_trans))
            self.cfg.Write(self.entoe_key, str(self.en_to_e_avg))
            #self.cfg.Write(self.encoding_key, str(self.mb_encoding))
            self.cfg.Write(self.odb_all_elements_key, str(self.odb_all_elements_off))
            self.cfg.Write(self.odb_duplicate_set_instances_key, str(self.odb_duplicate_set_instances_off))
            self.cfg.Write(self.odb_fast_load_key, str(self.odb_fast_load_on))
            self.cfg.Write(self.odb_load_zero_frames_key, str(self.odb_load_zero_frames_on))
            self.cfg.Write(self.odb_load_internal_sets_key, str(self.odb_load_internal_sets_on))
            self.cfg.Write(self.odb_load_instance_parts_key, str(self.odb_load_instance_parts_on))
            self.cfg.Write(self.abaqus_input_sets_prompt_key, str(self.abaqus_input_sets_prompt_on))
            self.cfg.Write(self.odb_upgrade_wizard_skip_key, str(self.odb_upgrade_wizard_skip_on))
            self.cfg.Write(self.ansys_input_commands_prompt_key, str(self.ansys_input_commands_prompt_on))
            self.cfg.Write(self.marc_experimental_features_key, str(self.marc_experimental_features_on))
            self.cfg.Write(self.results_use_instances_key, str(self.results_use_instances_on))
            self.cfg.Write(self.results_instance_title_key, str(self.results_instance_title_value))
            #self.cfg.Write(self.bdf_use_sets_key, str(self.bdf_use_sets_on))
            self.cfg.Write(self.op2_enable_rigid_rotation_node_key, str(self.op2_enable_rigid_rotation_node_value))
            self.cfg.Write(self.op2_rigid_rotation_node_index_key, str(self.op2_rigid_rotation_node_index))
            for interface, grouping_type in self.interface_grouping.items():
                self.cfg.Write(self.part_grouping_key_prefix + interface, grouping_type)
            self.cfg.Write(self.nodal_averaged_loads_key, str(self.nodal_averaged_loads_on))
            #self.cfg.Write(self.extract_mode_properties_key, str(self.extract_mode_properties_on))

        dlg.Destroy()
        
    def FlowLinesRadio(self, state):
        self.timestep_static_text.Enable(state)
        self.timestep_textctrl.Enable(state)

        self.steps_static_text.Enable(state)
        self.steps_textctrl.Enable(state)

        self.injection_static_text.Enable(state)
        self.injection_textctrl.Enable(state)

    def AddResultGroup(self, event):
        checked = event.IsChecked()
        if not self.features_root:
            # self.features_root = self.part_tree.AddRoot('Features', 1)
            self.features_root = self.part_tree.AppendItem(self.geom_root, 
                            'Features', 1)
            self.part_tree.SetItem3State(self.features_root, True)
            self.part_tree.SetItem3StateValue(self.features_root, wx.CHK_CHECKED)

        if not self.egroup_root:
            self.egroup_root = self.part_tree.AppendItem(self.features_root, 
                            'Element Groups', 1)
            self.part_tree.SetItem3State(self.egroup_root, True)
            self.part_tree.SetItem3StateValue(self.egroup_root, wx.CHK_CHECKED)
        self.part_tree.Expand(self.features_root)

        result_selections = self.result_tree.GetSelections()

        instance_selections = []
        for num in range(self.instance_listbox.GetItemCount()):
            if self.instance_listbox.IsSelected(num):
                instance_selections.append(
                        self.instance_listbox.GetItem(num, 1).GetText())

        for ritem in result_selections:
            for iitem in instance_selections:
                egroup_name = ritem.GetText() + ' ' + iitem + ' Specified'

                egroup_data = None

                for result_data in ritem.GetData()[2]:
                    instance_str = result_data[1].replace(':', 'L', 1).replace(':', 'M', 1)
                    if instance_str == iitem:
                        egroup_data = result_data[0]

                found = False
                for existing_item in self.egroup_root.GetChildren():
                    if existing_item.GetData() == egroup_data:
                        self.part_tree.CheckItem(existing_item, checked)
                        found = True

                if not found:
                    egroup_item = self.part_tree.AppendItem(self.egroup_root, 
                                                        egroup_name, 1)
                    self.part_tree.SetItem3State(egroup_item, True)
                    self.part_tree.SetItem3StateValue(egroup_item, wx.CHK_CHECKED)
                    egroup_item.SetData(egroup_data)
                    self.part_tree.CheckItem(egroup_item, True)
                    self.part_tree.Expand(self.egroup_root)
                    
        return

    def AddNoResultGroup(self, event):
        checked = event.IsChecked()
        if not self.egroup_root:
            self.egroup_root = self.part_tree.AppendItem(self.part_root, 
                            'Element Groups', 1)

        result_selections = self.result_tree.GetSelections()

        instance_selections = []
        for num in range(self.instance_listbox.GetItemCount()):
            if self.instance_listbox.IsSelected(num):
                instance_selections.append(
                        self.instance_listbox.GetItem(num, 1).GetText())

        for ritem in result_selections:
            for iitem in instance_selections:
                egroup_name = ritem.GetText() + ' ' + iitem + ' Not Specified'

                egroup_data = None

                for result_data in ritem.GetData()[2]:
                    instance_str = result_data[1].replace(':', 'L', 1).replace(':', 'M', 1)
                    if instance_str == iitem:
                        egroup_data = result_data[0]

                found = False
                for existing_item in self.egroup_root.GetChildren():
                    if existing_item.GetData() == -egroup_data:
                        self.part_tree.CheckItem(existing_item, checked)
                        found = True

                if not found:
                    egroup_item = self.part_tree.AppendItem(self.egroup_root, 
                                                        egroup_name, 1)
                    egroup_item.SetData(-egroup_data)
                    self.part_tree.CheckItem(egroup_item, True)
                    self.part_tree.Expand(self.egroup_root)
                    
        return

#---------------------------------------------------------------------------

class PreferenceDialog(wx.Dialog):
    def __init__(self, parent, ID, title, 
                    size=wx.DefaultSize, pos=wx.DefaultPosition, 
                    style=wx.DEFAULT_DIALOG_STYLE):

        wx.Dialog.__init__(self, parent, ID, title, pos, size, style)

        self.local_file_caching_key = 'InputFilecaching'
        self.ignore_midnodes_key = 'IgnoreMidNodes'
        #self.disable_parts_key = 'DisableParts'
        self.sep_partsets_key = 'SeparatePartSets'
        self.element_results_key = 'ElementResults'
        self.entoe_key = 'EN_to_E'
        self.encoding_key = 'Encoding'

        self.odb_all_elements_key = 'UncheckAllElementsSet'
        self.odb_duplicate_set_instances_key = 'UncheckDuplicateSetInstances'
        self.odb_fast_load_key = 'ODBFastLoad'
        self.odb_load_zero_frames_key = 'ODBZeroFramesLoad'
        self.odb_load_internal_sets_key = 'ODBLoadInternalSets'
        self.odb_load_instance_parts_key = 'ODBLoadInstanceParts'
        self.abaqus_input_sets_prompt_key = 'AbaqusInputSetsPrompt'
        self.odb_upgrade_wizard_skip_key = 'ODBUpgradeWizardSkip'
        self.ansys_input_commands_prompt_key = 'AnsysInputCommandsPrompt'
        self.marc_experimental_features_key = 'MarcExperimentalFeatures'
        self.results_use_instances_key = 'ResultsUseInstances'
        self.results_instance_title_key = 'ResultsInstanceTitle'
        #self.bdf_use_sets_key = 'BdfUseSets'
        self.op2_enable_rigid_rotation_node_key = 'Op2EnableRigidRotationNode'
        self.op2_rigid_rotation_node_index_key = 'Op2RigidRotationNodeIndex'
        self.op2_rigid_rotation_var_enabled = parent.op2_rigid_rotation_var_enabled
        self.op2_default_rigid_rotation_node_index = parent.op2_default_rigid_rotation_node_index
        self.interface_info_key = 'InterfaceInfo'
        self.interface_info = None
        self.interface_grouping_key = 'InterfaceGrouping'
        self.interface_grouping = {}
        self.nodal_averaged_loads_key = 'NodalAveragedLoads'
        #self.extract_mode_properties_key = 'ExtractModeProperties'

        # Now continue with the normal construction of the dialog
        # contents
        sizer = wx.BoxSizer(wx.VERTICAL)

        general_settings = wx.StaticBox(self, -1, "General Settings")
        general_sizer = wx.StaticBoxSizer(general_settings, wx.VERTICAL)
        self.midnode_checkbox = wx.CheckBox(self, -1, "Ignore mid-nodes")
        #self.disable_parts_checkbox = wx.CheckBox(self, -1, "Disable Parts")
        self.local_file_caching_checkbox = wx.CheckBox(self, -1, "Cache input files to temporary files folder")
        #self.no_e_result_averging_checkbox = wx.CheckBox(self, -1, "Do not average elemental results")
        #self.average_en_to_e_checkbox = wx.CheckBox(self, -1, "Average element nodal results to element results")
        self.nodal_averaged_loads_checkbox = wx.CheckBox(self, -1, "Nodal averaged Loads")
        #self.extract_mode_properties_checkbox = wx.CheckBox(self, -1, "Extract mode properties")
        self.part_config = wx.Button(self, -1, "Part Grouping");

        #enc_sizer = wx.BoxSizer(wx.HORIZONTAL)
        #self.encoding_statictext = wx.StaticText(self, -1, self.encoding_key)
        #self.encoding_textctrl = wx.TextCtrl(self, wx.ID_ANY, "",
        #                size=wx.Size(120,-1))
        #enc_sizer.Add(self.encoding_statictext, 0, 
        #                wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        #enc_sizer.Add(self.encoding_textctrl, 0, 
        #                wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)

        general_sizer.Add(self.midnode_checkbox, 0, 
                        wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        #general_sizer.Add(self.disable_parts_checkbox, 0, 
        #                wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        general_sizer.Add(self.local_file_caching_checkbox, 0, 
                        wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        #general_sizer.Add(self.no_e_result_averging_checkbox, 0, 
        #                wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        #general_sizer.Add(self.average_en_to_e_checkbox, 0, 
        #                wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        #general_sizer.Add(enc_sizer, 0, 
        #                wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        general_sizer.Add(self.nodal_averaged_loads_checkbox, 0, 
                        wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        #general_sizer.Add(self.extract_mode_properties_checkbox, 0, 
        #                wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        general_sizer.Add(self.part_config, 0, 
                        wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        self.part_config.Bind(wx.EVT_BUTTON, self.SetPartGrouping)

        sizer.Add(general_sizer, 0, wx.EXPAND|wx.ALL, 5)

        odb_settings = wx.StaticBox(self, -1, "Default ODB file Settings")
        odb_sizer = wx.StaticBoxSizer(odb_settings, wx.VERTICAL)

        self.odb_all_elements_off_checkbox = wx.CheckBox(self, -1, 'Uncheck " All Elements" set')
        self.odb_duplicate_set_instances_off_checkbox = wx.CheckBox(self, -1, 'Uncheck Duplicate Set Instances')
        self.odb_fast_load_checkbox = wx.CheckBox(self, -1, 'ODB fast load')
        self.odb_load_zero_frames_checkbox = wx.CheckBox(self, -1, 'Load frames numbered zero')
        self.odb_load_internal_sets_checkbox = wx.CheckBox(self, -1, 'Load internal sets')
        #self.odb_load_instance_parts_checkbox = wx.CheckBox(self, -1, 'Load Instance Parts')

        odb_sizer.Add(self.odb_all_elements_off_checkbox, 0, wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        odb_sizer.Add(self.odb_duplicate_set_instances_off_checkbox, 0, wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        odb_sizer.Add(self.odb_fast_load_checkbox, 0, wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        odb_sizer.Add(self.odb_load_zero_frames_checkbox, 0, wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        odb_sizer.Add(self.odb_load_internal_sets_checkbox, 0, wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        #odb_sizer.Add(self.odb_load_instance_parts_checkbox, 0, wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)

        self.abaqus_input_sets_prompt_checkbox = wx.CheckBox(self, -1, 'Prompt for Abaqus input file')
        odb_sizer.Add(self.abaqus_input_sets_prompt_checkbox, 0, wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)

        self.odb_upgrade_wizard_skip_checkbox = wx.CheckBox(self, -1, 'Auto upgrade Abaqus ODB files')
        odb_sizer.Add(self.odb_upgrade_wizard_skip_checkbox, 0, wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        sizer.Add(odb_sizer, 1, wx.EXPAND|wx.ALL, 5)

        ansys_settings = wx.StaticBox(self, -1, "Default Ansys file Settings")
        ansys_sizer = wx.StaticBoxSizer(ansys_settings, wx.VERTICAL)

        self.partsets_checkbox = wx.CheckBox(self, -1, "No averaging across materials")
        self.ansys_input_commands_prompt_checkbox = wx.CheckBox(self, -1, 'Prompt for Ansys input commands file')

        ansys_sizer.Add(self.partsets_checkbox, 0, wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        ansys_sizer.Add(self.ansys_input_commands_prompt_checkbox, 0, wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)

        sizer.Add(ansys_sizer, 0, wx.EXPAND|wx.ALL, 5)

        marc_settings = wx.StaticBox(self, -1, "Default MSC.Marc Result Settings")
        marc_sizer = wx.StaticBoxSizer(marc_settings, wx.VERTICAL)

        self.marc_experimental_checkbox = wx.CheckBox(self, -1, "Experimental Marc Features")

        marc_sizer.Add(self.marc_experimental_checkbox, 0, wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        sizer.Add(marc_sizer, 0, wx.EXPAND|wx.ALL, 5)

        results_file_settings = wx.StaticBox(self, -1, "Default Results File Settings")
        results_file_settings_sizer = wx.StaticBoxSizer(results_file_settings, wx.VERTICAL)
        self.results_instance_checkbox = wx.CheckBox(self, -1, "Instance results files")
        #self.results_instance_textctrl = wx.TextCtrl(self, -1, 'L')
        results_file_settings_sizer.Add(self.results_instance_checkbox, 0, wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        #results_file_settings_sizer.Add(self.results_instance_textctrl, 0, wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        sizer.Add(results_file_settings_sizer, 0, wx.EXPAND|wx.ALL, 5)

        nastran_sizer_required = False
        if self.op2_rigid_rotation_var_enabled:
            nastran_sizer_required = True

        if nastran_sizer_required:
            nastran_settings = wx.StaticBox(self, -1, "Default Nastran File Settings")
            nastran_sizer = wx.StaticBoxSizer(nastran_settings, wx.VERTICAL)
            sizer.Add(nastran_sizer, 0, wx.EXPAND|wx.ALL, 5)

            #self.bdf_use_sets_checkbox = wx.CheckBox(self, -1, "Create Parts based on BDF Sets")
            #nastran_sizer.Add(self.bdf_use_sets_checkbox, 0, wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)

        if self.op2_rigid_rotation_var_enabled:
            self.op2_enable_rigid_rotation_checkbox = wx.CheckBox(self, -1, "Rigid body rotation from virtual node results")
            self.op2_rigid_rotation_node_index_static_text = wx.StaticText(self, wx.ID_ANY, 'Virtual Node Id', size=wx.Size(100, 30))
            self.op2_rigid_rotation_node_index_text_ctrl   = wx.TextCtrl(self, wx.ID_ANY, str(self.op2_default_rigid_rotation_node_index ))

            op2_rigid_index_sizer = wx.BoxSizer(wx.HORIZONTAL)
            op2_rigid_index_sizer.AddStretchSpacer()
            op2_rigid_index_sizer.Add(self.op2_rigid_rotation_node_index_static_text, 0, wx.ALL, 5)
            op2_rigid_index_sizer.Add(self.op2_rigid_rotation_node_index_text_ctrl, 0, wx.ALL, 5)
            op2_rigid_index_sizer.AddStretchSpacer()

            nastran_sizer.Add(self.op2_enable_rigid_rotation_checkbox, 0, wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
            nastran_sizer.Add(op2_rigid_index_sizer, 0, wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)

        line = wx.StaticLine(self, -1, size=(20,-1), style=wx.LI_HORIZONTAL)
        sizer.Add(line, 0, wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.RIGHT|wx.TOP, 5)

        button_sizer = wx.StdDialogButtonSizer()

        save_button = wx.Button(self, wx.ID_OK)
        save_button.SetDefault()
        button_sizer.AddButton(save_button)

        close_button = wx.Button(self, wx.ID_CANCEL)
        button_sizer.AddButton(close_button)

        button_sizer.Realize()

        sizer.Add(button_sizer, 0, wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)

        self.SetSizer(sizer)
        sizer.Fit(self)

    def SetPreferences(self, dict):
        self.local_file_caching_checkbox.SetValue(dict[self.local_file_caching_key])
        self.midnode_checkbox.SetValue(dict[self.ignore_midnodes_key])
        #self.disable_parts_checkbox.SetValue(dict[self.disable_parts_key])
        self.partsets_checkbox.SetValue(dict[self.sep_partsets_key])
        #self.no_e_result_averging_checkbox.SetValue(dict[self.element_results_key])
        #self.average_en_to_e_checkbox.SetValue(dict[self.entoe_key])
        #self.encoding_textctrl.SetValue(dict[self.encoding_key])
        self.odb_all_elements_off_checkbox.SetValue(dict[self.odb_all_elements_key])
        self.odb_duplicate_set_instances_off_checkbox.SetValue(dict[self.odb_duplicate_set_instances_key])
        self.odb_fast_load_checkbox.SetValue(dict[self.odb_fast_load_key])
        self.odb_load_zero_frames_checkbox.SetValue(dict[self.odb_load_zero_frames_key])
        self.odb_load_internal_sets_checkbox.SetValue(dict[self.odb_load_internal_sets_key])
        #self.odb_load_instance_parts_checkbox.SetValue(dict[self.odb_load_instance_parts_key])
        self.abaqus_input_sets_prompt_checkbox.SetValue(dict[self.abaqus_input_sets_prompt_key])
        self.odb_upgrade_wizard_skip_checkbox.SetValue(dict[self.odb_upgrade_wizard_skip_key])
        self.ansys_input_commands_prompt_checkbox.SetValue(dict[self.ansys_input_commands_prompt_key])
        self.marc_experimental_checkbox.SetValue(dict[self.marc_experimental_features_key])
        self.results_instance_checkbox.SetValue(dict[self.results_use_instances_key])
        #self.results_instance_textctrl.SetValue(dict[self.results_instance_title_key])
        #self.bdf_use_sets_checkbox.SetValue(dict[self.bdf_use_sets_key])
        if self.op2_rigid_rotation_var_enabled:
            self.op2_enable_rigid_rotation_checkbox.SetValue(dict[self.op2_enable_rigid_rotation_node_key])
            self.op2_rigid_rotation_node_index_text_ctrl.SetValue(str(dict[self.op2_rigid_rotation_node_index_key]))
        self.interface_info = dict[self.interface_info_key]
        self.interface_grouping = dict[self.interface_grouping_key]
        self.nodal_averaged_loads_checkbox.SetValue(dict[self.nodal_averaged_loads_key])
        #self.extract_mode_properties_checkbox.SetValue(dict[self.extract_mode_properties_key])

    def GetPreferences(self):
        dict = {}
        dict[self.local_file_caching_key] = self.local_file_caching_checkbox.GetValue()
        dict[self.ignore_midnodes_key] = self.midnode_checkbox.GetValue()
        #dict[self.disable_parts_key] = self.disable_parts_checkbox.GetValue()
        dict[self.sep_partsets_key] = self.partsets_checkbox.GetValue()
        #dict[self.element_results_key] = self.no_e_result_averging_checkbox.GetValue()
        #dict[self.entoe_key] = self.average_en_to_e_checkbox.GetValue()
        dict[self.element_results_key] = False
        dict[self.entoe_key] = False
        #dict[self.encoding_key] = self.encoding_textctrl.GetValue()
        dict[self.odb_all_elements_key] = self.odb_all_elements_off_checkbox.GetValue()
        dict[self.odb_duplicate_set_instances_key] = self.odb_duplicate_set_instances_off_checkbox.GetValue()
        dict[self.odb_fast_load_key] = self.odb_fast_load_checkbox.GetValue()
        dict[self.odb_load_zero_frames_key] = self.odb_load_zero_frames_checkbox.GetValue()
        dict[self.odb_load_internal_sets_key] = self.odb_load_internal_sets_checkbox.GetValue()
        #dict[self.odb_load_instance_parts_key] = self.odb_load_instance_parts_checkbox.GetValue()
        dict[self.abaqus_input_sets_prompt_key] = self.abaqus_input_sets_prompt_checkbox.GetValue()
        dict[self.odb_upgrade_wizard_skip_key] = self.odb_upgrade_wizard_skip_checkbox.GetValue()
        dict[self.ansys_input_commands_prompt_key] = self.ansys_input_commands_prompt_checkbox.GetValue()
        dict[self.marc_experimental_features_key] = self.marc_experimental_checkbox.GetValue()
        dict[self.results_use_instances_key] = self.results_instance_checkbox.GetValue()
        #dict[self.results_instance_title_key] = self.results_instance_textctrl.GetValue()
        #dict[self.bdf_use_sets_key] = self.bdf_use_sets_checkbox.GetValue()
        if self.op2_rigid_rotation_var_enabled:
            dict[self.op2_enable_rigid_rotation_node_key] = self.op2_enable_rigid_rotation_checkbox.GetValue()
            dict[self.op2_rigid_rotation_node_index_key] = int(self.op2_rigid_rotation_node_index_text_ctrl.GetValue())
        dict[self.interface_info_key] = self.interface_info
        dict[self.interface_grouping_key] = self.interface_grouping
        dict[self.nodal_averaged_loads_key] = self.nodal_averaged_loads_checkbox.GetValue()
        #dict[self.extract_mode_properties_key] = self.extract_mode_properties_checkbox.GetValue()

        return dict

    def SetPartGrouping(self, event):
        dlg = PartGroupingDialog(self, -1, 'Part Grouping', 
                    self.interface_info, self.interface_grouping,
                    size=(400, 300), style=wx.DEFAULT_DIALOG_STYLE)
        dlg.CenterOnScreen()

        # this does not return until the dialog is closed.
        state = dlg.ShowModal()
    
        if state == wx.ID_OK:
            part_grouping_options = dlg.GetPartGroupingOptions()
            for key, value in part_grouping_options.items():
                self.interface_grouping[key] = value

        dlg.Destroy()

#----------------------------------------------------------------------------

class PartGroupingTabPanel(wx.Panel):

    def __init__(self, parent, option_labels, current_option):
        wx.Panel.__init__(self, parent=parent)

        self.radio_box = wx.RadioBox(self, -1, "Part Grouping type", 
                wx.DefaultPosition, wx.DefaultSize, option_labels, 
                1, wx.RA_SPECIFY_COLS)
        self.radio_box.SetMinSize(wx.Size(180, 200))

        sizer = wx.BoxSizer(wx.HORIZONTAL)
        sizer.Add(self.radio_box, 0, wx.EXPAND|wx.ALL, 5)
        self.SetSizer(sizer)
        self.radio_box.SetSelection(current_option)

    def SetGroupingType(self, option):
        self.radio_box.SetSelection(option)

    def GetGroupingType(self):
        return self.radio_box.GetSelection()

#----------------------------------------------------------------------------

class PartGroupingDialog(wx.Dialog):
    def __init__(self, parent, ID, title, 
                    interface_info, interface_grouping,
                    size=wx.DefaultSize, pos=wx.DefaultPosition, 
                    style=wx.DEFAULT_DIALOG_STYLE):

        wx.Dialog.__init__(self, parent, ID, title, pos, size, style)

        # initialize class attributes
        self.interface_info = interface_info
        self.grouping_types = interface_info.enabled_grouping_types
        grouping_type_names = [interface_info.grouping_type_labels[type] for type in self.grouping_types]
        self.part_grouping_options = {}
        self.tab_panels = {}
        self.interface_grouping = interface_grouping

        # Now continue with the normal construction of the dialog
        # contents
        sizer = wx.BoxSizer(wx.VERTICAL)

        notebook = wx.Listbook(self, -1, size=(400, 300), style = wx.NB_LEFT)
        notebook.GetListView().SetColumnWidth(0, 200)
        for item in interface_info.enabled_grouping_option_interfaces:
            grouping_type = self.interface_grouping[item]
            if grouping_type not in interface_info.enabled_grouping_types:
                grouping_type = interface_info.GetGroupingDefault()
            self.part_grouping_options[item] = grouping_type
            self.tab_panels[item] = PartGroupingTabPanel(notebook,
                    grouping_type_names, 
                    self.grouping_types.index(grouping_type))
            notebook.AddPage(self.tab_panels[item], interface_info.interface_labels[item])
        #self.Bind(wx.EVT_LISTBOOK_PAGE_CHANGED, self.OnPageChanged)
        #self.Bind(wx.EVT_LISTBOOK_PAGE_CHANGING, self.OnPageChanging)
        sizer.AddSpacer(5)
        sizer.Add(notebook, 0, wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
        sizer.AddSpacer(5)

        line = wx.StaticLine(self, -1, size=(20,-1), style=wx.LI_HORIZONTAL)
        sizer.Add(line, 0, wx.GROW|wx.ALIGN_CENTER_VERTICAL, 5)

        #button_sizer = wx.StdDialogButtonSizer()
        button_sizer = wx.BoxSizer(wx.HORIZONTAL)

        save_button = wx.Button(self, wx.ID_OK)
        #button_sizer.AddButton(save_button)
        button_sizer.Add(save_button, 0, wx.ALL, 5)

        close_button = wx.Button(self, wx.ID_CANCEL)
        #button_sizer.AddButton(close_button)
        button_sizer.Add(close_button, 0, wx.ALL, 5)

        reset_button = wx.Button(self, -1, "Reset")
        #button_sizer.AddButton(reset_button)
        button_sizer.Add(reset_button, 0, wx.ALL, 5)
        reset_button.Bind(wx.EVT_BUTTON, self.OnReset)

        defaults_button = wx.Button(self, -1, "Defaults")
        #button_sizer.AddButton(defaults_button)
        button_sizer.Add(defaults_button, 0, wx.ALL, 5)
        defaults_button.Bind(wx.EVT_BUTTON, self.OnSetToDefaults)

        #button_sizer.Realize()

        sizer.Add(button_sizer, 0, wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)

        self.SetSizer(sizer)
        sizer.Fit(self)

    def OnReset(self, event):
        for item in self.interface_info.enabled_grouping_option_interfaces:
            self.tab_panels[item].SetGroupingType(
                    self.grouping_types.index(self.interface_grouping[item].decode()))

    def OnSetToDefaults(self, event):
        grouping_default = self.interface_info.GetGroupingDefault()
        def_index = self.grouping_types.index(grouping_default)
        for item in self.interface_info.enabled_grouping_option_interfaces:
            self.tab_panels[item].SetGroupingType(def_index)

    def OnPageChanged(self, event):
        old = event.GetOldSelection()
        new = event.GetSelection()
        #sel = notebook.GetSelection()
        event.Skip()

    def GetPartGroupingOptions(self):
        for item, panel in self.tab_panels.items():
            self.part_grouping_options[item] = self.grouping_types[panel.GetGroupingType()]
        return self.part_grouping_options
            
#----------------------------------------------------------------------------

class CustomChoice(wx.Choice):
    def __init__(self, parent, id=wx.ID_ANY,
                    pos=wx.DefaultPosition, size=wx.DefaultSize,
                    choices = [], style=0):
        wx.Choice.__init__(self, parent, id, pos, size, choices, style)

        SelectionTypes = ["Geometry", "Results", "Instances"]
        AllChoiceTypes = ["All", "Invert", "Selected", "Deselected",
                               "Checked", "Unchecked"]
        self.ChoiceDict = {
            'Types'   : [0, SelectionTypes],
            'Default' : [0, AllChoiceTypes],
#            'Geometry': [0, AllChoiceTypes + [ "Parts", "Features", 
#                            "Cut-Sections", "Iso-Surfaces"]],
#            'Results': [0, AllChoiceTypes + [ "Scalars", "Vectors", 
#                            "SixDof", "Tensors"]],
            'Geometry': [0, AllChoiceTypes],
            'Results': [0, AllChoiceTypes],
            'Instances': [0, AllChoiceTypes]
            }

        self._type = 'Default'
        self.Activate(self._type)

    def Activate(self, name):
        self._type = name
        #self.ChoiceDict[self._type][0] = self.GetSelection()
        self.Clear()
        for item in self.ChoiceDict[self._type][1]:
            self.Append(item)
        self.SetSelection(self.ChoiceDict[self._type][0])

    def GetActive(self):
        return self._type

    def OptionChanged(self):
        self.ChoiceDict[self._type][0] = self.GetSelection()

    def GetChoice(self):
        return self.ChoiceDict[self._type][1][self.GetSelection()]

#----------------------------------------------------------------------------

DerivedTypeSettings = { 'Scalar': [],
                        'Vector': ['X', 'Y', 'Z', 'Magnitude'],
                        'SixDof' : ['TX', 'TY', 'TZ',
                                'RX', 'RY', 'RZ', 'TMag', 'RMag'],
                        'Tensor': ['XX', 'YY', 'ZZ', 'XY', 'YZ', 'ZX',
                                'Mean', 'Von Mises',
                                #'Von Mises Strain', 
                                'Octahedral Shear',
                                'Maximum Principal', 
                                'Middle Principal', 
                                'Minimum Principal', 
                                'Maximum Shear', 
                                'Equal Direct at Maximum Shear', 
                                'Intensity', 
                                'Determinant']}

#----------------------------------------------------------------------------

#class DerivedTypeListBox(wx.HtmlListBox):
class DerivedTypeListBox(SimpleHtmlListBox):
    def __init__(self, parent, id=wx.ID_ANY, 
                    pos=wx.DefaultPosition, size=wx.DefaultSize, 
                    type = 'Vector',
                    style=wx.BORDER_SUNKEN|wx.LB_MULTIPLE):
        self._type = type
        self._item = DerivedTypeSettings[self._type]
        self._itemstate = []
        for dt in self._item:
            self._itemstate.append(tclb.TriState_Checked)
        
        wx.HtmlListBox.__init__(self, parent, id, pos, size, style)
        self.SetItemCount(len(self._item))
        self.SelectChecked()
        self.Bind(wx.EVT_LISTBOX, self.OnClick)
        #self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftClick)

    def GetItems(self):
        return self._item

    def OnGetItem(self, n):
        itemstate = self._itemstate[n]
        if tclb.TriState_NotChecked == itemstate:
            return self._item[n]
        elif tclb.TriState_PartChecked == itemstate:
            return "<font color='GREY'>" + self._item[n] + "</font>"
        else:
            return "<font color='RED'>" + self._item[n] + "</font>"


    def SelectChecked(self):
        for x in range(self.GetItemCount()):
            if tclb.TriState_Checked == self._itemstate[x]:
                self.Select(x, True)
            else:
                self.Select(x, False)

    def OnClick(self, event):
        for x in range(self.GetItemCount()):
            if self.IsSelected(x):
                self._itemstate[x] = tclb.TriState_Checked
                self.RefreshLine(x)
            elif tclb.TriState_PartChecked != self._itemstate[x]:
                self._itemstate[x] = tclb.TriState_NotChecked
                self.RefreshLine(x)
        
    def OnLeftClick(self, event):
        pt = event.GetPosition()
        flags = 0
        item = self.HitTest(pt)
        if wx.NOT_FOUND == item:
            return
        for x in range(self.GetItemCount()):
            if item != x and self.IsSelected(x):
                self.Select(item, True)
        if self.IsSelected(x):
            self.Select(x, False)
        else:
            self.Select(x, True)

#----------------------------------------------------------------------------

class VMoveApp(wx.App, wx.lib.mixins.inspection.InspectionMixin):
    def __init__(self, option_list, file_list):
        #wx.EvtHandler.AddFilter(self)
        self.engine = None
        self.option_list = option_list
        self.file_list = file_list
        wx.App.__init__(self, redirect=False)

    #def __del__(self):
    #    wx.EvtHandler.RemoveFilter(self)

    #def FilterEvent(self, event):
    #    print('Filtering events')
    #    return self.Event_Skip

    def OnInit(self):
        #wx.Log_SetActiveTarget(wx.LogStderr())
        wx.Log.SetActiveTarget(wx.LogStderr())
        #self.SetAssertMode(wx.PYAPP_ASSERT_DIALOG)
        self.SetAssertMode(wx.APP_ASSERT_LOG)
        self.Init()  # InspectionMixin

        os.environ["ABQ_CRTMALLOC"]="1"
        self.engine = CaeEngine.getEngine()

        if '--exclude-geometry' in self.option_list:
            self.engine.ExcludeGeometry(True)

        self.tmpdir = Common.TempFolder()
        self.tmpdir.create()
        try:
            self.tmpdir.clearAllOld(5)
        except Exception:
            pass

        tmp_dir_path = self.tmpdir.getPath()
        self.engine.SetTempFileFolder(tmp_dir_path)
        tr_file = os.path.join(tmp_dir_path, 'vmovecae_trace.log')
        ou_file = os.path.join(tmp_dir_path, 'vmovecae.log')
        er_file = os.path.join(tmp_dir_path, 'vmovecae_errors.log')
        pi_file = os.path.join(tmp_dir_path, 'progress_file.log')

        self.engine.SetLogFile(tr_file)
        self.engine.SetPIFile(pi_file)
        # sys.stdout = open(ou_file, 'w')
        # sys.stderr = open(er_file, 'w')
        self.tmpdir.retainFiles([tr_file, ou_file, er_file])

        license_status = self.engine.AcquireLicense()
        if 'False' == license_status:
            wx.MessageBox('\nLicense not available.\nExiting Application', 
                            'Error!')
        else:
            #cwd = os.getcwd()
            cwd = None  # overriding the cwd read from configuration file
            frame = VmoveCaeFrame(self.engine, self.tmpdir)
            if frame:
                # so set the frame to a good size for showing stuff
                frame.Show(True)
                self.SetTopWindow(frame)
                frame.setCmdLineOptions(self.option_list, self.file_list, cwd)
            else:
                return False

        #wx.Log_SetActiveTarget(wx.LogStderr())
        #wx.Log_SetTraceMask(wx.TraceMessages)
        return True

    def OnExitApp(self, evt):
        if self.engine:
            self.engine.ReleaseLicense()
        if self.tmpdir:
            self.tmpdir.destroy()

    def OnWidgetInspector(self, evt):
        wx.lib.inspection.InspectionTool().Show()

#----------------------------------------------------------------------------

def main(argv):
    os.environ["ABQ_CRTMALLOC"]="1"
    option_list = []
    for option in argv:
        if option.startswith('--'):
            option_list.append(option)

    file_list = []
    for option in argv:
        if not option.startswith('--'):
            file_list.append(option)

    #if "--debug" in option_list:
    #    import pdb
    #    pdb.set_trace()

    VMoveApp(option_list, file_list).MainLoop()

#----------------------------------------------------------------------------

if __name__ == '__main__':
    main(sys.argv)
